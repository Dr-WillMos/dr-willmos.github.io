<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第七章：输入输出系统</title>
    <link href="/posts/Chapter_7_I/O_Systems/"/>
    <url>/posts/Chapter_7_I/O_Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章：输入输出系统"><a href="#第七章：输入输出系统" class="headerlink" title="第七章：输入输出系统"></a>第七章：输入输出系统</h1><p><strong>除了CPU和主存之外的设备都是外围设备，简称外设。</strong></p><p><strong>每个外设都有各自的控制器，也可以称为I/O接口。</strong></p><p><img src="https://s2.loli.net/2026/01/03/w5n4WmeQM8ukvhS.png" alt="image-20260103171311870"></p><p><img src="https://s2.loli.net/2026/01/03/sxUPBrVwR2jHkt3.png" alt="image-20260103171324998"></p><h3 id="机械硬盘（磁盘）"><a href="#机械硬盘（磁盘）" class="headerlink" title="机械硬盘（磁盘）"></a>机械硬盘（磁盘）</h3><p><strong>主存的存储速度很快，但是属于易失性存储器，断电后容易丢失，而且每个sRAM造价很高。</strong></p><p><strong>所以我们需要外存来长期存取数据。</strong></p><p><img src="https://s2.loli.net/2026/01/03/MLmA3YdI9th1zaQ.png" alt="image-20260103171657999"></p><p><strong>机械硬盘的构造如下：</strong></p><p><img src="https://s2.loli.net/2026/01/03/DyFe5Efni2PtKXm.png" alt="image-20260103172127430"></p><p><img src="https://s2.loli.net/2026/01/03/FiuyprHkNgE5Ic6.png" alt="image-20260103172144628"></p><p><strong>位密度：单位长度内存放的二进制数目。</strong></p><p><strong>扇区：就是数学意义上的扇形。</strong></p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>低密度存储（恒定扇区数）</strong></th><th><strong>高密度存储（恒定位密度）</strong></th></tr></thead><tbody><tr><td><strong>分区方式</strong></td><td><strong>将盘面划分为数量相等</strong>的扇形区域</td><td><strong>将盘面划分为弧长相等</strong>的扇形区域</td></tr><tr><td><strong>位密度特性</strong></td><td><strong>内圈位密度高，外圈位密度低磁盘整体位密度不均</strong></td><td><strong>内外圈位密度保持一致磁盘整体位密度恒定</strong></td></tr><tr><td><strong>扇区数量</strong></td><td><strong>每个磁道上的扇区数量相同</strong></td><td><strong>外圈磁道的扇区数量远多于</strong>内圈磁道</td></tr><tr><td><strong>优点</strong></td><td><strong>控制逻辑相对简单（早期技术）</strong></td><td><strong>大幅提升存储容量</strong>，更好地利用外圈空间</td></tr><tr><td><strong>缺点</strong></td><td><strong>存储空间浪费严重（外圈位密度低）</strong></td><td><strong>需要更复杂的磁头和控制算法来读写不同数量的扇区</strong></td></tr></tbody></table><p><img src="https://s2.loli.net/2026/01/03/FYM7WGjiQDgo16B.png" alt="image-20260103172530927"></p><p><img src="https://s2.loli.net/2026/01/03/CWQpsovG29xJTi1.png" alt="image-20260103172922303"></p><h3 id="磁盘的平均存取时间"><a href="#磁盘的平均存取时间" class="headerlink" title="磁盘的平均存取时间"></a>磁盘的平均存取时间</h3><p><strong>一次存取的时间由三部分时间构成：</strong></p><ul><li><strong>寻道时间：磁头从当前位置移动到目标数据所在磁道</strong>所需的时间</li><li><strong>旋转等待时间：磁头到达目标磁道后，等待磁盘旋转，使目标扇区转到磁头下方</strong>所需的时间</li><li><strong>数据传输时间：目标扇区位于磁头下方后，实际读取或写入数据</strong>所花费的时间</li></ul><p><strong>以上三种时间都有最好和最坏情况，只能取平均，作为评判磁盘性能的指标给到消费者。</strong></p><p><img src="https://s2.loli.net/2026/01/03/ov7DYAjzFEtgJfN.png" alt="image-20260103181015576"></p><p><strong>看一道例题：</strong></p><p><img src="https://s2.loli.net/2026/01/03/6JodCpTe7qyB1KW.png" alt="image-20260103181213967"></p><p><img src="https://s2.loli.net/2026/01/03/TGatJglLS5mE1ob.png" alt="image-20260103181739046"></p><h3 id="磁盘驱动器和控制器"><a href="#磁盘驱动器和控制器" class="headerlink" title="磁盘驱动器和控制器"></a>磁盘驱动器和控制器</h3><p><strong>CPU的寄存器很小，需要配合主存来控制磁盘。</strong></p><p><img src="https://s2.loli.net/2026/01/03/UOHNn3wzV6x97vs.png" alt="image-20260103183142943"></p><p><strong>CPU的机器字长是4个字节，那么一共512B的数据就需要传128次（我指的是128个周期），数据经过CPU后放到主存这种传输效率是比较慢的。</strong></p><p><strong>位于主机和磁盘之间的是磁盘控制器，能够翻译地址。</strong></p><p><img src="https://s2.loli.net/2026/01/03/fKF5axiTOsUHJRW.png" alt="image-20260103183533070"></p><p><strong>具体流程如下：</strong></p><p><img src="https://s2.loli.net/2026/01/03/wsuWtLRXF583EQV.png" alt="image-20260103184002764"></p><p><strong>首先，主机通过总线将逻辑块号发送到磁盘控制器翻译地址，同时将主存中的数据的头32位数据传到数据缓冲寄存器。磁盘控制器的电路发出写控制信号，地址翻译模块将翻译后的地址发送到磁盘驱动器进行寻道，完毕后发回结束信号，随即磁头开始定位并匹配，匹配后发回信号，控制器发送写命令，开始读写数据。数据缓冲寄存器的数据送到磁头，主句再将后续的数据经过数据缓冲寄存器写到磁盘。</strong></p><p><strong>总结一下：</strong></p><p><img src="https://s2.loli.net/2026/01/03/NQOYBethqoXvaVZ.png" alt="image-20260103184937070"></p><h3 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h3><p><strong>比机械硬盘更快，但是很贵。</strong></p><p><strong>固态硬盘使用半导体材料制成，是高密度非易失。型存储。但是读取能够马上读取，写需要先擦除再写入，写速度和磁盘差不多，而且擦写是有寿命的</strong></p><p><strong>固态硬盘是用页和块来分区的，CPU通过硬盘控制器来实现对硬盘的管理。</strong></p><p><img src="https://s2.loli.net/2026/01/03/z8bUte5pBSKvXL3.png" alt="image-20260103185343981"></p><p><strong>为了解决擦写寿命短的问题，硬盘控制器引入了磨损均衡，分为两种</strong></p><ul><li><strong>动态磨损均衡：写入数据时，自动选择较新的闪存块。</strong></li><li><strong>静态磨损均衡：就算没有数据写入，SSD也会检测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让新的闪存块腾出空间，承担平常的写操作。</strong></li></ul><h3 id="IO模块的通用接口"><a href="#IO模块的通用接口" class="headerlink" title="IO模块的通用接口"></a>IO模块的通用接口</h3><p><strong>无论是磁盘还是硬盘以及其他的外设，我们都可以把他们的控制器称作是IO接口。</strong></p><p><strong>他们具有一些通用特性，请回忆计网那本书的内容。</strong></p><p><strong>主机想要访问某一设备时，IO桥会将目标设备号广播，直到目标外设回应</strong></p><p><img src="https://s2.loli.net/2026/01/03/zJmniI1E8oPtMGp.png" alt="image-20260103200325016"></p><p><strong>这意味着IO接口要和主机通讯，IO接口中有数据缓冲寄存器，设备状态寄存器，命令控制寄存器等寄存器用数据总线与主机相连。还有设备选择电路用地址总线与主机相连，还有IO控制电路用控制总线与主机相连。</strong></p><p><img src="https://s2.loli.net/2026/01/03/ApQm3jRyLU67Y9F.png" alt="image-20260103200929408"></p><p><strong>比如打印机的IO运行模式：</strong></p><p><img src="https://s2.loli.net/2026/01/03/BO1XKYaembcAzqr.png" alt="image-20260103201032975"></p><p><strong>现在需要把主存中的ABC三个字符打印出来。</strong></p><p><strong>CPU发送启动命令，打印机命令译码器分析，启动打印机，状态寄存器设置为就绪，随即主存的A暂存在eax寄存器，读出打印机为就绪状态，A和打印命令通过数据总线传送到打印机，译码器分析后打印机开始工作，状态设置为busy，CPU将B传到eax寄存器之后不断检查打印机状态，如果为就绪就继续下一个字母。</strong></p><p><strong>循环这个流程，直到完全打印完毕。</strong></p><p><strong>IO端口的编址有独立编址和统一编址。</strong></p><p><strong>独立编址就是基于总线并独立于主存地址，给每个外设分配一个地址，操作时加上OUT或INSERT等关键词来表示对IO设备的操作。这种方式因为IO设备数量不多，寻址快，但是只有输入输出，灵活性差。</strong></p><p><strong>统一编址就是将主存的一部分地址拿出来分配给IO设备，常被精简指令集采用，不需要设置专门的IO指令，只需要经典的访存指令就能满足需求，CPU会自动根据地址的区间来判断具体的操作设备。</strong></p><h3 id="IO程序查询方式"><a href="#IO程序查询方式" class="headerlink" title="IO程序查询方式"></a>IO程序查询方式</h3><p><strong>我们上个例子说到，打印机忙碌时，CPU不断检查打印机状态，这就是一种独占查询方式，CPU必须干等着，利用率很低，即使实时性无可比拟。</strong></p><p><strong>定时查询方式</strong>：CPU启动I/O后，<strong>返回执行正常程序</strong>。同时，一个定时器被设定，每隔固定时间（如每毫秒）产生一次中断，CPU在中断处理程序中查询一次设备状态。利用率较高，但是存在延迟。</p><p><strong>我们以鼠标为例子：</strong></p><p><img src="https://s2.loli.net/2026/01/04/oe9k4mbB37gYTD6.png" alt="image-20260104075518671"></p><p><strong>再以硬盘为例子：</strong></p><p><img src="https://s2.loli.net/2026/01/04/rqW4KEkgCPU78ab.png" alt="image-20260104075649177"></p><p><strong>所以：</strong></p><p><img src="https://s2.loli.net/2026/01/04/tBURdVDMc4f2N7r.png" alt="image-20260104075718827"></p><p><strong>但是我们希望时外设自己执行完命令就主动通知CPU，而不是CPU是不是就要去看一样，那样就可以实现并行运行。</strong></p><p><del>就像我希望老师可以在讲完后主动提醒我这节课签到而不是我一直盯着智慧课堂看他签不签到。</del></p><h3 id="IO程序中断控制方式"><a href="#IO程序中断控制方式" class="headerlink" title="IO程序中断控制方式"></a>IO程序中断控制方式</h3><p><strong>I/O（输入/输出）程序中断控制方式是计算机管理中一种关键的数据交换机制。它的核心思想是变被动等待为主动通知</strong>：CPU启动I/O设备后便可继续执行原有任务，当设备完成操作时主动“打断”CPU，CPU再转去处理这次I/O请求，从而极大提升了工作效率。</p><p><strong>初始化与并行工作</strong>：CPU执行一条I/O指令，启动外部设备（如磁盘读取）。之后，CPU<strong>不再等待</strong>，而是立即返回执行其主程序。此时，<strong>CPU和设备处于并行工作状态</strong>。</p><p><strong>中断请求与响应</strong>：当设备完成数据准备后，它会通过中断请求线向CPU发出一个<strong>中断请求信号</strong>。CPU并非随时响应，而是在<strong>当前指令执行周期结束时</strong>，才会检查是否有中断请求。如果请求有效且未被屏蔽，CPU则会响应中断。</p><p><strong>核心处理与数据传送</strong>：响应中断后，CPU通过<strong>中断向量表</strong>自动定位并执行对应的<strong>中断服务程序</strong>。ISR的核心任务包括从I/O设备的数据寄存器中读取一个字（或字节）的数据，并最终将其存入内存。</p><p><strong>收尾与返回</strong>：数据传送完成后，ISR<strong>中断服务例程</strong>会执行<strong>中断返回指令</strong>。该指令能自动恢复之前保存的现场，使CPU跳回主程序的断点处继续执行</p><p><strong>这一次我们以键盘为例</strong></p><p><img src="https://s2.loli.net/2026/01/05/UprKDSndwVE39Xx.png" alt="image-20260105151315875"></p><p><strong>假设当前CPU正在执行某一程序的某条指令D，下一条指令程序的地址是0x1234，也就是说PC里的地址是0x1234。这时你在键盘上输入了一个字母a，字母a被送到数据寄存器中，同时IO控制电路发送高电平刀中断触发器中，随后CPU在执行完毕指令D之后给中断触发器发送一个中断查询信号，看看有没有外设向CPU发送中断请求。随机中断触发器通过控制总线发送中断信号发送到CPU的中断系统，随即CPU知道键盘有新数据产生，现在需要优先处理键盘数据，所以CPU会执行键盘中断程序。将PC中的值0x1234移动到栈内存中，然后将PC的值设置为键盘中断程序的首条指令的地址0x8888，开始执行程序，键盘中断程序将输入的a移动到主存并将其显示到显示器当中。当键盘中断程序结束后，PC再取回存在栈内存中的0x1234继续执行原程序。</strong></p><blockquote><p><strong>网课还讲了打印机和鼠标的例子，但是没有补充</strong></p></blockquote><p><strong>这种方式一些问题，一个是中断触发器分布在多个IO接口中难以管理，而且cpu一次只能响应一次中断请求，这就产生了类似总线总裁的问题。</strong></p><p><img src="https://s2.loli.net/2026/01/05/q985RLPj6hondiv.png" alt="image-20260105154448281"></p><p><strong>为了解决这个问题，就有了中断控制器，内置介个中断请求寄存器，接到每个外设的中断触发器中。控制器在接收到CPU的中断查询信号时，会将已接收的中断请求通过中断判优电路排序优先级，再通过设备编码器返回编码后的向量地址（存储地址）。</strong></p><p><strong>插播一下跳转，每个子程序的头指令的地址都会放在主存的某个地方并且有一个相应的地址与之对应，比如上图中0x6666对应地址0xCCCC，对应程序打印机中断服务程序。</strong></p><p><strong>比如现在鼠标发出一个中断信号，经过判别电路和编码器生成的中断向量地址0x665F，随后PC值会被转移到栈内存，PC值更新为0x665F，执行，跳转到0x8888，执行鼠标中断服务程序。</strong></p><h3 id="中断控制的条件和步骤"><a href="#中断控制的条件和步骤" class="headerlink" title="中断控制的条件和步骤"></a>中断控制的条件和步骤</h3><p><img src="https://s2.loli.net/2026/01/05/zIursPeDJ6x5fhE.png" alt="image-20260105162424392"></p><p><strong>整个过程分为三部</strong></p><ul><li><strong>中断识别和判优</strong></li><li><strong>中断响应</strong></li><li><strong>中断处理</strong></li></ul><p><strong>CPU响应中断是有条件的</strong></p><ul><li><strong>至少有一个中断请求</strong></li><li><strong>当前指令刚刚执行完</strong></li><li><strong>CPU处于开中断状态</strong></li></ul><p><strong>指令执行完CPU才会发送中断查询信号。</strong></p><h4 id="中断识别与判优"><a href="#中断识别与判优" class="headerlink" title="中断识别与判优"></a>中断识别与判优</h4><p><strong>CPU执行某一条指令完毕时，中断控制器接收到CPU发送的中断查询请求，内部集合，判优，编码中断请求，并发回到CPU中去。</strong></p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p><strong>通过中断隐指令完成，中断隐指令不是一个真正的指令，而是CPU一个自动完成的流程。</strong></p><p><strong>中断隐指令：</strong></p><ul><li><strong>关中断</strong></li><li><ul><li><strong>一个标志，因为CPU一时间只能处理一个请求，当关中断尾关时，CPU不再接收新的请求。</strong></li></ul></li><li><strong>断点与程序状态</strong></li><li><ul><li><strong>断点其实就是当前PC的值，处理中断的时候断点会被放到EPC寄存器（MIPS）或者栈内存（x86）中。程序状态将存放在CPU的标志寄存器中去</strong></li></ul></li><li><strong>寻找中断服务程序入口地址并跳转</strong></li><li><ul><li><strong>就是根据中断控制器传入的向量地址找到中断程序的首条指令的地址</strong></li></ul></li></ul><h4 id="中断处理阶段"><a href="#中断处理阶段" class="headerlink" title="中断处理阶段"></a>中断处理阶段</h4><p><strong>中断处理涉及到控制流程的转移，那么就需要关注原来执行的程序A。</strong></p><p><img src="https://s2.loli.net/2026/01/05/zCwQLdKkjgh8e73.png" alt="image-20260105162726978"></p><p><strong>鼠标中断服务程序执行完了CPU要回到程序A继续执行，就分为以下几个流程。</strong></p><ul><li><strong>保护现场</strong></li><li><ul><li><strong>在刚进入中断服务程序时，通过软件（如PUSH指令）将当前所有通用寄存器（如EAX, EBX等）和程序状态字的值压入系统堆栈保存 。</strong></li></ul></li><li><strong>恢复现场</strong></li><li><ul><li><strong>在中断服务程序结束前，通过软件（如POP指令）将之前压栈的寄存器值按相反顺序弹出到原来的寄存器中 。</strong></li></ul></li><li><strong>开中断</strong></li><li><ul><li><strong>在恢复现场操作之后、执行中断返回指令之前，使用STI等指令将中断标志位重新置位。这通常在中断服务程序的最后阶段进行。</strong></li></ul></li></ul><p><strong>整体流程：</strong></p><p><img src="https://s2.loli.net/2026/01/05/EkAob6QTqgP4uD2.png" alt="image-20260105163544780"></p><p><strong>以上描述的是单中断，以下我们探讨多重中断（嵌套中断）</strong></p><h3 id="多重中断和中断屏蔽字"><a href="#多重中断和中断屏蔽字" class="headerlink" title="多重中断和中断屏蔽字"></a>多重中断和中断屏蔽字</h3><p><strong>多重中断：是指当CPU正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而CPU又响应了这个请求，暂时停止正在的中断服务程序，转去执行新的中断服务程序。</strong></p><p><strong>多重中断的</strong>“关中断”的状态并不是整个中断处理过程中不可改变的，操作系统可以通过软件指令在关键时刻“开中断”，从而允许更高优先级的中断嵌入。</p><p><strong>比如，现在是CPU正在运行鼠标中断服务程序，CPU为了能够接收更高级的中断请求将关中断设置为开</strong>，随即将鼠标中断服务程序的断电保存到其他地方去，执行键盘中断程序，这就实现了多重中断。</p><p><img src="https://s2.loli.net/2026/01/05/3SHTqmkvrKGo9l8.png" alt="image-20260105201502482"></p><p><strong>但是这么做就需要保证：只有优先级更高的中断源请求才可以中断比其级别低的中断服务程序，反之则不然。</strong></p><p><strong>要完成这个逻辑就需要引入中断屏蔽字。</strong></p><p><strong>中断屏蔽字：一组二进制代码，用来控制CPU是否响应某个中断源发出的请求，从而实现对中断处理顺序的精细管理。</strong></p><p><strong>比如有以下四个中断源，那就需要完成这样的逻辑</strong></p><p><img src="https://s2.loli.net/2026/01/05/dJNaEMf5gPS1ryw.png" alt="image-20260105202252241"></p><p><strong>我们就需要这样的中断屏蔽字来实现，在这里，1就是不接受对应外设的中断请求。</strong></p><p><img src="https://s2.loli.net/2026/01/05/JQUXfpA1uZPc8Te.png" alt="image-20260105202941209"></p><p><strong>那么硬件具体如何实现？</strong></p><p><img src="https://s2.loli.net/2026/01/05/GldteyJAUcrowDp.png" alt="image-20260105203324449"></p><p><strong>如图，中断控制器内置一个中断屏蔽字寄存器，现在CPU正在执行C的中断服务程序，当B传出中断请求，控制器的判优电路认为B优先级低，CPU不会响应B的指令。如果是A发送请求，那根据判优电路，A的优先级高，C的断电被保存，控制流程转移，开始执行A的中断服务程序。A的中断服务程序执行完后，开始执行C的中断服务程序。</strong></p><h3 id="磁盘的中断控制"><a href="#磁盘的中断控制" class="headerlink" title="磁盘的中断控制"></a>磁盘的中断控制</h3><p><img src="https://s2.loli.net/2026/01/05/9tFe58ShHjLykBC.png" alt="image-20260105204530798"></p><h2 id="DMA控制方式"><a href="#DMA控制方式" class="headerlink" title="DMA控制方式"></a>DMA控制方式</h2><p><strong>DMA（Direct Memory Access，直接内存访问）是一项重要的计算机技术，它允许外部设备（如硬盘、网卡）与计算机内存之间直接进行数据交换，而无需中央处理器（CPU）频繁介入。</strong></p><p><strong>DMA接口可以位于任何外设当中，比如有能力绕过CPU将数据从磁盘直接移动到主存中，从而减轻CPU开销。</strong></p><p><strong>DMA接口又名DMA控制器，内部构成是：</strong></p><ul><li><strong>AR：Address Register，主存地址寄存器</strong></li><li><strong>WC：Word Count，字计数器</strong></li><li><strong>BR：Buffer Register，数据缓冲寄存器</strong></li><li><strong>DAR：Device Address Register，设备地址寄存器</strong></li><li><strong>其他控制逻辑</strong></li></ul><p><img src="https://s2.loli.net/2026/01/05/JfW9bdP6VX7NeBw.png" alt="image-20260105211356026"></p><p><strong>如图CPU将操作参数传至DMA控制器中后，磁盘准备好一个字的数据传到DMA的BR中，同时发送DMA请求，DMA控制逻辑发送总线申请，主存控制器允许使用总线，DMA发送主存地址和主存读写命令，一个字的数据被传到主存，最后DMA控制逻辑授予磁盘一个DMA周期，主存地址AR和WC也要相应变化，为下一个字做准备。最后发送DMA中断请求，CPU接受后执行DMA中断服务，开始检查传输是否有误等后续工作。</strong></p><p><strong>如果有时候DMA准备使用主存时，CPU已经使用主存。这就产生了冲突。</strong></p><p><strong>解决的第一种方法就是DMA夺权：DMA就会向CPU提出申请让他取消使用主存让出总线控制权，DMA获取控制器完成数据传输后会将控制权还给CPU。但是这种方法会导致CPU在DMA使用总线时进入什么都不做的空窗期。</strong></p><p><strong>第二种是周期挪用：IO设备挪用或者窃取总线占用权一个或几个贮存周期。DMA仅在需要传输数据时</strong>“借用”一个或几个总线周期。若CPU不使用总线，则无冲突；若冲突，则DMA优先（这个时候BR已经是满的，IO设备再等会触发BR覆写，原有数据丢失会导致整体传输失败）</p><p><strong>第三种是DMA和CPU交替访问：将CPU的工作周期强制分时</strong>，一部分专供DMA访存，另一部分专供CPU访存，这样会扩大存储周期</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章：中央处理器</title>
    <link href="/posts/Chapter_6_CPU/"/>
    <url>/posts/Chapter_6_CPU/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章：中央处理器"><a href="#第六章：中央处理器" class="headerlink" title="第六章：中央处理器"></a>第六章：中央处理器</h1><p><strong>全章节学习路线：</strong></p><p><img src="https://s2.loli.net/2025/12/05/51ySOEgGCs2YwmW.png" alt="image-20251205193311196"></p><h2 id="数电基础"><a href="#数电基础" class="headerlink" title="数电基础"></a>数电基础</h2><p><strong>组合逻辑电路在任何时刻的输出信号的稳定值，仅仅与该时刻的输入信号有关，而与该时刻以前的输入信号无关。</strong></p><p><strong>但时序电路的输出不仅取决于当前的输入，还取决于电路原来的状态</strong>。</p><p><strong>CPU是边沿反应的，这是为了阻止输出信号震荡的问题。</strong></p><h3 id="中央从处理器"><a href="#中央从处理器" class="headerlink" title="中央从处理器"></a>中央从处理器</h3><p><strong>CPU由数据通路和控制单元组成。</strong></p><p><strong>CPU内部集成了一根内部总线，但是存在信号碰撞的问题，也就是在同一时刻只能传输一个数据。</strong></p><p><img src="https://s2.loli.net/2025/12/05/84oU9hWR6kTLVDy.png" alt="image-20251205200944438"></p><p><strong>元件是否进入总线是由三态门把关的，三态门接收到使能信号就允许通过，反之成立，每个三态门都与控制单元连接。控制单元还通过使能信号端来控制每个元件。</strong></p><p><strong>数据通路指的是：指令执行过程中数据经过的路径，包括路径上的部件，称为数据通路。</strong></p><p><strong>控制单元根据每条指令的功能不同生成对数据通路的控制信号，并正确控制指令的执行流程。</strong></p><h3 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h3><p><strong>需要执行的指令存在主存中，那么将指令cong主存读取到CPU的过程就是取指阶段。</strong></p><p><strong>取指阶段由六个微操作组成。</strong></p><p><strong>第一步，CU向pc和mar发送信号，PC的主存地址会通过总线传输到MAR中，MAR将通过总线送到主存中</strong></p><p><strong>第二步：CU向主存发送信号</strong></p><p><strong>第三步：主存返回指令存放到MDR</strong></p><p><strong>第四步：向IR和MDR发送信号，将 MDR发送到IR</strong></p><p><strong>第五步：将IR发送到CU进行译码分析</strong></p><p><strong>第六步：译码分析并执行完毕后，CU向pC发送信号使PC自增1</strong></p><blockquote><p><strong>为了加速单次取指的时间，我们需要注意：部分微操作的次序不可改变。</strong></p><p><strong>被控制对象不同的微操作应尽可能放在同一个时钟周期节省时间。</strong></p><p><strong>占用时间不长的微操作应该安排到同一个时钟周期内完成，允许其有不同的次序</strong></p></blockquote><p><strong>注意看，第一步和第二步的被操作对象不同，那么我们就能够将他们放在同一个时钟周期内</strong></p><p><strong>第三第四第五步有先后顺序，不能改变。</strong></p><p><strong>但是第六步自增可以和第三步安排在同一时钟周期。</strong></p><p><strong>只要这两个微操作不冲突（不使用同一总线或功能部件），就能够放到同一周期以优化性能。</strong></p><p><strong>所以，加速后的操作次序就是</strong></p><p><strong>T1:PC -&gt; MAR,CU-&gt;Read</strong></p><p><strong>T2:M[MAR]-&gt;MDR,PC++</strong></p><p><strong>T3:MDR-&gt;IR,OP[IR]-&gt;CU</strong></p><p><strong>执行一次取指需要三个时钟周期，</strong></p><p><img src="https://s2.loli.net/2025/12/06/5y7Ghq2dc9RDoTj.png" alt="image-20251206143343069"></p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p><strong>假设这是一个CPU的指令集：</strong></p><p><img src="https://s2.loli.net/2025/12/06/Oij6Cy3IERNJHKo.png" alt="image-20251206143638747"></p><p><strong>第一条是将制定主存地址的数据加载到寄存器R0中。</strong></p><p><strong>执行起来有三步。</strong></p><p><strong>T1:Ad[IR]-&gt;MAR,1-&gt;Read 将IR中的地址经过MAR发送到主存，CU发送控制读信号。</strong></p><p><strong>T2:M[MAR]-&gt;MDR 将主存中对应地址的数据取出到MDR</strong></p><p><strong>T3:MDR-&gt;R0 将MDR的数据存入到寄存器R0中。</strong></p><p><strong>再比如，倒数第三条指令，是将R1和R0做加法存到R1</strong></p><p><img src="https://s2.loli.net/2025/12/06/emEpPUHBwkAgMS8.png" alt="image-20251206145008437"></p><p><strong>T1:R1-&gt;Y将R1的 值赋给Y</strong></p><p><strong>T2:[R0]+[Y]-&gt;Z 这一步需要CU发送00指令</strong></p><p><strong>T3:Z-&gt;R1</strong></p><p><strong>这三部用的都是同一个对象，不可再做任何优化</strong></p><p><strong>再看JUMP无条件跳转指令</strong></p><p><strong>这个很简单了，就是</strong></p><p><strong>T1:Ad[IR]-&gt;PC</strong></p><p><strong>指令周期：取出并执行一条指令所需的全部时间</strong></p><p><strong>指令周期可以看作是取指周期（Fetch）和执行周期（STORE）组成</strong></p><p><strong>取指周期完成取指令和分析指令的操作</strong></p><p><strong>执行周期是完成执行指令的操作</strong></p><h2 id="控制单元是如何实现的"><a href="#控制单元是如何实现的" class="headerlink" title="控制单元是如何实现的"></a>控制单元是如何实现的</h2><p><strong>控制单元的职能是译码分析，执行指令，发送控制信号等</strong></p><h3 id="组合逻辑控制单元"><a href="#组合逻辑控制单元" class="headerlink" title="组合逻辑控制单元"></a>组合逻辑控制单元</h3><p><img src="https://s2.loli.net/2025/12/06/Iegf72LGSdJVs4H.png" alt="image-20251206151741768"></p><p><strong>使用门电路实现，又名硬部件控制单元，适用于早期计算机。</strong></p><p><strong>其执行速度非常快，原子速度接近光速，但是结果复杂，实现困难，不容易扩充和修改指令，可塑性非常差只适合RISC指令系统，但在追求极致速度的场景下也会使用。</strong></p><h3 id="微程序控制单元"><a href="#微程序控制单元" class="headerlink" title="微程序控制单元"></a>微程序控制单元</h3><p><strong>微程序控制采用”存储器替代逻辑”的思想，将机器指令的执行转化为微程序的执行。</strong></p><p><strong>微程序是一个微指令，一条伪指令包括若干微命令，一条机器指令功能由一个微程序完成。</strong></p><p><strong>你记不记得我们说过，CU能够给每个元件发送控制信号？</strong></p><p><strong>那么请回忆计网那本书的内容。CU能够将对所有的元件发送的信号组合成一个长二进制（也就是一条微指令），每一位都对应不同的元件，随后将该二进制在一个时钟周期内广播，就完成了发送控制信号的工作。</strong></p><p><img src="https://s2.loli.net/2025/12/06/S2WXF6zVIPMDiuo.png" alt="image-20251206201231806"></p><p><strong>那么取指阶段的三个微操作就对应了CU发送的三条微指令，执行ADD命令也是如此。</strong></p><p><img src="https://s2.loli.net/2025/12/06/siwLObeNoXRHYnZ.png" alt="image-20251206201509433"></p><p><strong>这六个微指令合在一起就是微程序，一个微程序就完成一条机器指令的功能，因为取指是公共操作，所以我们会将取指的三个微指令作为一个独立的微程序。</strong></p><p><img src="https://s2.loli.net/2025/12/06/xyDk7lr1F526mQR.png" alt="image-20251206203036427"></p><p><strong>这些微程序存放在CU的控制存储器(Control Storage)当中，是一块只读ROM芯片，简称CS。每一条微指令都有对应的微地址。</strong></p><p><strong>还有一个起始和转移地址发生器</strong>，能够生成下一条微指令的微地址，并存入uPC中（与CPU中的PC功能类似）。指令寄存器uIR会根据uPC的地址获取对应的微指令，控制单元开始译码uIR中的指令并对相应的元件发出相应的控制信号到数据通路中，最后在时钟信号的控制下uPC自动加1.</p><p><strong>微程序控制单元中的转移控制模块能够洁厕出下一条指令的微地址</strong></p><h3 id="下一条指令地址的决策"><a href="#下一条指令地址的决策" class="headerlink" title="下一条指令地址的决策"></a>下一条指令地址的决策</h3><p><strong>执行完一条指令后，下一条指令地址有三种方法得到：机器指令操作码，uPC++，控制转移字段。</strong></p><p><strong>CS中，每个指令末尾都带两位二进制作为控制转移字段。控制转移字段能决定下一条指令的地址选取，就是图中的MUX多路选择器的输入。</strong></p><p><img src="https://s2.loli.net/2025/12/06/jaFVSG2XfT4vuWh.png" alt="image-20251206210151664"></p><p>这种三合一的计数方法，因为大多数是时候都是程序顺序执行，所以在大部分时间都是uPComing增量+1操作，所以我们称其为“<strong>增量计数法</strong>”，这样的计数法要求微指令必须是顺序存放的。</p><p><strong>针对不是顺序存放的我们使用“断定法“。</strong></p><p><img src="https://s2.loli.net/2026/01/03/qJ3I7Rx8Oh2WlHi.png" alt="image-20260103160903297"></p><p><strong>下址就是下一条指令的微地址。</strong></p><p><strong>这样虽然空间利用率低，但是确实能够解决非顺序存放的问题。</strong></p><h3 id="微命令编码问题"><a href="#微命令编码问题" class="headerlink" title="微命令编码问题"></a>微命令编码问题</h3><p><strong>比如这个过程：</strong></p><p><img src="https://s2.loli.net/2026/01/03/fAWMec8TzvGiXDJ.png" alt="image-20260103161808572"></p><p><strong>这么长一个微指令只有三个1信号，这就显得空间利用率低。另外，因为1-&gt;Read，PC-&gt;MAR，MDR-&gt;IR都需要占用总线，这意味着他们是互斥微命令，不能同时执行。这意味着所有相同后缀的互斥信号都因为互斥能够统一管理和编码。</strong></p><p><strong>所以，我们可以将相容的输出信号放到一起，统一编码来优化空间利用率。</strong></p><p><img src="https://s2.loli.net/2026/01/03/MkU356exLwoysmt.png" alt="image-20260103162448299">这样空间利用率就得到极大优化，这样的编码法叫做<strong>字段编码法</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章：指令系统</title>
    <link href="/posts/Chapter_5_Command_System/"/>
    <url>/posts/Chapter_5_Command_System/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章：指令系统"><a href="#第五章：指令系统" class="headerlink" title="第五章：指令系统"></a>第五章：指令系统</h1><p><strong>记得在第一章写的层次结构吗？</strong></p><p><img src="https://s2.loli.net/2026/01/03/nwjRpAyZNLtHbU7.png" alt="image-20251117153817438"></p><p><strong>ISA是一种规定和结构规范，是软件和硬件之间的接口。</strong></p><p><strong>目前分为Intel x86（支配着计算机的PC时代）</strong></p><p><strong>arm（最流行的嵌入式设备指令系统）</strong></p><p><strong>MIPS和RISC-V（新兴的，能够使得计算机系统构建变得简单）</strong></p><p>指令集又分为<strong>复杂指令集</strong>和<strong>精简指令集</strong>，Intel x86属于复杂指令集，其他属于后者。</p><p>MIPS和X86两种<strong>ISA</strong>，都有32位和64位两种版本，也就是说寄存器可以是32位和64位</p><p><img src="https://s2.loli.net/2025/11/26/1WlxsjguXh69D3c.png" alt="image-20251125221854356"></p><p><strong>本章的学习流程会配合C语言，需要你根据一段C语言代码找到对应的MIPS代码。使用</strong><a href="godbolt.org">GodBolt</a>能够将C语音代码转化为其他指令系统的代码。</p><p><img src="https://s2.loli.net/2025/11/26/pM2jP7c6E3HQDrg.png" alt="image-20251126111028860"></p><h2 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h2><p><strong>MIPS是“Microprocessor without Interlocked Pipeline Stages”的缩写，即“无互锁流水级的微处理器”</strong></p><p><strong>MIPS规定了在CPU内部有32个通用寄存器，每个寄存器的大小是32位，32位为一个字，也就是一个字等于四个字节。</strong></p><p><strong>MIPS是精简指令集</strong></p><p><img src="https://s2.loli.net/2025/12/01/swF4vS9DKLiyGJc.png" alt="image-20251201144921739"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p><img src="https://s2.loli.net/2025/12/01/KgYmB9EbJ2OFder.png" alt="image-20251201193928997"></p><p><strong>注意看，addu是无符号加指令，subu是无符号减指令（上面没有） ，li是加载指令，jal是程序跳转指令，该指令意味着程序需要暂时离开当前位置去执行一个子任务（函数或者子程序）</strong></p><p><strong>首先，将25加载到7号寄存器，将12加载到6号寄存器，直到将-10加载到4号寄存器，jal指令跳转到函数add中继续执行，将4号和5号相加，结果存到4号寄存器，随即将4和6相加放到4号，再将4和7相加，结果放到2号寄存器返回给res</strong></p><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p><img src="https://s2.loli.net/2025/12/01/JkT86s2EhwF5y7X.png" alt="image-20251201200613540"></p><p><strong>栈指针是29号寄存器，里面存有一个存储地址这里是偏移值8，sw是存数指令，将一个字的数据存到指定的内存单元中。</strong></p><p><strong>这里将1存入2号寄存器，随后将2号寄存器的值存入到24+$sp(8) = 32号主存中，循环往复直到主存被写入A数组的6个元素，随后给5号寄存器写入10，addiu执行将8+24=32存放到4号寄存器中，随后jal跳转到add_3</strong></p><p><strong>add_3中有三条指令</strong></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">12</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">nop</span><br><span class="hljs-attribute">addu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><strong>lw是取数，从指定内存地址取得一个字，这是取得4号寄存器的值32+12（索引是3，一个字是4，那就是3*4 = 12）= 44存入2号寄存器中，nop指令是空操作指令，addu将2和5相加，结果存入2号寄存器</strong></p><p><strong>数据传送指令：在主存储器和寄存器之间传送数据指令，比如sw，lw。</strong></p><p><strong>$sp也可以叫基址寄存器,又名栈指针寄存器，写在前面的值是偏移值offset，目标地址为$sp+offset。</strong></p><p><strong>CPU寄存器是主体，主存是客体</strong></p><blockquote><p><strong>初次之外还有立即寻址，也就是操作数就在指令内，这样的操作数称为立即数。</strong></p></blockquote><h3 id="整体指令执行流程"><a href="#整体指令执行流程" class="headerlink" title="整体指令执行流程"></a>整体指令执行流程</h3><p><img src="https://s2.loli.net/2025/12/02/6OqkJhHj18dESfi.png" alt="image-20251202144247923">两种寻址方式讲的有点细，我们需要跳出来看整体的执行流程。指令也一样是存在主存中的，一开始PC是0，CU向PC和MAR发送信号，将PC的值发送到MAR，通过地址总线读取0号内存的指令，CU通过控制总线发送信号，主存将指令发送到CPU的MDR中，PC自动加4(每一条指令4个字节)，MDR中的指令会移交到IR，CU对IR做译码操作，ALU将4号寄存器里的值和偏移值12做加法，得到44送到MAR，CU,MAR配合读出44号内存的数字存到寄存器中。</p><h3 id="R型指令格式"><a href="#R型指令格式" class="headerlink" title="R型指令格式"></a>R型指令格式</h3><blockquote><p><strong>R型指令可以表示算数，逻辑，移位运算指令。</strong></p></blockquote><p><strong>一条指令对应的二进制位长度就是指令字长。</strong></p><p><strong>精简指令集比如RISC或者MIPS是定长的。</strong></p><p><strong>复杂指令集比如CISC是变长的。</strong></p><p><strong>MIPS中所有的指令都是32位的，32位分布结构如下：</strong></p><p><img src="https://s2.loli.net/2025/12/02/Suv75hNLOE91Hd2.png" alt="image-20251202145924526"></p><p><strong>前六位op是用来区分指令格式的，可以分为R型（寄存器型），I型（立即数型），J型（跳转型）等等。</strong></p><p><strong>比如指令</strong><code>add $2,$4,$6</code>$4是rs（第一源）,$6是rt（第二源）,$2是rd（目的寄存器）。</p><p><strong>指令送入IR中，译码器根据前6位操作码确定格式，CU再根据最后6位功能码进行译码分析其操作，转交ALU或者其他模块执行。</strong></p><p><strong>寄存器地址是5位，因为2^5=32，正好能够表示32个寄存器。</strong></p><p>而位移量是5位，<strong>5位二进制数恰好可以表示0到31（2^5=32个值），而这足以覆盖一个32位寄存器所有有意义的移位操作。</strong></p><blockquote><p><strong>你只需要知道原理，不需要知道具体怎么写，我们不可能用汇编语言或者机器语言来写程序。</strong></p></blockquote><h3 id="乘除指令"><a href="#乘除指令" class="headerlink" title="乘除指令"></a>乘除指令</h3><p><strong>记得之前说过的吗？有两个32位的乘商寄存器：Hi和Lo是专用寄存器。</strong></p><p><img src="https://s2.loli.net/2025/12/02/PTivDrAa95IERWZ.png" alt="image-20251202160008452"></p><p><code>mult</code>是将两个操作数存到专用寄存器中，<code>mflo</code>再将结果存到2号寄存器中</p><p><strong>除法也是差不多，在这里就不赘述了。</strong></p><h3 id="R型指令格式的总结"><a href="#R型指令格式的总结" class="headerlink" title="R型指令格式的总结"></a>R型指令格式的总结</h3><p><img src="https://s2.loli.net/2025/12/02/Pi4mMGZjEaK2zOJ.png" alt="image-20251202160632925"></p><p><strong>因为指令字长是一定的，所以即使nop只有一个操作字段，也不得不用32位来表示，虽然这样看起来确实很规整。</strong></p><h3 id="I型指令格式"><a href="#I型指令格式" class="headerlink" title="I型指令格式"></a>I型指令格式</h3><p><img src="https://s2.loli.net/2025/12/02/QLKOVoDb9CZ3gd5.png" alt="image-20251202192910943"></p><p><strong>其中rs是源操作数寄存器，rt是目标操作数寄存器，im是立即数，就是包含在指令中的操作数，范围是-32768到+32767。</strong></p><p><strong>I型指令没有独立的功能码，因为从根本上就不需要。</strong></p><p><strong>比如指令</strong><code>lw $2,1200($4)</code>，所以$4是rs，1200是立即数,$2是目标操作数寄存器。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2025/12/02/HWkfZ6rehotV1zl.png" alt="image-20251202193834837"></p><h3 id="MIPS执行if语句"><a href="#MIPS执行if语句" class="headerlink" title="MIPS执行if语句"></a>MIPS执行if语句</h3><p><img src="https://s2.loli.net/2025/12/02/h4dDRG5BuM6nAmf.png" alt="image-20251202195009184"></p><p><img src="https://s2.loli.net/2025/12/02/Zu1CFIVeifPpDxG.png" alt="image-20251202202342495"></p><p><img src="https://s2.loli.net/2025/12/02/RG3XgTUisn7trZH.png" alt="image-20251202202356984"></p><h3 id="MIPS中执行循环结构"><a href="#MIPS中执行循环结构" class="headerlink" title="MIPS中执行循环结构"></a>MIPS中执行循环结构</h3><p><img src="https://s2.loli.net/2025/12/03/vJOia81wg9jmHk5.png" alt="image-20251203134516104"></p><p>将同一段高级语言代码能够转化为不同的汇编语言代码，不同汇编代码之间性能差别很大，<strong>挑选并采用最佳性能的过程叫优化。</strong></p><p><img src="https://s2.loli.net/2025/12/03/ISRH4uOvjGCo6L8.png" alt="image-20251203135415382"></p><p><img src="https://s2.loli.net/2025/12/03/XG3h82RgSm5VbMY.png" alt="image-20251203135444575"></p><h3 id="指令设计"><a href="#指令设计" class="headerlink" title="指令设计"></a>指令设计</h3><p><strong>指令长度：字面意思，就是指令的长度，就是指令的二进制位数。</strong></p><p><strong>越短越好，降低空间开销。</strong></p><p>可以设置为**定长指令集(MIPS)，或者是变长指令集(x86)**。</p><h3 id="指令格式："><a href="#指令格式：" class="headerlink" title="指令格式："></a>指令格式：</h3><p><strong>一般指令都需要两个部分，一个是操作码一个是地址码，地址码可以是立即数或者寄存器编号，也可以有多个地址码。</strong></p><p><img src="https://s2.loli.net/2025/12/09/H8b9FdJBQZ5Onk3.png" alt="image-20251209143216922"></p><p><strong>但是我们会使用PC存放下一个指令地址</strong></p><p><img src="https://s2.loli.net/2025/12/09/H1gvw2dne76DOsN.png" alt="image-20251209142906162"></p><p><strong>有些操作不需要输出到某个寄存器</strong></p><p><img src="https://s2.loli.net/2025/12/09/TuLdPKcIsvZEb8e.png" alt="image-20251209143256102"></p><p><strong>部分操作是单目的。</strong></p><p><img src="https://s2.loli.net/2025/12/09/pTVN47uFxRrMCDj.png" alt="image-20251209143311733"></p><p><strong>随地址码位数扩大，那么能表示的地址范围就越来越大。</strong></p><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>分为<strong>立即数寻址，直接寻址，间接寻址，相对寻址，基址寻址，变址寻址，隐含寻址</strong>。</p><p><strong>其中基址寻址，变址寻址，隐含寻址统称偏移寻址。</strong></p><p><strong>立即数寻址就是在指令中直接给出操作数本身。</strong></p><p><strong>直接寻址分为寄存器直接寻址和主存直接寻址。</strong></p><p><strong>寄存器直接寻址就是操作数存放在CPU寄存器中，主存直接寻址就是操作数放在主存中，指令给出寄存器编号或者主存的有效地址来寻找并调用操作数。</strong></p><blockquote><p><strong>因为寄存器数量远小于主存单元数，所以寄存器编号比主存短很多，所以寄存器寻址方式的指令比较短，访问也比主存更快。</strong></p></blockquote><p><strong>间接寻址也分为寄存器间接寻址和主存间接寻址。</strong></p><p><strong>寄存器间接寻址就是：指令中的地址码是一个寄存器编号，寄存器中存放的是操作数的有效地址，常用于指针。</strong></p><p><img src="https://s2.loli.net/2025/12/09/3lIyrOtL1ZKTVF6.png" alt="image-20251209144854536"></p><p><strong>主存间接寻址就是：在指令中给出的地址码是存放操作数有效地址的主存单元地址，用的比较少。</strong></p><p><img src="https://s2.loli.net/2025/12/09/1QSNf32ktWDFAPr.png" alt="image-20251209145031647"></p><p><strong>基址寻址：指令中给出形式地址R和偏移量offset</strong></p><p><strong>操作数的有效地址等于给出的形式地址R加上某个偏移量offset</strong></p><p><img src="https://s2.loli.net/2025/12/09/fd485eyTRPvsLpV.png" alt="image-20251209145309835"></p><p><strong>相对寻址：操作数有效地址等于PC寄存器的值加上给出的偏移值offset</strong></p><p><img src="https://s2.loli.net/2025/12/09/wq8kG9bS3pliHeU.png" alt="image-20251209145521340"></p><p><strong>变址寻址：</strong></p><p><strong>操作数地址等于一个基地址和一个动态可变偏移量相加。</strong></p><p><strong>可变偏移量往往是一个内容可改变的寄存器</strong></p><p><img src="https://s2.loli.net/2025/12/09/oFHG2a1TvrcMXY8.png" alt="image-20251209145947932"></p><p><strong>隐含寻址是一种特别的指令设计技巧，它的核心在于指令中并不直接写明某个操作数的地址，而是通过操作码或约定俗成的规则隐含地指定</strong></p><p><strong>为了让CPU知道寻址方式，指令往往是这种结构：</strong></p><p><img src="https://s2.loli.net/2025/12/09/yxq59cMszYOQgt7.png" alt="image-20251209150127712"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章：数据的表示与运算</title>
    <link href="/posts/Chapter_4_Representation_and_operation_of_data/"/>
    <url>/posts/Chapter_4_Representation_and_operation_of_data/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章：数据的表示与运算"><a href="#第四章：数据的表示与运算" class="headerlink" title="第四章：数据的表示与运算"></a>第四章：数据的表示与运算</h1><p><strong>计算机的世界中，只有零和一两种表示。</strong></p><p><strong>将各种表示用0和1的二进制来表示的过程，就是编码。</strong></p><p><strong>广义上的定义是：</strong></p><p><strong>编码，就是用少量简单的基本符号对大量复杂多样的信息进行一定规则的组合</strong></p><p><strong>本章思维导图：</strong></p><p><img src="https://s2.loli.net/2025/11/25/mfSUFa49goRzvLJ.png" alt="image-20251125213805365"></p><p><strong>进制转换技巧</strong></p><p><strong>非数值数据的编码</strong></p><p><strong>无符号整数的编码</strong></p><blockquote><p><strong>八个二进制位那么表示的无符号范围就是0-255，因为255对应的是八位全一，在加一就是256但是这种情况下发生了溢出，所以只能取到255</strong></p></blockquote><p><strong>有符号整数的原码</strong></p><blockquote><p><strong>第一位就是符号位，后面都是数值位</strong></p></blockquote><p><strong>正数的原码反码补码都相同</strong></p><p><strong>负数的反码等于原码的符号位不变其余位取反，补码等于反码+1</strong></p><p><strong>补码（负数的补码）数值位取反+1就是原码</strong></p><p><strong>补码的存在有很强的进步性。</strong></p><p><img src="https://s2.loli.net/2025/11/26/SpARUgaxh9NOnu6.png" alt="image-20251126140928451"></p><p>如果我们要使用无符号数表示符号数，对于0-499，我们可以直接表示，但是对于-500-0，我们的方法是求其补数（<strong>补数是一个在特定计数系统（模运算）下，能够“互补”使得结果达到某个“上限”的数。</strong>），也就是用500-999来表示，这么做很有利于计算。</p><p><strong>比如，我们要计算176-253，那就是176+（-253），那–253对应747，那就是176+747就是923对应-77。我们也知道176-253就是-77，前后对得上，这就完成了计算。</strong></p><p><strong>补码中+0和-0是同一个表示</strong></p><p><strong>注意，如果说在二进制比较中1比0大，那么会出现****负数大于整数的情况</strong></p><p><strong>我们用移码来解决这个问题：</strong></p><p><img src="https://s2.loli.net/2025/11/26/ayhLqUlVvDYQ5iX.png" alt="image-20251126200129240"></p><p><strong>移码就是将数往某个方向移动一段距离从而统一符号。[X]移 = 2 ^ (n-1) + x，可表示的范围是-2^(n-1)到2^(n-1)-1,和补码的范围是一样的。</strong></p><h3 id="有符号数和无符号数的转换"><a href="#有符号数和无符号数的转换" class="headerlink" title="有符号数和无符号数的转换"></a>有符号数和无符号数的转换</h3><p><strong>无符号编码如果超过了正数范围转化后会变为负数。转换的C语音语句大概是</strong></p><p><code>unsigned short uv =(unsigned short)v; </code></p><h2 id="零扩展和位截断"><a href="#零扩展和位截断" class="headerlink" title="零扩展和位截断"></a>零扩展和位截断</h2><p><strong>如果将一个无符号数转换成一个更大的无符号类型的话，就需要执行零扩展（位扩展）。这就是扩大了数据的最大位数。</strong></p><p><strong>顺序是先进行零扩展在进行符号转换</strong></p><p><strong>反过来，如果需要将long转化为int或者short，就需要位截断</strong></p><h2 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h2><p><strong>浮点数编码是使用科学计数法的方式来表示的，根据需要分为符号位S，指数域E（标定数的范围），尾数域M（决定数的精度）。</strong></p><p>让我们以数字<code>-12.375</code>的单精度（32位）编码过程为例，来具体感受一下</p><p><strong>处理符号</strong>：这是一个负数，所以**符号位 <code>S</code>设为 <code>1</code>**。</p><p><strong>转换为二进制科学计数法</strong>： 先将 <code>12.375</code>转换为二进制。整数部分 <code>12</code>是 <code>1100</code>，小数部分 <code>0.375</code>是 <code>0.011</code>（因为 0.375=0.25+0.125=2−2+2−3）。 所以 <code>12.375</code>的二进制表示是 <code>1100.011</code>。</p><p><strong>将其规格化：</strong><code>1100.011 = 1.100011 × 2^3</code>。这里，**底数（尾数）是 <code>1.100011</code><strong>，</strong>实际指数是 <code>3</code>**。</p><p><strong>编码数</strong>：精度的偏移值是127。所以，存入指数域的值是 <code>3 + 127 = 130</code>。<code>130</code>的二进制是 <code>10000010</code>。所以**指数域 <code>E</code>为 <code>10000010</code>**。</p><p><strong>编码尾数</strong>：从规格化后的尾数 <code>1.100011</code>中，取出小数部分 <code>100011</code>，然后在其<strong>右边补0，直到凑满23位</strong>。所以**尾数域 <code>M</code>为 <code>100 0110 0000 0000 0000 0000</code>**。</p><p><strong>最终，</strong><code>-12.375</code>的单精度浮点数编码结果就是将这三部分拼接起来：**<code>1 10000010 10001100000000000000000</code>**（为了方便阅读，这里用空格分开了符号位、指数域和尾数域）。</p><p><img src="https://s2.loli.net/2025/11/27/i17eElwBnSLsgzA.png" alt="image-20251127105936336"></p><p><strong>标准化的原因是尾数部分我们尽可能不让0占用精度，会移动小数点位置，位数部分往左移叫做左规，右移叫右规。</strong></p><p><strong>规格化浮点数的标志是尾数部分的最高位是1，但在IEEE 754标准中，这个1是隐含的。</strong></p><h3 id="IEEE-754浮点数规范"><a href="#IEEE-754浮点数规范" class="headerlink" title="IEEE 754浮点数规范"></a>IEEE 754浮点数规范</h3><p><strong>该规范解决了不同计算机数据不互通需要额外转化数据的问题。</strong></p><p><img src="https://s2.loli.net/2025/11/27/Wvcqm3jw6D9o21H.png" alt="image-20251127112240360"></p><p><img src="https://s2.loli.net/2025/11/27/pHAduK6Gg2xRZTm.png" alt="image-20251127193931090"></p><p><img src="https://s2.loli.net/2025/11/27/KVwcEXHrtqv36Lj.png" alt="image-20251127195520234"></p><p><strong>其他区间不能使用浮点数表示，属于溢出数，根据溢出的不同分为负上溢，负下溢，正上溢，正下溢。</strong></p><blockquote><p><strong>数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。</strong> <strong>而数据下溢时，浮点数值趋于零，计算机将其当作机器零处理。</strong></p></blockquote><p><strong>非规格化数的特点：</strong></p><ul><li><strong>阶码为0</strong></li><li><strong>尾数不为零</strong></li><li><strong>指数是-126</strong></li><li><strong>隐藏位是0，位数变化范围是0.0000····1 ~0.111····1</strong></li></ul><p><strong>六十四位类似。</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章：主存储器</title>
    <link href="/posts/Chapter_3_Main_Memory/"/>
    <url>/posts/Chapter_3_Main_Memory/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章：主存储器"><a href="#第三章：主存储器" class="headerlink" title="第三章：主存储器"></a>第三章：主存储器</h1><blockquote><p><strong>思维导图</strong></p></blockquote><p><img src="https://s2.loli.net/2025/11/21/f7iHGPU1R2rqdWI.png" alt="image-20251121200709266"></p><p><strong>数电内容在此略过</strong></p><p><strong>寄存器就是能够存储一定位数的二进制位的电子元件</strong></p><p><strong>机器字长:CPU一次能够处理的数据的位数，与CPU的寄存器位数有关</strong></p><p><img src="https://s2.loli.net/2025/11/21/BDoebIykMr1qTwn.png" alt="image-20251121203419264"></p><p><strong>bus是读口，RA和RB是输入要读的寄存器的编号，busW是写口，配合CLK时钟信号和WE使能端，RW写入寄存器地址，往寄存器内写入信息。</strong></p><h2 id="主存储器存储原理"><a href="#主存储器存储原理" class="headerlink" title="主存储器存储原理"></a>主存储器存储原理</h2><p><strong>一个字节等于8位二进制</strong>，这是计算机普遍适用的规律</p><p><strong>也就是1B = 8Bit</strong></p><p><strong>所以有 1024B = 1KB</strong></p><p><strong>1024KB = 1MB</strong></p><p><strong>在计算机内部是1024为进率</strong></p><p><strong>所以4GB = 4 * 1024 * 1024* 1024 /8B</strong></p><p><strong>= 2 ^ 29个存储字</strong></p><p><strong>平时下载速度不是波特率而是比特率。</strong></p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><blockquote><p><strong>只读，正常工作时只能读出数据，切断电源信息也不会消失，存储不经常改变的信息</strong></p></blockquote><p><img src="https://s2.loli.net/2025/11/21/LO6qcgJ5PReWCm2.png" alt="image-20251121204505080"></p><p><strong>掩膜只读寄存器（Mask ROM）</strong></p><p><strong>掩膜ROM由地址译码器和存储都阵列两部分组成，结构如下：</strong></p><p><img src="https://s2.loli.net/2025/11/21/KI98ynX1V7te5Ez.png" alt="image-20251121205143797"></p><p><strong>可以看到，先是一个3-8译码器直接连接CPU，并且四根位线与8根字字选择线相交，并且在某些交点用二极管链接，那么输入地址和数据输出就是以下关系：</strong></p><table><thead><tr><th><strong>A2</strong></th><th><strong>A1</strong></th><th><strong>A0</strong></th><th><strong>F0</strong></th><th><strong>F1</strong></th><th><strong>F2</strong></th><th><strong>F3</strong></th></tr></thead><tbody><tr><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td></tr><tr><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td></tr><tr><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td></tr><tr><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td></tr><tr><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td></tr><tr><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td></tr><tr><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td></tr><tr><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>0</strong></td></tr></tbody></table><p><strong>3根地址线，有2^3=8个地址，每个地址存</strong> <strong>放4位二进制，总容量8*4=32bit</strong></p><p><strong>一次性读出来4位二进制称作一个存储字（存储单元），存储字长就是4，</strong></p><p><strong>存储元：存储一个位的电路</strong></p><p><strong>如果有10根地址线，8根位线，那就是2^10 * 8 = 1K * 8 = 1KB</strong></p><p><strong>存储信息只读，这就是为什么使用二极管链接。</strong></p><h3 id="可编程ROM"><a href="#可编程ROM" class="headerlink" title="可编程ROM"></a>可编程ROM</h3><p><strong>可编程只读存储器（PROM）</strong></p><p><img src="https://s2.loli.net/2025/11/21/2EfpSO3lKcWazxL.png" alt="image-20251121210807957"></p><p><strong>存储元改为使用熔丝链接，熔丝只能允许一次数据交换，之后便会自行熔断，所以只能写入一次。</strong></p><p><strong>可擦除可编程只读存储器（EPROM）</strong></p><p><img src="https://s2.loli.net/2025/11/21/iX741OuhPScknBl.png" alt="image-20251121210949401"></p><p><strong>能够反复写入擦除读取，不过擦除需要专门工具，而且是MOS工艺，速度比较慢，而且一旦擦除整个数据都会消失</strong></p><p><strong>电擦除电改写只读存储器（EEPROM）</strong></p><p><img src="https://s2.loli.net/2025/11/21/fO73lIPeqBYnLmX.png" alt="image-20251121211137338"></p><p><strong>使用电来擦除</strong></p><p><strong>快闪只读存储器（FM）</strong></p><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><blockquote><p><strong>随机存取存储器</strong></p></blockquote><p><strong>随机：按地址访问存储单元，因为每个地址译码时间是一样的，所以每个单元的访问时间是一个常数，与地址无关。</strong></p><p><img src="https://s2.loli.net/2025/11/23/MIlCZJPioXjvNzn.png" alt="image-20251123144024546"></p><p><strong>唯一需要运算的地方就是地址译码器。</strong></p><p><strong>这样的译码方式叫一维译码，只适用于小容量。</strong></p><p><strong>二维译码(重合法，双译码法)：使用两个译码器。</strong></p><p><img src="https://s2.loli.net/2025/11/23/JKZmYPkT7SLONg8.png" alt="image-20251123144606317"></p><p><strong>一个黑块就是一个存储单元，那么两个译码器就构成了64个存储单元，这样的结构称为存储阵列</strong>。</p><p><strong>但是如果XY</strong>(也就是行地址译码器和列地址译码器)分别只输入了一位，那意味着能够直接读取一行。</p><p><img src="https://s2.loli.net/2025/11/23/v58mtDBJLxciPeI.png" alt="image-20251123145359317"></p><h4 id="静态SRAM"><a href="#静态SRAM" class="headerlink" title="静态SRAM"></a>静态SRAM</h4><p><strong>SRAM存储元一开始保存的是0还是1是随机的。</strong></p><p><img src="https://s2.loli.net/2025/11/23/cWVkK6gdj4FhGuT.png" alt="image-20251123150450133"></p><p><strong>存储阵列示意图：</strong></p><p><img src="https://s2.loli.net/2025/11/23/9Rlt7Efu8v3SXMB.png" alt="image-20251123150652294"></p><p><strong>可以看到每个列地址使用了6个MOS管来构成双稳态触发器，访问速度非常快而且通电时数据就永久保持。</strong></p><p><strong>X地址选择5，Y选择3，那么Y=3的线连接两个MOS管导通，WE为低电平，将数据线传输的数据写到存储单元(5,3)中。</strong></p><h4 id="动态DRAM"><a href="#动态DRAM" class="headerlink" title="动态DRAM"></a>动态DRAM</h4><p><img src="https://s2.loli.net/2025/11/23/AlFELiKHSmZDnCj.png" alt="image-20251123151659551"></p><p><img src="https://s2.loli.net/2025/11/23/berNZ2A6hyv4HWR.png" alt="image-20251123152038530"></p><p><strong>可以看到每个列地址是一个MOS管加一个电容来连接。电容会漏电，数据会丢失，访问慢。</strong></p><p><strong>所以，读取数据的同时，会清空存储电荷的电容，导致原始数据被破坏。因此，必须在读取后立即执行一次“再生”操作，将数据重新写回。</strong></p><h3 id="存储器的存储周期"><a href="#存储器的存储周期" class="headerlink" title="存储器的存储周期"></a>存储器的存储周期</h3><p><strong>读出时间:指从存储器接收到读命令开始，到读取出信息所需时间</strong></p><p><strong>写入时间:指从存储器接收到写命令开始，至信息被写入存储器所需的时间</strong></p><p><strong>存储周期：进行一次操作需要的时间，也就是存\取时间+恢复时间。</strong></p><h3 id="DRAM刷新"><a href="#DRAM刷新" class="headerlink" title="DRAM刷新"></a>DRAM刷新</h3><p><strong>DRAM的电容会缓慢放电，放电过多会导致信息丢失，破坏性读取后也会直接清空电容电量，所以必须定时给电容充电，这个过程称为刷新或者读后再生。</strong></p><p><strong>刷新是以行为单位进行的，是由刷新计数器和刷新控制器来进行的</strong></p><p>刷新周期定义为：<strong>上次对整个存储器刷新结束时作为开始点，到下次对整个存储器全部刷新一遍为止的时间间隔。</strong></p><p><strong>和总线的仲裁类型差不多，这里有刷新也有刷新策略：</strong></p><ul><li><p><strong>集中刷新</strong></p><ul><li><strong>在规定的一个刷新周期内，对全部存储元集中一段时间进行逐行刷新</strong></li><li><strong>存储阵列式128*128，刷新周期是2ms，存储周期是0.5us，刷新单行的时间可以看作是存储（读取）单行的时间，那就是128 * 0.5us=64us，那么刷新周期为2ms，也就是2000us，我们就划分为前1936us来进行读写操作，后64us刷新，刷新时间为死时间，在这个时间内无法进行读写。</strong></li></ul><p><img src="https://s2.loli.net/2025/11/23/nIAoDMfO4s8hVCL.png" alt="image-20251123155833655"></p></li><li><p><strong>分散刷新</strong></p><ul><li><strong>对每行存储单元的刷新分散到每个存储周期内完成。将存储周期分为两段，前段存取，后半段刷新。</strong></li><li><strong>存储阵列式128*128，刷新周期是2ms，存储周期是0.5us，Tm是存取，Tr是刷新操作，Tc就是读取并刷新一行的时间。这样没有死时间但是会延长存储周期一倍或者更多。到点就强制刷新，这可能会干扰CPU正在进行的操作。</strong></li></ul><p><img src="https://s2.loli.net/2025/11/23/woJ7A4KBqZUxiyh.png" alt="image-20251123160507879"></p></li><li><p><strong>异步刷新</strong></p><ul><li><strong>前两种方式的结合，能够缩短死时间，又可以充分利用最大刷新间隔为2ms的特点。</strong></li><li><strong>存储阵列式128*128，刷新周期是2ms，存储周期是0.5us，将刷新周期平均分配到每一行上，那么刷新间隔是2ms/128行 = 15.6us，那么在存取一行后就会刷新一次。</strong></li></ul><p><img src="https://s2.loli.net/2025/11/23/sP89MuNlHexAco1.png" alt="image-20251123164942461"></p></li></ul><h3 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h3><p><strong>SRAM是“快而贵”的缓存，DRAM是“大而便宜”的主存</strong></p><table><thead><tr><th><strong>特性维度</strong></th><th><strong>SRAM（静态随机存储器）</strong></th><th><strong>DRAM（动态随机存储器）</strong></th></tr></thead><tbody><tr><td><strong>基本存储单元</strong></td><td><strong>6个晶体管（MOS管）构成一个****双稳态触发器</strong></td><td><strong>1个晶体管（MOS管） + 1个****电容</strong></td></tr><tr><td><strong>数据保持原理</strong></td><td><strong>只要通电，数据就****永久保持</strong>（静态）</td><td><strong>电容会漏电，数据****会丢失</strong>，需要定期<strong>刷新</strong>（动态）</td></tr><tr><td><strong>速度</strong></td><td><strong>非常快</strong>（访问周期约10ns级别）</td><td><strong>较慢</strong>（访问周期约50ns级别，含刷新开销）</td></tr><tr><td><strong>集成度/容量</strong></td><td><strong>低（一个单元要6个晶体管）</strong></td><td><strong>高（一个单元只需1个晶体管1个电容）</strong></td></tr><tr><td><strong>功耗</strong></td><td><strong>较高（持续通电）</strong></td><td><strong>较低（待机时功耗低，但刷新会增加总功耗）</strong></td></tr><tr><td><strong>成本</strong></td><td><strong>高</strong>（芯片面积大，制造复杂）</td><td><strong>低</strong>（芯片面积小，结构简单）</td></tr><tr><td><strong>主要应用</strong></td><td><strong>CPU高速缓存</strong>（L1, L2, L3 Cache）</td><td><strong>主存储器</strong>（内存条/运行内存）</td></tr><tr><td><strong>核心挑战</strong></td><td><strong>面积大，成本高</strong></td><td><strong>需要刷新电路</strong>，设计更复杂</td></tr></tbody></table><h3 id="主存如何与CPU连接"><a href="#主存如何与CPU连接" class="headerlink" title="主存如何与CPU连接"></a>主存如何与CPU连接</h3><p><strong>我们将之前讲过的逻辑电路看成一块集成电路IC，称作存储芯片</strong></p><p><img src="https://s2.loli.net/2025/11/23/nX3hrsaWFTMUOQR.png" alt="image-20251123165558704"></p><p><strong>单个存储芯片不可能做得很大，为我们需要扩展存储芯片的容量大小。</strong></p><p><img src="https://s2.loli.net/2025/11/23/Qe5yvgLnR2VwANE.png" alt="image-20251123165832393"></p><p><strong>CPU通过主存控制器</strong>与存储芯片链接。</p><p><img src="https://s2.loli.net/2025/11/23/eQpqL6cfrK4IaNW.png" alt="image-20251123192730840"></p><p><strong>现代计算机中，主存控制器已被集成到CPU中，所以有些图不会画出主存控制器。</strong></p><p><strong>m是MDR的位数，也就是存储字长，n是MAR的位数，2^n是存储字数量。</strong></p><p><strong>建议配合上图理解。</strong></p><p><img src="https://s2.loli.net/2025/11/23/YRuL5Oiqj63D8rW.png" alt="image-20251123193908944"></p><h3 id="主存的扩展"><a href="#主存的扩展" class="headerlink" title="主存的扩展"></a>主存的扩展</h3><p><strong>如果说一个主存是1K * 4Bit，说明存储字数量为1K，存储字长为4位，主存容量就是4096位，根据一个字节8位那就是512B（这里的B是字节Byte），那么也就是一共有1024个存储单元，每个存储单元能够存储4位二进制，芯片通过4根数据线换数据。</strong></p><ul><li><strong>位扩展：增大存储字</strong><ul><li><strong>我们希望有8根数据线进行是数据交换，字长就被扩张到8位</strong></li></ul></li></ul><p><img src="https://s2.loli.net/2025/11/24/7KdEso8rfPnl6xC.png" alt="image-20251124135041016"></p><p><strong>注意看，第一芯片链接D0-D3，第二芯片链接D4-D7，那就是一共有8个数据线来交换数据，这就增加了存储字长。</strong></p><ul><li><strong>字扩展：增加存储字数量</strong><ul><li><strong>我们通过加一个芯片，扩大地址数，也就是扩大存储字数量。</strong></li></ul></li></ul><p><img src="https://s2.loli.net/2025/11/24/kSBEbAxYytjIHCF.png" alt="image-20251124140100173"></p><p><strong>注意看，我们用两个芯片并联了地址信号并用一个非门将两芯片的片选信号连接起来，这就使得地址数扩大了一倍，那就是扩大了存储字数量。</strong></p><ul><li><strong>字,位扩展</strong><ul><li><strong>两个方法的结合，能够同时扩大存储字长和存储字数量。</strong></li></ul></li></ul><p><img src="https://s2.loli.net/2025/11/24/S6L8CQPYsAe71pq.png" alt="image-20251124140535880"></p><h2 id="CPU和主存链接的例题"><a href="#CPU和主存链接的例题" class="headerlink" title="CPU和主存链接的例题"></a>CPU和主存链接的例题</h2><p><img src="https://s2.loli.net/2025/11/24/yTmsIQjKADr1qMl.png" alt="image-20251124142411532"></p><p><a href="https://www.bilibili.com/video/BV1G29JYQE8b?spm_id_from=333.788.player.switch&amp;vd_source=cb9728ea927f0db8dc6b78c5ae60b004&amp;p=37">讲解视频</a></p><h3 id="同步主存储器SDRAM（DRAM）"><a href="#同步主存储器SDRAM（DRAM）" class="headerlink" title="同步主存储器SDRAM（DRAM）"></a>同步主存储器SDRAM（DRAM）</h3><p><strong>MFC异步通信很大程度拖慢了CPU时间。</strong></p><h4 id="行缓冲器"><a href="#行缓冲器" class="headerlink" title="行缓冲器"></a>行缓冲器</h4><p><strong>SDRAM的行缓冲器</strong>是集成在SDRAM芯片内部的一个<strong>高速静态存储器（SRAM）缓存</strong>。它的作用是：当CPU要访问SDRAM时，<strong>并不直接去庞大的存储单元阵列中读取数据，而是先把整个一行数据（通常几千位）一次性从慢速的DRAM阵列预取到这个高速的行缓冲器中</strong>，后续的读写操作都在这个缓冲器上完成，从而极大提升访问速度。</p><p><img src="https://s2.loli.net/2025/11/24/THjrhz9g3Gk6LNp.png" alt="image-20251124144736726"></p><p><strong>如果地址线输入01，那就是选中了第二行，行缓存器会提取所有第二行的数据并保存，</strong></p><p><strong>随即传入列地址00,就能够从缓冲器中读取第一列的八位数据。基于行缓冲器SRAM的高速率，这个过程是非常快的。</strong></p><h5 id="突发传输"><a href="#突发传输" class="headerlink" title="突发传输"></a>突发传输</h5><p><img src="https://s2.loli.net/2025/11/24/XeJ4HIuYKsDVPci.png" alt="image-20251124145154160"></p><p><strong>行缓冲器中有两个寄存器，一个是BL，保存突发长度，第二个是CL，CAS（列地址信号）潜伏期</strong></p><h5 id="DDR（Double-Data-Rate）-SDRAM"><a href="#DDR（Double-Data-Rate）-SDRAM" class="headerlink" title="DDR（Double Data Rate） SDRAM"></a>DDR（Double Data Rate） SDRAM</h5><p><img src="https://s2.loli.net/2025/11/24/pxwkXvnqRPM4u8z.png" alt="image-20251124150106165"></p><p><strong>DDR技术也在不断更新</strong></p><p><img src="https://s2.loli.net/2025/11/24/StTVLBfarmeyA5z.png" alt="image-20251124150137825"></p><h3 id="按字节寻址"><a href="#按字节寻址" class="headerlink" title="按字节寻址"></a>按字节寻址</h3><p><strong>温习一下主存结构：</strong></p><p><img src="https://s2.loli.net/2025/11/24/naKxmH8oZVMPvkY.png" alt="image-20251124152421868"></p><p><strong>八根数据线，那每次能够读写一个字节。</strong></p><p><strong>有32个地址线，使用二进制表示地址太长了，所以我们往往使用十六进制来表示，例如</strong><code>0x00000004</code>等。</p><p><strong>所以每个地址对应一个字节，根据地址来找到地址就是根据字节寻址。</strong></p><p><strong>如果每个地址存储的字节数 &lt;=1的话，那就只能使用按字节寻址。</strong></p><h3 id="按字寻址"><a href="#按字寻址" class="headerlink" title="按字寻址"></a>按字寻址</h3><p><strong>如果每个地址存放的字节数多比如32位，那因为一个字节等于八个二进制位（这是计算机的普遍标准），我们就可以定义四个字节为一个字，那么每个地址对应1个字，我们就能够通过查找字来确定要查找的数据的位置，也就是按字寻址。</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>按字节寻址</strong></th><th><strong>按字寻址</strong></th></tr></thead><tbody><tr><td><strong>基本寻址单位</strong></td><td><strong>字节</strong></td><td><strong>字</strong></td></tr><tr><td><strong>地址对应数据量</strong></td><td><strong>1个字节</strong></td><td><strong>1个字（如32位系统下为4个字节）</strong></td></tr><tr><td><strong>灵活性</strong></td><td><strong>高</strong>，可精确访问任意字节</td><td><strong>低</strong>，以字为单位访问</td></tr><tr><td><strong>地址空间利用</strong></td><td><strong>地址线与字节地址对应</strong></td><td><strong>地址线与字地址对应，相同地址线可管理更大物理内存</strong></td></tr><tr><td><strong>常见应用</strong></td><td><strong>现代通用计算机（如x86架构）</strong></td><td><strong>某些早期或特定领域的硬件系统</strong></td></tr></tbody></table><p><strong>事实上按字寻址</strong>凭借<strong>相同地址线能够管理更大内存</strong>，是对早期计算机制造瓶颈的妥协。</p><p><strong>现在不存在技术瓶颈，使用字节寻址是现代计算机的绝对主流</strong>。</p><h3 id="高速缓存Cache"><a href="#高速缓存Cache" class="headerlink" title="高速缓存Cache"></a>高速缓存Cache</h3><p>时间局限性：<strong>被访问的某个存储单元带一个叫短时间间隔内可能又被访问</strong>，比如for循环等</p><p>空间局限性：<strong>被访问的某个存储单元的邻近单元在一个较短时间间隔内也可能被访问。比如顺序执行的指令，遍历数组等</strong></p><p><strong>而Cache的设计，就是****预测</strong>程序的行为会遵循局部性原理。一方面他会保存最近使用的数据等待再次访问，另一方面他会预取相邻的数据等待CPU访问。如果下一次CPU要访问的数据刚好在Cache中，那么就能利用Cache的高速访问来缩短时间，这样的情况我们称之为”<strong>命中（Hit）</strong>“。这样的机制能够使速度提升很多倍。</p><p><img src="https://s2.loli.net/2025/11/25/I1WFykcP5fMdQTZ.png" alt="image-20251125135735079"></p><p><strong>这个代码的作用是求和数组，函数中有for循环，这符合时间局部性，而且数组在内存中是顺序排列的，这就是符合空间局部性。</strong></p><p><img src="https://s2.loli.net/2025/11/25/dqBWOlh3a9fDVwM.png" alt="image-20251125140609316"></p><p><strong>注意看，C语言中，数组是按行存储的，程序一的按行访问，正好对应了顺序访问的局部性原则，程序二却是按列访问，这意味着访问完</strong><code>A[0][0]</code>之后会直接跳转到<code>A[0][2047]</code>这会大大降低Cache命中的概率，所以空间局部性很差。</p><h3 id="Cache基本工作原理"><a href="#Cache基本工作原理" class="headerlink" title="Cache基本工作原理"></a>Cache基本工作原理</h3><p><strong>Cache往往集成到CPU中，并于主存控制器，ALU等连接到一起，在CPU正式操作前，他会预取一部分的数据和指令保存，供CPU使用</strong></p><p><img src="https://s2.loli.net/2025/11/25/SjXLR7gotIrQHiq.png" alt="image-20251125144701973"></p><p><strong>总结一下</strong></p><p><img src="https://s2.loli.net/2025/11/25/WGOyM2dAvenHr9D.png" alt="image-20251125144947176"></p><p><strong>如果CPU访问主存单元所在的主存块在Cache中，则称为Cache命中(hit)。</strong> <strong>命中的概率称为命中率（hitrate），它等于命中次数与访问总次数之比。</strong> <strong>如果CPU访间主存单元所在的主存块不在Cache 中，则称为Cache 不命中（miss)。</strong> <strong>不命中的概率称为缺失率（missrate)，它等于不命中次数与访问总次数之比。</strong></p><h3 id="主存块的划分和相关地址的计算"><a href="#主存块的划分和相关地址的计算" class="headerlink" title="主存块的划分和相关地址的计算"></a>主存块的划分和相关地址的计算</h3><p><img src="https://s2.loli.net/2025/11/25/yQSV3GBad7LvNEO.png" alt="image-20251125145824600"></p><p><strong>Cache和主存块的三种映射方式是直接映射，组相联映射，全相联映射</strong>。</p><p><strong>抱歉，这三个映射方式我没看，也许有时间会补上。</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章：总线结构</title>
    <link href="/posts/Chapter_2_Bus_Structure/"/>
    <url>/posts/Chapter_2_Bus_Structure/</url>
    
    <content type="html"><![CDATA[<h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><p><strong>总线</strong>是一组<strong>为多个部件服务的公共信息传输线路</strong>，是计算机内部各个功能部件（如CPU、内存、I/O设备）之间进行数据、地址和控制信息传输的<strong>共享通道</strong>。</p><p><strong>所以，总线是一个公用的通道，他需要一些通用属性：****带宽，仲裁逻辑，总线事务，总线定时，总线标准。</strong></p><p><img src="https://s2.loli.net/2026/01/25/Ux8gfDKJr6iM1bT.png" alt="image-20251118141640690"></p><p><strong>总线在同一时刻在发送相同信息会导致信息冲突，形成通信瓶颈。所以中大型计算机会使用多个总线。</strong></p><p><img src="https://s2.loli.net/2026/01/25/pX6cDu3l7x28Yih.png" alt="image-20251118141856685"></p><h1 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h1><h2 id="通信知识"><a href="#通信知识" class="headerlink" title="通信知识"></a>通信知识</h2><p><strong>通信的目的是为了传递数据，信号就是传输载体。</strong></p><p><strong>数据又分为连续数据和离散数据，在信号中，连续数据用模拟信号表示，离散数据用数字信号表示。</strong></p><p><strong>CPU内置一个发射器，能够将二进制码转化为电信号，让别的设备接受，但是这种信号不适用于远距离，需要调制为模拟型号</strong></p><p><img src="https://s2.loli.net/2026/01/25/W3a8Yr1CGtOFBcV.png" alt="image-20251118143043278"></p><p><strong>但是，读取的时间是需要控制的，这就由发射器和****接收器中的时钟</strong>完成，时钟会发出具有时钟周期的脉冲信号。接收方在接到信号后就知道在一个脉冲信号的周期截获并解析一个二进制码，这种方法称为<strong>外同步法</strong>。</p><p><img src="https://s2.loli.net/2026/01/25/TyWkPDMGRX6s7LK.png" alt="image-20251118143611473"></p><p><img src="https://s2.loli.net/2026/01/25/Of2eFSmYlazC4Au.png" alt="image-20251118144031603"></p><p><strong>自同步码后面会提到。</strong></p><p><strong>同理，总线也有一个总线控制器，里面有总线时钟来负责同步工作。</strong></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://s2.loli.net/2026/01/25/udzVSmayZ2whH4L.png" alt="image-20251118144940589"></p><p><strong>并行运输有缺点，30米以上的长度会导致不同信道的信号到达时间不同，会导致****数据错误</strong></p><p><strong>然而总线中有不同类型的支线，支线内部也是****并行传输</strong>的。</p><p><img src="https://s2.loli.net/2026/01/25/8cfn2VdaLPyRDXt.png" alt="image-20251118145035698"></p><p><strong>每一个总线有自己的时钟频率，****单位是赫兹hz</strong>，100MHz表示每秒传输100M次数据。</p><p><strong>所以总线带宽表示总线的最大数据传输率，即****单位时间没最多可以传输的数据量。</strong></p><p>$$<br>\text{总线带宽}=\text{总线宽度}\times\frac{1s}{\text{总线时钟周期}}=\text{总线宽度}\times\text{总线时钟频率}<br>$$</p><p><strong>总线时钟频率是每秒可以发送多少次数据，总线宽度就是每次你能够发送多少位数据。</strong></p><p>$$<br>\text{总线带宽}=32\mathrm{~bit~*~33MHz=(32/8)~B~*~33MHz=~132~MB/s}\quad(1\mathrm{M=10^{6})}<br>$$</p><p><strong>但是现在有的总线在一个总线时钟周期内能够发送2次甚至是4次数据，这样的技术名为DDR技术。</strong></p><p><strong>这时候，总线的工作频率就是总线时钟频率的2倍或者4倍。</strong></p><p><strong>这时：****总线带宽=总线宽度×总线工作频率=总线宽度×总线时钟频率×数据传输倍数</strong></p><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p><strong>主设备</strong>指的是在总线中发射信号的设备，<strong>具有总线控制权</strong>，<strong>从设备</strong>是在总线中接收信号的设备，<strong>没有总线控制权</strong>。</p><p><strong>比如，存储器总线中，CPU是主设备，主存是从设备。</strong></p><p><strong>主设备想控制从设备需要先向总线控制器发送信号，得到同意信号后才能拿到控制权，才能通过总线通信。如果多个主设备申请，总线需要仲裁需要确定同意哪些申请。</strong></p><p><strong>仲裁分为****集中式仲裁</strong>和分布式仲裁。</p><p><strong>集中式仲裁又分为****链式查询方式，计时器查询方式和独立请求方式。</strong></p><p><strong>链式查询方式:</strong></p><p><img src="https://s2.loli.net/2026/01/25/gDRMboc4lkZ7eCv.png" alt="image-20251118202635094"></p><p><strong>设备4和设备n发送使用申请，随即总线授权线会逐个检查设备是否发送过申请，如果发送过就同意申请。这样的方式使用几根线就能实现一定优先次序的总线仲裁，容易扩充设备。但是对电路敏感很故障，而且查询链的次序很固定。</strong></p><p><strong>计数器定时查询：</strong></p><p><img src="https://s2.loli.net/2026/01/25/dtLCFIw1uvkmQWf.png" alt="image-20251118203113491"></p><p><strong>总线控制器内置一个计数器，初始为1，如果设备2发送了总线请求，总线控制器会将1这个数值通过设备号线发送到每个设备（也就是广播），随即检查设备号与发送的数值相等的设备有没有发送过请求，如果有就同意，如果没有就让计数器自增然后向所有设备广播2,这个数值，检查到设备2并同意之后，总线忙，该阶段计数器不会变化。总线被设备2解除占用后，计数器恢复自增功能，变为3继续检查。</strong></p><p><strong>优点是优先级是相同的，计数器初始值可以通过程序设置，但是控制线数量很多，如果有15个设备，至少需要4位二进制，2^4 = 16。n台设备需要log2(n)条数据线</strong></p><p><strong>独立请求方式（使用较多）：</strong></p><p><img src="https://s2.loli.net/2026/01/25/pqTGKujH9NLyXcO.png" alt="image-20251118204629549"></p><p><strong>每个设备都有独立的申请线路，总线控制器内部有一个排队电路，先接收到申请就先通过，先来后到，忙完下一个。</strong></p><p><strong>优点是响应速度很快，次序控制灵活，但是控制线数量很多，行线复杂，n台设备需要2n条控制线</strong></p><h2 id="总线事务周期"><a href="#总线事务周期" class="headerlink" title="总线事务周期"></a>总线事务周期</h2><p><img src="https://s2.loli.net/2026/01/25/zI8sOVqpBH7rYXg.png" alt="image-20251119141554016"></p><p><strong>数据线是双向的，用于传输数据，地址线传输数据对应的地址，控制线传输控制信息，比如时钟信号等，控制线整体上是双向的。</strong></p><p><strong>总线周期就是完成一次总线操作的时间。</strong></p><p><strong>一个周期包括四个阶段。</strong></p><p><strong>1.申请分配阶段</strong></p><p><strong>主设备向总线控制器发送申请，总线仲裁器将总线控制权移交到主设备。</strong></p><p><strong>2.寻址阶段</strong></p><p><strong>主设备通过总线发送从设备地址，启动从设备</strong></p><p><strong>3.数据传输阶段</strong></p><p><strong>主设备与从设备进行数据交换</strong></p><p><strong>4.结束</strong></p><p><strong>主设备的信息从总线中撤除，让出总线控制权</strong></p><h2 id="总线定时"><a href="#总线定时" class="headerlink" title="总线定时"></a>总线定时</h2><p><strong>总线周期内有很多操作时间：****发送地址，发送命令，提供数据，撤销命令，撤销数据。</strong></p><p><strong>总线定时是为了解决这些操作事件在一个周期内的先后次序关系。</strong></p><p><strong>定时方式有好几种，分为同步定时和异步定时。</strong></p><h2 id="同步定时："><a href="#同步定时：" class="headerlink" title="同步定时："></a>同步定时：</h2><p><strong>时钟信号线会发送4个时钟信号</strong></p><p><strong>以主设备读取从设备数据为例</strong></p><p><strong>T1：主设备发送从设备地址</strong></p><p><strong>T2：主设备发送读取从设备的命令</strong></p><p><strong>T3：从设备提供数据</strong></p><p><strong>T4：主从设备撤销命令，撤销数据</strong></p><blockquote><p><strong>这里没有申请分配阶段</strong></p></blockquote><p><strong>这样的定时方式有很高的传输频率但属于强制性同步，如果有读写很慢的部件他会拖慢整个读写速度。</strong></p><p><strong>适用于总线长度短，各设备存取时间差不多的情况。</strong></p><h2 id="异步定时"><a href="#异步定时" class="headerlink" title="异步定时"></a>异步定时</h2><p><strong>异步定时允许总线上设备存储时间不一致</strong></p><p><img src="https://s2.loli.net/2025/11/20/HX6q3jdTLMQkcFv.png" alt="image-20251120005210471"></p><p><strong>数据交换的过程是</strong></p><p><strong>主设备将地址发送到地址线等地址信号稳定后，通过控制线发送读命令到从设备，从设备将数据放到数据线，等到数据线信号稳定后，从设备使用一个确认线告知主设备连接安全，数据交换结束后，从设备撤销数据线，主设备撤销地址线</strong></p><p><strong>可以看出：后一个操作事件出现在总线上的时刻取决于前一个操作事件出现的时刻</strong></p><p><strong>异步请求有三种</strong></p><ul><li><strong>异步定时（不互锁）</strong></li><li><strong>主设备向从设备发送请求，等待一段时间后，不管有没有应答，撤销请求信号，就执行其他任务，从设备接收到请求，将数据放到数据线上，将确认通知发送到主设备，等待一段时间，撤销通知信号，然后执行其他任务。</strong></li><li><strong>异步定时（半互锁）</strong></li><li><strong>主设备发送请求，等待从设备应答，从设备应答，从设备将数据放到数据线中，从设备等待一定事件后离开并执行其他任务</strong></li><li><strong>异步定时（全互锁）</strong></li><li><strong>主从设备发出的信息必须等待回复，否则不能撤销信号，这就是二者的互相锁定</strong></li></ul><p><img src="https://s2.loli.net/2025/11/20/1DaWOVjrZXAiuL6.png" alt="image-20251120005455811"></p><p><strong>CPU和主存同步和异步都可以，有些读写速度差别过大的只能用异步，用同步会严重拖慢CPU速度。</strong></p><h1 id="总线数据传输方式"><a href="#总线数据传输方式" class="headerlink" title="总线数据传输方式"></a>总线数据传输方式</h1><p><strong>分为串行和并行，串行就是一次只能传输一位二进制信息，并行就是一次能够传输多为二进制信息，这和同步异步一起可以理解为4种场景。</strong></p><p><strong>也就是：</strong></p><ul><li><strong>同步串行通信</strong></li><li><strong>异步串行通信</strong></li><li><strong>同步并行通信</strong></li><li><strong>异步并行通信</strong></li></ul><h3 id="同步串行通信"><a href="#同步串行通信" class="headerlink" title="同步串行通信"></a>同步串行通信</h3><p><img src="https://s2.loli.net/2025/11/20/9DFa6uYwvlHOEhA.png" alt="image-20251120193110587"><strong>外同步法</strong>：每个时钟周期发送一位二进制</p><p><strong>自同步法</strong>：在每个数据元的头加上同步字符来同步</p><h3 id="异步串行通信（这很重要）"><a href="#异步串行通信（这很重要）" class="headerlink" title="异步串行通信（这很重要）"></a>异步串行通信（这很重要）</h3><p><strong>现代大多数总线都是这种通信模式，这很重要。</strong></p><p><strong>不需要同步时钟，以字符为单位传输</strong></p><p><strong>字符结构示意图：</strong></p><p><img src="https://s2.loli.net/2025/11/20/Lf1QeXgWJFIiuMk.png" alt="image-20251120193629922"></p><p><strong>奇偶校验是为了检查传输是否有错误，分为奇校验和偶校验。</strong></p><p><strong>奇偶校验位是一个附加位，其值（0或1）使得包括校验位在内的整个数据单元中“1”的个数为奇数（奇校验）或偶数（偶校验）</strong>。</p><p><strong>比如奇校验数据1011001****1</strong>，加粗是校验位可以看到，为了使包括校验位在内的1的数量为奇数，校验位只能是1。如果传输中出错，某一个1变为0，那就统计的数量时不再是奇数。</p><blockquote><p><strong>但是如果出错两个，那就检查不出来，更别提纠正。</strong></p></blockquote><p><img src="https://s2.loli.net/2025/11/20/Z2KNXIzeq4Q5tVY.png" alt="image-20251120194726429"></p><p><strong>数据传输速率用波特率来衡量。</strong></p><p><strong>波特率：单位时间内传输的二进制数据位数，单位bps(位/秒)</strong></p><h2 id="突发传输"><a href="#突发传输" class="headerlink" title="突发传输"></a><strong>突发传输</strong></h2><p><img src="https://s2.loli.net/2025/11/20/ScQElq7rMJuVFts.png" alt="image-20251120200403727"></p><p><strong>如果是非突发传输：命令周期为T</strong></p><p><strong>T1：传起始地址</strong></p><p><strong>T2：传读命令</strong></p><p><strong>T3：读取4地址的数据</strong></p><p><strong>T4：撤销命令和地址</strong></p><p><strong>以后每一位数据都要这么干，要花4个周期。</strong></p><p><strong>如果是突发传输</strong></p><p><strong>T1：传地址</strong></p><p><strong>T2：传控制命令</strong></p><p><strong>T3：传一个数据</strong></p><p><strong>T4T5T6：传剩下三个数据</strong></p><p><strong>T7：撤销命令，结束传输</strong></p><p><strong>这么来就少了很多个周期，传输效率很高。</strong></p><h2 id="传统计算机的总线结构"><a href="#传统计算机的总线结构" class="headerlink" title="传统计算机的总线结构"></a>传统计算机的总线结构</h2><p><img src="https://s2.loli.net/2025/11/20/IhkDXuwfrsNvBGU.png" alt="image-20251120202945181"></p><p><img src="https://s2.loli.net/2025/11/20/FqGm6P3HXEwWgAL.png" alt="image-20251120203003896"></p><h2 id="现代计算机的总线结构"><a href="#现代计算机的总线结构" class="headerlink" title="现代计算机的总线结构"></a>现代计算机的总线结构</h2><p><strong>可以看到本来CPU之间是共享链接，在新的结构中是独立链接</strong></p><p><strong>PCle总线是一个串行的点对点总线，全双工。</strong></p><p><strong>PCIe的“全双工”是指****每个链路（Lane）由独立的发送和接收通道组成，支持同时双向传输</strong></p><p><img src="https://s2.loli.net/2025/11/20/Pbg1aiJus2FxhIr.png" alt="image-20251120204326662"></p><p><strong>总体结构</strong></p><p><img src="https://s2.loli.net/2025/11/20/89owjlUPDudyBZ6.png" alt="image-20251120204614104"></p><p><img src="https://s2.loli.net/2025/11/20/FufBCi6GaAYU314.png" alt="image-20251120204623170"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章：计算机系统概述</title>
    <link href="/posts/Chapter_1_Overview_of_Computer_Systems/"/>
    <url>/posts/Chapter_1_Overview_of_Computer_Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：计算机系统概述"><a href="#第一章：计算机系统概述" class="headerlink" title="第一章：计算机系统概述"></a>第一章：计算机系统概述</h1><p>请记住，所有的程序都是指令序列+数据</p><p>比如一个C语言的<strong>HelloWorld</strong>的展示</p><p><img src="https://s2.loli.net/2026/01/25/epZARrfonghF32y.png" alt="image-20251114202415262"></p><p>程序从硬盘复制到高速读写的主存储器中，然后从主存复制到CPU中执行，执行，最后数通过IO总线输出到显示器。</p><p><img src="https://s2.loli.net/2026/01/25/7DMRjYnAcCmKWTl.png" alt="image-20251114202922252"></p><p>一般地，存储器被划分为若干存储单元，<strong>每个单元一般可以存放8个二进制位</strong>（就是8个数位，每个数位只能是0和1），而每八个二进制位就被称为一个字节（这个规律是计算机普遍适用的），所以主存可以理解为字节数组，其存储地址是连续的。</p><h1 id="指令的设计"><a href="#指令的设计" class="headerlink" title="指令的设计"></a>指令的设计</h1><p>语言的发展历程：<strong>高级语言（C语言等）</strong>-&gt;汇编语言-&gt;机器语言（0-1代码）</p><p>机器语言就是0-1代码，前四个是操作码，是动词，后四个是地址码，是宾语，是被操作对象。</p><p>我在这里提到的是一个很简化的模型，没关系，第五章会详细讲到。</p><p><img src="https://s2.loli.net/2026/01/25/5S1ofxE3BzlWbaX.png" alt="image-20251117134258148"></p><p><img src="https://s2.loli.net/2026/01/25/pcnCbSKQwBsUNYz.png" alt="image-20251117135400155"></p><p>这样的指令集在不同的机器中是<strong>不一样</strong>的。</p><h1 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a>指令的执行</h1><p><img src="https://s2.loli.net/2026/01/25/PouNj2MyDilhfYe.png" alt="image-20251117140111392"></p><p>CPU与主存有三个总线，<strong>地址总线，控制总线和数据总线</strong></p><p>还需要各种寄存器：</p><p><strong>通用寄存器(GPRS)</strong></p><p><strong>程序计数器(PC):暂存下一条需要执行的指令，</strong></p><p><strong>指令寄存器(IR):暂存正在执行的指令</strong></p><p><strong>内存地址寄存器(MAR)：临时存放内存地址</strong></p><p><strong>内存数据寄存器(MDR)：临时存放数据</strong></p><p><strong>算术逻辑单元(ALU)：对数据运算</strong></p><p><strong>控制单元(CU)：发出控制信号和操作命令</strong></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><blockquote><p>主存中，左边的是命令，是主存这个数组中的数据，右边是地址，是数组的索引，建议配合上文图片阅读。</p></blockquote><p>首先，主存的第一条内存地址会放到PC中，控制单元会向PC和MAR发送控制信号，将PC中的地址传到MAR，MAR通过地址总线传到主存，CU通过控制总线将控制信号发到主存，主存将地址对应的数据通过数据总线走到MDR，（此时MDR中的是待执行命令），CU给MDR和IR发送小信号，将MDR的数据存放到IR中，<strong>这就完成了取出指令(取指)的操作</strong>。</p><p>随即PC自增2(也不一定是2，取决于实际指令长度)，切换到主存中的下一个索引，执行下一条指令。</p><p>CU会分析IR中的操作码，给IR和MAR控制信号，将源操作数（目标）的地址通过地址总线传输到主存，CU再发送控制信号，主存会将根据接收到的地址将目标的数据通过数据总线发回到MDR，随即CU向通用寄存器和MDR发送信号，MDR的数据转移到0号寄存器。</p><p>在引入两套数据之后，下一条引入的指令往往是操作而非数据，CU会根据需要给ALU发送指令，将寄存器中的值进行加减乘除操作，并将结果存入到目标寄存器地址中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>+1指的是移动到下一指令的操作，具体加多少需要看指令长度</p></blockquote><p><img src="https://s2.loli.net/2026/01/25/ci1Jl4MN39QRtr6.png" alt="image-20251117143140761"></p><h2 id="冯诺依曼计算机结构"><a href="#冯诺依曼计算机结构" class="headerlink" title="冯诺依曼计算机结构"></a>冯诺依曼计算机结构</h2><p><img src="https://s2.loli.net/2026/01/25/o9Bf4XpcaKxumjW.png" alt="image-20251117144057087"></p><p><strong>注意：存储器包括 输入设备 输出设备 控制器 运算器</strong></p><p>运算器:执行算数运算和逻辑运算</p><p>存储器:存放内存和指令，分为主存（内存条）和外存（硬盘）</p><p>控制器:指挥中心，发送指令与控制信息，包括前文提到的PC，IR，CU</p><p><strong>在那个年代</strong>，这种计算机结构以<strong>运算器</strong>为中心，参与存储和输出的工作，这就使得容易达到性能瓶颈。鉴于冯诺依曼具有跨时代意义的设计，现代计算机很大程度上沿用了冯诺依曼结构，但是以<strong>存储器</strong>为中心，只有需要计算才会使用运算器，这样就能将存储和输出与运算器解耦，解放性能。</p><p><img src="https://s2.loli.net/2026/01/25/tdRapZfXSgYjxv8.png" alt="image-20251117144125877"></p><p>实际上，运算器和控制器联系紧密，往往集成在同一个芯片(IC)上，这块IC名为<strong>中央处理器CPU</strong>。</p><p><img src="https://s2.loli.net/2026/01/25/oz1xFTS4JvKbmsR.png" alt="image-20251117144349525"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>冯诺依曼计算机结构有五个特点：</p><p>①:计算机由运算器、控制器、存储器、输入设备和输出设备5个基本部件组成</p><p>②:指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们</p><p>③:指令和数据均用二进制代码表示</p><p>④:指令由操作码和操作数组成两部分组成，操作数可以是多个</p><p>⑤:采用“存储程序”工作方式</p><blockquote><p>存储程序：将事先编制好的程序和原始数据送入主存储器后才能执行，一旦开始执行，不需要人员干预就会自动逐条执行完毕。</p></blockquote><h1 id="语言的编译过程"><a href="#语言的编译过程" class="headerlink" title="语言的编译过程"></a>语言的编译过程</h1><p>高级语言翻译成机器语言程序一般是使用编译器和解释器，编译器会一次性将所有的代码编译成机器码，解释器逐行解释为机器码</p><p><img src="https://s2.loli.net/2026/01/25/TKizcns2MZj8gJl.png" alt="image-20251117145328787"></p><p>第一阶段是对C文件略作修改，对#include的预处理指令做解析和替换。</p><p>第二阶段是将C语言翻译成汇编程序，仍是文本</p><p>第三阶段是将汇编程序转化为二进制机器码，这一阶段已经不是文本了，所以直接打开会乱码。</p><p>第四阶段是将程序中的函数连接起来，形成一个整体的exe，供执行。</p><p>你可以使用编译器来实现“半编译”的效果。</p><p>解释器会将一行的指令解释为机器语音指令，直接可执行。</p><blockquote><p>抽象能力很重要,梳理需求的时间比操作时间长的多。</p></blockquote><p><img src="https://s2.loli.net/2026/01/25/PBMFipCZbNLm81S.png" alt="image-20251117152307862"></p><p>很多时候可以用“教室”“课程段”来集合我们的多对多关系。</p><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p><img src="https://s2.loli.net/2026/01/25/V4T3ZMYLJ6maQUd.png" alt="image-20251117153817438"></p><p>每一层都是由下一层支持的，每一层又在支持着上一层</p><p>底层是晶体管，一般是MOS管，mos管内部有一个电压阈值，能够依据电压调整导通情况，高于阈值的电压称作高压，反之低压。</p><p>NMOS:高压导通，低压不通</p><p>PMOS:高压不导通，低压导通</p><p>逻辑电路:低压表示0，高压表示1，使用晶体管可以方便地运行与或非运算。</p><p>一般地，我们只需要知道数电课里的表示就可以了，原件内部的半导体如何摆放，如何设计的，那不是很重要。</p><p><img src="https://s2.loli.net/2026/01/25/RqbiKZ4dVQXchnA.png" alt="image-20251117194512215"></p><p>操作系统负责掌控计算机的每一个硬件，控制程序调度</p><p>其实在操作系统层和功能部件层中包括了两层，是指令集体系结构(<strong>ISA</strong>)和微体系结构。</p><p><strong>ISA</strong>:定义了计算机可以执行的所有指令，规定了指令对应的操作，规定了操作数存放位置和操作数类型</p><p><strong>微体系结构</strong>：比如指令的流水线设计，加法器的进位方式，等等，规定了ISA的具体实现</p><p>计算机的软件和硬件在逻辑功能上是等价的。</p><p>我们会加速<strong>经常性行为</strong>来增强性能。</p><h1 id="计算机性能评估指标"><a href="#计算机性能评估指标" class="headerlink" title="计算机性能评估指标"></a>计算机性能评估指标</h1><p>三个性能指标：</p><ul><li><strong>时钟周期（Clock cycle）</strong></li><li><strong>时钟频率（主频）</strong></li><li><strong>CPI</strong></li></ul><p><strong>时钟周期：就是CPU执行操作的节奏，CPU一般是一个周期执行若干固定数量的操作。</strong></p><p>如果一个指令是5个时钟周期，一个时钟周期试试20ms，那么执行指令需要100m</p><p>所以，周期越短，执行速度越快。</p><p><strong>主频：就是时钟周期的倒数，主频越大，执行越快。</strong></p><p><strong>CPI：执行一条指令需要的时钟周期数</strong></p><p>当然这是<strong>分情况讨论的</strong>，如果是一个指令那就是执行这条指令的花费周期</p><p>如果是一个程序，那就指的是该程序所有指令执行所需的平均时钟周期数</p><p>如果是一台机器，那就是执行该机器指令中所有指令执行所需的<strong>平均时钟周期数</strong></p><p>CPU执行时间 = 程序指令条数 * CPI * 时钟周期</p><p><strong>我们能够通过修改指令集来减少程序总指令条数，但是那样会导致CPU结构变化，可能增大时钟周期。三者相互制约，增强性能的方式往往都是有代价的。</strong></p><h2 id="三种性能指标的评估方式"><a href="#三种性能指标的评估方式" class="headerlink" title="三种性能指标的评估方式"></a>三种性能指标的评估方式</h2><h2 id="方法一：用指令执行速度评估"><a href="#方法一：用指令执行速度评估" class="headerlink" title="方法一：用指令执行速度评估"></a>方法一：用指令执行速度评估</h2><p><strong>IPS：平均每秒执行指令数量</strong></p><p>IPS = 主频/平均CPI</p><p>IPS越高，性能越好（待证实，很多时候现实不是这样的）</p><p>MIPS（Million IPS）：平均每秒执行多少百万条指令</p><p>MIPS = IPS * 10^-6</p><p>例题：</p><p><img src="https://s2.loli.net/2026/01/25/jPfS7EwHeX4xviC.png" alt="image-20251118135437736"></p><p><strong>FLOPS：平均每秒执行多少次浮点运算操作</strong></p><p>类似于MIPS，有MFLOPS，GFLOPS等类似的指标，只有单位上的不同</p><h2 id="方法二：用基准程序进行评估"><a href="#方法二：用基准程序进行评估" class="headerlink" title="方法二：用基准程序进行评估"></a>方法二：用基准程序进行评估</h2><p>同一个基准程序，在两台计算机执行的时间差就能够拿到性能差，但仅仅使用一个程序是不全面且不科学的，所以玩往往会用到一组程序。</p><p><strong>基准程序是专门用来进行性能评价的一组程序</strong></p><p>如SPEC测试程序集，分为了整数测试程序集SPECint，浮点型SPECfp，CPU性能测试集SPEC CPU 2000，WEB测试 SPEC web等。</p><h2 id="方法三：阿姆达尔定律"><a href="#方法三：阿姆达尔定律" class="headerlink" title="方法三：阿姆达尔定律"></a>方法三：阿姆达尔定律</h2><p>基本思想:对系统中某个硬件部分，或者软件中的某部分<strong>进行更新所带来的系统性能的改进程度</strong>，取决于该硬件部分或软件部分被使用的频率或其执行时间占总执行时间的比例。</p><p>通俗的说，就是针对某一处硬件或者软件修改，看修改后性能增强了多少。这取决于计算机执行这个操作的频率高不高，高的话能吃到的增强就越多。</p><p><img src="https://s2.loli.net/2026/01/25/z8x7j1isFuAkaK2.png" alt="image-20251118140426107"></p><p>例如：</p><p><img src="https://s2.loli.net/2026/01/25/BFHeRfohxS5jtwL.png" alt="image-20251118140825158"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生日提醒开发笔记</title>
    <link href="/posts/Birthday_reminder/"/>
    <url>/posts/Birthday_reminder/</url>
    
    <content type="html"><![CDATA[<h1 id="生日提醒开发笔记"><a href="#生日提醒开发笔记" class="headerlink" title="生日提醒开发笔记"></a>生日提醒开发笔记</h1><blockquote><p><strong>这是笔者在大一下创新实践课程做的项目，即使还有很多上线刚需的功能没有实装，但是暂时的回顾和复盘是很有必要的。年后两个月左右我会将剩下的功能补齐，到时候再更新文档。</strong></p><p><strong>笔者表达能力堪忧，所以请结合源码阅读。</strong></p></blockquote><h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p><strong>在快节奏的现代生活中，我们忙于处理无数事务，重要的日子——比如亲友的生日——常常在指尖悄然溜走。即便记得日期，也可能因一时疏忽而错过那个送上祝福的最佳时刻。这种遗忘不仅留下遗憾，也可能让一份本该温暖的关系悄然降温。</strong></p><p><strong>为此，“生日提醒”应运而生。它不止是一个简单的生日记录工具，更是一位贴心的私人提醒助手。您只需提前设置好重要日期，应用便会在预设时间智能发出提醒，为您留出充足的时间准备礼物、构思祝福，或在那一刻准时送上问候。让我们帮助您，把每一个值得纪念的日子，都变成温暖人心的时刻。</strong></p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><strong>亲友管理</strong>：记录亲友基本信息、生日日期、标签分类</li><li><strong>提醒计划</strong>：设置提前N天提醒，支持多种提醒时间</li><li><strong>自动邮件</strong>：生日当天自动发送个性化祝福邮件</li><li><strong>双模式提醒</strong>：<ul><li><strong>提醒用户模式：提前通知用户准备生日祝福</strong></li><li><strong>自动祝福模式：生日当天自动发送祝福给亲友</strong></li></ul></li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><table><thead><tr><th><strong>类别</strong></th><th><strong>技术/组件</strong></th><th><strong>版本/说明</strong></th></tr></thead><tbody><tr><td><strong>核心框架</strong></td><td><strong>Spring Boot</strong></td><td><strong>3.5.8</strong></td></tr><tr><td><strong>Web框架</strong></td><td><strong>Spring Boot Starter Web</strong></td><td><strong>内置于Spring Boot</strong></td></tr><tr><td><strong>ORM框架</strong></td><td><strong>MyBatis</strong></td><td><strong>3.0.3</strong></td></tr><tr><td><strong>分页插件</strong></td><td><strong>PageHelper</strong></td><td><strong>2.1.0</strong></td></tr><tr><td><strong>邮件服务</strong></td><td><strong>Spring Boot Starter Mail</strong></td><td><strong>内置于Spring Boot</strong></td></tr><tr><td><strong>数据库</strong></td><td><strong>MySQL</strong></td><td><strong>8.0.31</strong></td></tr><tr><td><strong>开发工具</strong></td><td><strong>Lombok</strong></td><td><strong>1.18.38 (用于简化POJO)</strong></td></tr><tr><td></td><td><strong>Spring Boot Devtools</strong></td><td><strong>内置于Spring Boot (热部署)</strong></td></tr><tr><td><strong>工具库</strong></td><td><strong>Hutool</strong></td><td><strong>5.8.38</strong></td></tr><tr><td><strong>系统监控</strong></td><td><strong>Spring Boot Actuator</strong></td><td><strong>内置于Spring Boot</strong></td></tr><tr><td><strong>定时任务</strong></td><td><strong>基于Spring Boot注解Schedule</strong></td><td><strong>内置于Spring Boot</strong></td></tr></tbody></table><hr><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a><strong>前端</strong></h3><table><thead><tr><th><strong>类别</strong></th><th><strong>技术/组件</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>UI框架</strong></td><td><strong>Bootstrap</strong></td><td><strong>5</strong></td></tr><tr><td><strong>图标库</strong></td><td><strong>Font Awesome</strong></td><td><strong>阿里图标库</strong></td></tr><tr><td><strong>脚本语言</strong></td><td><strong>JavaScript</strong></td><td><strong>原生</strong></td></tr></tbody></table><hr><h2 id="项目构建与运行环境"><a href="#项目构建与运行环境" class="headerlink" title="项目构建与运行环境"></a><strong>项目构建与运行环境</strong></h2><table><thead><tr><th><strong>类别</strong></th><th><strong>技术/组件</strong></th></tr></thead><tbody><tr><td><strong>构建工具</strong></td><td><strong>Maven</strong></td></tr><tr><td><strong>JDK版本</strong></td><td><strong>JDK 25</strong></td></tr><tr><td><strong>数据库</strong></td><td><strong>MySQL 8.0+</strong></td></tr></tbody></table><hr><h3 id="项目架构与结构"><a href="#项目架构与结构" class="headerlink" title="项目架构与结构"></a><strong>项目架构与结构</strong></h3><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk">com.Birthday_reminder<br>├── Birthday_reminder.java                    <span class="hljs-comment"># Spring Boot启动类</span><br>├── controller/                              <span class="hljs-comment"># 控制器层</span><br>│   ├── HelloController.java                 <span class="hljs-comment"># 测试控制器</span><br>│   ├── MailTestController.java              <span class="hljs-comment"># 邮件测试控制器</span><br>│   ├── RelationshipController.java          <span class="hljs-comment"># 亲友关系控制器</span><br>│   ├── RelationshipRecordController.java    <span class="hljs-comment"># 提醒记录控制器</span><br>│   └── RelationshipReminderController.java  <span class="hljs-comment"># 生日提醒控制器</span><br>├── domain/                                  <span class="hljs-comment"># 实体层</span><br>│   ├── Relationship.java                    <span class="hljs-comment"># 亲友实体类</span><br>│   ├── ReminderPlan.java                    <span class="hljs-comment"># 提醒计划实体类</span><br>│   └── ReminderRecord.java                  <span class="hljs-comment"># 提醒记录实体类</span><br>├── dto/                                     <span class="hljs-comment"># 数据传输对象</span><br>│   ├── PageDTO.java                         <span class="hljs-comment"># 分页数据传输对象基类</span><br>│   └── RelationshipPageDTO.java             <span class="hljs-comment"># 亲友分页数据传输对象</span><br>├── mapper/                                  <span class="hljs-comment"># 数据访问层</span><br>│   ├── RelationshipMapper.java              <span class="hljs-comment"># 亲友数据访问接口</span><br>│   ├── ReminderPlanMapper.java              <span class="hljs-comment"># 提醒计划数据访问接口</span><br>│   └── ReminderRecordMapper.java            <span class="hljs-comment"># 提醒记录数据访问接口</span><br>├── service/                                 <span class="hljs-comment"># 服务层接口</span><br>│   ├── RelationPlanService.java             <span class="hljs-comment"># 关系计划服务接口</span><br>│   ├── RelationshipService.java             <span class="hljs-comment"># 亲友服务接口</span><br>│   └── ReminderRecordService.java           <span class="hljs-comment"># 提醒记录服务接口</span><br>├── service<span class="hljs-regexp">/impl/</span>                            <span class="hljs-comment"># 服务层实现类</span><br>│   ├── RelationPlanServiceImpl.java         <span class="hljs-comment"># 关系计划服务实现类</span><br>│   ├── RelationshipServiceImpl.java         <span class="hljs-comment"># 亲友服务实现类</span><br>│   └── ReminderRecordServiceImpl.java       <span class="hljs-comment"># 提醒记录服务实现类</span><br>├── task/                                    <span class="hljs-comment"># 定时任务</span><br>│   ├── BirthdayReminderJob.java             <span class="hljs-comment"># 生日提醒定时任务</span><br>│   └── MailJob.java                         <span class="hljs-comment"># 邮件发送定时任务</span><br>├── typehandler/                             <span class="hljs-comment"># 类型处理器</span><br>│   └── IntegerListJsonTypeHandler.java      <span class="hljs-comment"># JSON类型处理器</span><br>├── util/                                    <span class="hljs-comment"># 工具类</span><br>│   └── MailUtil.java                        <span class="hljs-comment"># 邮件工具类</span><br>└── vo/                                      <span class="hljs-comment"># 视图对象</span><br>    ├── PageVO.java                          <span class="hljs-comment"># 分页视图对象</span><br>    ├── RelationshipPageVO.java              <span class="hljs-comment"># 亲友分页视图对象</span><br>    └── ResponseEntity.java                  <span class="hljs-comment"># 响应实体类</span><br></code></pre></td></tr></tbody></table></figure><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p><strong>这是一个基于 *<em><strong>Spring Boot</strong> 的现代化单体应用程序，采用经典的</em>*分层架构</strong>。<strong>MyBatis</strong> 负责数据持久化，配合 <strong>PageHelper</strong> 处理分页。核心的生日提醒功能通过 <strong>Spring Mail</strong> 发送邮件。前端使用 <strong>Bootstrap</strong> 提供响应式界面，整个项目由 <strong>Maven</strong> 统一构建和管理。</p><h2 id="本项目使用的依赖"><a href="#本项目使用的依赖" class="headerlink" title="本项目使用的依赖"></a>本项目使用的依赖</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>​<br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Birthday_reminder<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>​<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--springboot整合mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--mybatis分页插件，已经包含了mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--mysql驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--简化实体类--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.38<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>​<br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.38<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;dependency&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;/dependency&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>​<br>​<br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>25<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>25<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><p><strong>我们需要三张表，一张是关系表，名为Relationship，作为主表记录主要信息。</strong></p><p><strong>一张是计划表，名为reminder_plan，关联主表记录提醒计划。</strong></p><p><strong>一张是记录表，名为reminder_record，关联主表，存储提醒记录，以便管理员查询和修改bug。</strong></p><p><strong>创建表结构的SQL如下：</strong></p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">​<br># 亲友关系表<br><span class="hljs-comment">-- table_birthday.relationship definition</span><br>​<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `relationship` (<br>                                `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>                                `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>                                `my_email` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `calendar_type` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span>,<br>                                `birthday` <span class="hljs-type">date</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `birthday_month` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `birthday_day` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `tag` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `reminder_enabled` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span>,<br>                                `congratulate_enabled` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span>,<br>                                `relationship_email` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `greeting` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `self_call` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `notes` <span class="hljs-type">text</span>,<br>                                `days_before` <span class="hljs-type">json</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>                                `created_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>                                `updated_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>                                <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">38</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_0900_ai_ci;<br># 提醒计划表<br># 该表用于规划后面的发送邮件等任务<br><span class="hljs-comment">-- table_birthday.reminder_plan definition</span><br>​<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `reminder_plan` (<br>                                 `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'计划ID，主键'</span>,<br>                                 `relationship_id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'关联的亲友关系ID'</span>,<br>                                 `reminder_date` <span class="hljs-type">date</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'提醒日期'</span>,<br>                                 `days_before` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'提前提醒天数'</span>,<br>                                 `reminder_type` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'提醒类型 (0:生日提醒, 1:其他提醒)'</span>,<br>                                 `execution_status` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'执行状态 (0:待执行, 1:已执行, 2:已取消)'</span>,<br>                                 `created_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建时间'</span>,<br>                                 `updated_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'更新时间'</span>,<br>                                 <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>                                 KEY `relationship_id` (`relationship_id`),<br>                                 <span class="hljs-keyword">CONSTRAINT</span> `reminder_plan_ibfk_1` <span class="hljs-keyword">FOREIGN KEY</span> (`relationship_id`) <span class="hljs-keyword">REFERENCES</span> `relationship` (`id`) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span><br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">32</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_0900_ai_ci <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'提醒计划表'</span>;<br># 提醒记录表<br># 记录，用于保存系统日志供日后查询<br><span class="hljs-comment">-- table_birthday.reminder_record definition</span><br>​<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `reminder_record` (<br>                                   `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'记录ID，主键'</span>,<br>                                   `relationship_id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'关联的亲友关系ID'</span>,<br>                                   `reminder_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'实际提醒时间'</span>,<br>                                   `receiver` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'提醒接收方'</span>,<br>                                   `reminder_type` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'提醒类型'</span>,<br>                                   `reminder_content` <span class="hljs-type">text</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'提醒内容'</span>,<br>                                   `send_status` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'发送状态 (0:成功, 1:失败)'</span>,<br>                                   `created_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建时间'</span>,<br>                                   <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>                                   KEY `relationship_id` (`relationship_id`),<br>                                   <span class="hljs-keyword">CONSTRAINT</span> `reminder_record_ibfk_1` <span class="hljs-keyword">FOREIGN KEY</span> (`relationship_id`) <span class="hljs-keyword">REFERENCES</span> `relationship` (`id`) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span><br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">3</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_0900_ai_ci <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'提醒记录表'</span>;<br>​<br></code></pre></td></tr></tbody></table></figure><p><strong>值得一提的是，我在创建时间和修改时间使用的语句是</strong></p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">`created_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建时间'</span>,<br>`updated_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'更新时间'</span>,<br></code></pre></td></tr></tbody></table></figure><p><strong>使用了MySQL的原生功能—-自动填充变动时间戳，这意味着我们不再需要在项目中额外用代码配置。</strong></p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><strong>这是在开发过程中一个比较重要的知识点。</strong></p><p><strong>跨域是浏览器的一种安全限制，它阻止你网页上的JavaScript代码，去请求另一个“来源”（域名、端口、协议不同）的服务器的数据。</strong></p><p><strong>也就是****默认情况下，只允许网页与“同源”的服务器自由通信。</strong></p><p><strong>同源</strong>指的是协议端口域名都必须相同，一旦出现以下任意一种情况，浏览器就会自动拦截操作</p><ul><li><strong>协议不同：</strong><code>http://example.com</code> 请求 <code>https://example.com</code></li><li><strong>域名不同：</strong><code>http://a.com</code> 请求 <code>http://b.com</code></li><li><strong>端口不同：</strong><code>http://localhost:3000</code> 请求 <code>http://localhost:8080</code></li></ul><p><strong>作为一个简单的演示级项目，我们将前端三件套的文件(html,css,js)等与后端文件放在一起，实现逻辑上的分离但结构上的耦合。</strong></p><h2 id="使用MyBatisX插件快速生成实体类"><a href="#使用MyBatisX插件快速生成实体类" class="headerlink" title="使用MyBatisX插件快速生成实体类"></a>使用MyBatisX插件快速生成实体类</h2><p><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx/">MyBatisX</a>插件是一个强大的IDEA插件，能够提供跳转、代码生成、提示等功能，优化基于MyBatis/MyBatis-Plus的开发体验。我们可以用它生成实体类甚至是Service层。</p><p><strong>在Idea中配置数据库之后就能够用MybatisX插件生成实体类，具体教程请自行搜索。</strong></p><p><strong>请原谅，我不可能在这里用大量图片篇幅来解释这个过程。</strong></p><h2 id="项目结构层级作用"><a href="#项目结构层级作用" class="headerlink" title="项目结构层级作用"></a>项目结构层级作用</h2><blockquote><p><strong>想半天也不知道怎么写，将就看吧。</strong></p><p><strong>有些层和其他层耦合严重，介绍层级就按照拓扑排序顺序来，先讲简单的。</strong></p></blockquote><p><strong>项目一共有几个层级，分别是：</strong></p><ul><li><strong>Controller控制器层：与前端直接交互，完成交互逻辑</strong></li><li><strong>Domain实体层：将数据库格式转化为java对象</strong></li><li><strong>DTO层：数据运输对象，封装某些参数在网络中传输，不带逻辑处理，作用是减少网络中传输次数。</strong></li><li><strong>Mapper数据访问层：Java的数据库接口，声明了数据库操作方法</strong></li><li><strong>Service服务层接口：针对三个界面写的三个接口，在Impl层用类实现并填充</strong></li><li><strong>Task层：基于@Schedule实现，负责执行定时任务。</strong></li><li><strong>TypeHandler层：数据转换器层将json类型转化为java对象，这个后面会提一嘴。</strong></li><li><strong>Util层：工具类，发送邮件</strong></li><li><strong>VO层：视图对象，为了美观地展示数据，我们需要将返回的数据封装成一个识图对象，才能与前端联动展示</strong></li></ul><p><strong>所以，整体执行逻辑应该是：</strong></p><p><img src="https://s2.loli.net/2026/01/02/yqdeFsAPBIZ45vC.png" alt="4d57680833c09"></p><h2 id="DTO层"><a href="#DTO层" class="headerlink" title="DTO层"></a>DTO层</h2><p><strong>我们用了PageHelper插件来实现分页展示那参数就是页码page和每页要展示的数量size.</strong></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">PageDTO</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Serializable</span> {<br>​<br>    <span class="hljs-keyword">private</span> Integer page;<br>    <span class="hljs-keyword">private</span> Integer size;<br>​<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>那就集成序列化类，写一个简单的类就行了。</strong></p><h2 id="Domain层"><a href="#Domain层" class="headerlink" title="Domain层"></a>Domain层</h2><blockquote><p><strong>这里有什么好写的？</strong></p></blockquote><p><strong>使用MyBatisX插件生成的，你自己写的话注意和数据库的数据类型和顺序要完全对得上。</strong></p><p><strong>插件为了保证稳妥，甚至自动生成了操作方法，虽然这样的写法可读性不可理喻。</strong></p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> boolean equals(Object that) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == that) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (that == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (getClass() != that.getClass()) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        Relationship other = (Relationship) that;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.getId() == <span class="hljs-literal">null</span> ? other.getId() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getId().equals(other.getId()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getName() == <span class="hljs-literal">null</span> ? other.getName() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getName().equals(other.getName()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getCalendarType() == <span class="hljs-literal">null</span> ? other.getCalendarType() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getCalendarType().equals(other.getCalendarType()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getBirthday() == <span class="hljs-literal">null</span> ? other.getBirthday() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getBirthday().equals(other.getBirthday()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getBirthdayMonth() == <span class="hljs-literal">null</span> ? other.getBirthdayMonth() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getBirthdayMonth().equals(other.getBirthdayMonth()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getBirthdayDay() == <span class="hljs-literal">null</span> ? other.getBirthdayDay() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getBirthdayDay().equals(other.getBirthdayDay()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getTag() == <span class="hljs-literal">null</span> ? other.getTag() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getTag().equals(other.getTag()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getRemindEnabled() == <span class="hljs-literal">null</span> ? other.getRemindEnabled() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getRemindEnabled().equals(other.getRemindEnabled()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getCongratulateEnabled() == <span class="hljs-literal">null</span> ? other.getCongratulateEnabled() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getCongratulateEnabled().equals(other.getCongratulateEnabled()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getRelationshipEmail() == <span class="hljs-literal">null</span> ? other.getRelationshipEmail() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getRelationshipEmail().equals(other.getRelationshipEmail()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getGreeting() == <span class="hljs-literal">null</span> ? other.getGreeting() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getGreeting().equals(other.getGreeting()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getSelfCall() == <span class="hljs-literal">null</span> ? other.getSelfCall() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getSelfCall().equals(other.getSelfCall()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getNotes() == <span class="hljs-literal">null</span> ? other.getNotes() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getNotes().equals(other.getNotes()))<br>            &amp;&amp; (<span class="hljs-keyword">this</span>.getDaysBefore() == <span class="hljs-literal">null</span> ? other.getDaysBefore() == <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.getDaysBefore().equals(other.getDaysBefore()));<br>    }<br>​<br></code></pre></td></tr></tbody></table></figure><h2 id="Util层"><a href="#Util层" class="headerlink" title="Util层"></a>Util层</h2><p><strong>一个工具类，没什么好说的，调用函数，传入该传的原子参数就行。</strong></p><h2 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h2><p><strong>这一层就是声明数据库查询方法，具体实现看源码。</strong></p><h2 id="TypeHandler层"><a href="#TypeHandler层" class="headerlink" title="TypeHandler层"></a>TypeHandler层</h2><p><strong>明确，在前端，提前天数是可选的：</strong></p><p><img src="https://s2.loli.net/2026/01/02/gPn1ByNTFflW3rk.png" alt="image-20260102030446635"></p><p><strong>数据库中提前天数我使用的是</strong></p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">`days_before` <span class="hljs-type">json</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br></code></pre></td></tr></tbody></table></figure><p><strong>这是一个非空的json数据类型，比较的“生僻”，所以使用MyBatisX插件的时候，他将数据库的提前天数给我生成了object类，这是java的一个很底层的基类，直接使用它可能会出现类型</strong><code>安全问题，代码可读性差，Lombok生成意外方法</code>等问题，所以最好将他转化为java更常用的数据类型，我们单独写了TypeHandler来解决这个问题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.json.JSONUtil;  <span class="hljs-comment">//hutool类型工具</span><br><span class="hljs-keyword">import</span> org.apache.ibatis.type.BaseTypeHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.type.JdbcType;<br>​<br><span class="hljs-keyword">import</span> java.sql.CallableStatement;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br>​<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerListJsonTypeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;List&lt;Integer&gt;&gt; {<br>​<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i, List&lt;Integer&gt; parameter, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span>JSONUtil.toJsonStr(parameter);<br>        ps.setString(i,json);<br>    }<span class="hljs-comment">//这里只展示部分代码</span><br></code></pre></td></tr></tbody></table></figure><p><strong>也是使用了Java内置和hutools工具箱去转换，具体请移步到项目源码。</strong></p><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><p><strong>这里才是真正的业务大脑，在这里需要做到</strong></p><ul><li><strong>一个接口，一个实现</strong></li><li><strong>处理复杂的业务规则</strong></li><li><strong>协调多个Mapper完成一个功能</strong></li></ul><h3 id="Relationship接口"><a href="#Relationship接口" class="headerlink" title="Relationship接口"></a>Relationship接口</h3><p><strong>增删改查：</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-title class_">Relationship</span> <span class="hljs-title function_">getRelationship</span>(<span class="hljs-params">Integer id</span>) {<br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span> || id &lt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"无效的ID"</span>);<br>        }<br>        <span class="hljs-title class_">Relationship</span> relationship = relationshipMapper.<span class="hljs-title function_">selectById</span>(id);<br>        <span class="hljs-keyword">if</span> (relationship == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"未找到对应的亲友关系"</span>);<br>        }<br>        <span class="hljs-keyword">return</span> relationship;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Relationship</span> <span class="hljs-title function_">createRelationship</span>(<span class="hljs-params">Relationship relationship</span>) {<br>        int result = relationshipMapper.<span class="hljs-title function_">insert</span>(relationship);<span class="hljs-comment">//具体insert方法怎么写就看源码，这里没什么奇淫技巧。</span><br>        <span class="hljs-keyword">return</span> relationship;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Boolean</span> <span class="hljs-title function_">updateRelationship</span>(<span class="hljs-params">Relationship relationship</span>) {<br>        <span class="hljs-title class_">Relationship</span> existing = relationshipMapper.<span class="hljs-title function_">selectById</span>(relationship.<span class="hljs-title function_">getId</span>());<br>        <span class="hljs-keyword">if</span> (existing == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        int result = relationshipMapper.<span class="hljs-title function_">update</span>(relationship);<br>        <span class="hljs-keyword">return</span> result &gt; <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Boolean</span> <span class="hljs-title function_">deleteRelationship</span>(<span class="hljs-params">Integer id</span>) {<br>        int result = relationshipMapper.<span class="hljs-title function_">delete</span>(id);<br>        <span class="hljs-keyword">return</span> result &gt; <span class="hljs-number">0</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>分页效果：</strong></p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义方法，接收一个RelationshipPageDTO参数，返回PageInfo&lt;RelationshipPageVO&gt;类型的分页结果</span><br>public PageInfo&lt;RelationshipPageVO&gt; query<span class="hljs-constructor">RelationshipPage(RelationshipPageDTO <span class="hljs-params">dto</span>)</span> {<br><br>    <span class="hljs-comment">// 使用PageHelper插件开始分页查询，设置当前页码和每页大小</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageHelper</span>.</span></span>start<span class="hljs-constructor">Page(<span class="hljs-params">dto</span>.<span class="hljs-params">getPage</span>()</span>, dto.get<span class="hljs-constructor">Size()</span>);<br><br>    <span class="hljs-comment">// 调用Mapper层查询所有符合条件的亲友关系列表</span><br>    List&lt;Relationship&gt; relationships = relationshipMapper.select<span class="hljs-constructor">All(<span class="hljs-params">dto</span>)</span>;<br><br>    <span class="hljs-comment">// 将查询结果封装到PageInfo对象中，包含分页相关信息</span><br>    PageInfo&lt;Relationship&gt; pageInfo = <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(relationships);<br><br>    <span class="hljs-comment">// 将Relationship实体对象转换为RelationshipPageVO视图对象</span><br>    <span class="hljs-comment">// 使用Stream流处理，通过BeanUtils.copyProperties方法复制属性</span><br>    List&lt;RelationshipPageVO&gt; vos = pageInfo.get<span class="hljs-constructor">List()</span>.stream<span class="hljs-literal">()</span>.map(relationship -&gt; {<br>        RelationshipPageVO vo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RelationshipPageVO()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanUtils</span>.</span></span>copy<span class="hljs-constructor">Properties(<span class="hljs-params">relationship</span>, <span class="hljs-params">vo</span>)</span>;  <span class="hljs-comment">// 复制属性从实体对象到视图对象</span><br>        return vo;<br>    }).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);  <span class="hljs-comment">// 收集为List</span><br><br>    <span class="hljs-comment">// 创建新的PageInfo&lt;RelationshipPageVO&gt;对象</span><br>    PageInfo&lt;RelationshipPageVO&gt; result = <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(vos);<br><br>    <span class="hljs-comment">// 将原始pageInfo的分页属性复制到新的result对象中</span><br>    result.set<span class="hljs-constructor">Total(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getTotal</span>()</span>);           <span class="hljs-comment">// 总记录数</span><br>    result.set<span class="hljs-constructor">Pages(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getPages</span>()</span>);           <span class="hljs-comment">// 总页数</span><br>    result.set<span class="hljs-constructor">PageNum(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getPageNum</span>()</span>);       <span class="hljs-comment">// 当前页码</span><br>    result.set<span class="hljs-constructor">PageSize(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getPageSize</span>()</span>);     <span class="hljs-comment">// 每页大小</span><br>    result.set<span class="hljs-constructor">Size(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getSize</span>()</span>);             <span class="hljs-comment">// 当前页大小</span><br>    result.set<span class="hljs-constructor">StartRow(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getStartRow</span>()</span>);     <span class="hljs-comment">// 起始行</span><br>    result.set<span class="hljs-constructor">EndRow(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getEndRow</span>()</span>);         <span class="hljs-comment">// 结束行</span><br>    result.set<span class="hljs-constructor">PrePage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getPrePage</span>()</span>);       <span class="hljs-comment">// 上一页页码</span><br>    result.set<span class="hljs-constructor">NextPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getNextPage</span>()</span>);     <span class="hljs-comment">// 下一页页码</span><br>    result.set<span class="hljs-constructor">IsFirstPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">isIsFirstPage</span>()</span>); <span class="hljs-comment">// 是否为第一页</span><br>    result.set<span class="hljs-constructor">IsLastPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">isIsLastPage</span>()</span>);   <span class="hljs-comment">// 是否为最后一页</span><br>    result.set<span class="hljs-constructor">HasPreviousPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">isHasPreviousPage</span>()</span>); <span class="hljs-comment">// 是否有上一页</span><br>    result.set<span class="hljs-constructor">HasNextPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">isHasNextPage</span>()</span>); <span class="hljs-comment">// 是否有下一页</span><br>    result.set<span class="hljs-constructor">NavigatePages(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getNavigatePages</span>()</span>); <span class="hljs-comment">// 导航页码数</span><br>    result.set<span class="hljs-constructor">NavigatepageNums(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getNavigatepageNums</span>()</span>); <span class="hljs-comment">// 导航页码数组</span><br>    result.set<span class="hljs-constructor">NavigateFirstPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getNavigateFirstPage</span>()</span>); <span class="hljs-comment">// 导航首页</span><br>    result.set<span class="hljs-constructor">NavigateLastPage(<span class="hljs-params">pageInfo</span>.<span class="hljs-params">getNavigateLastPage</span>()</span>); <span class="hljs-comment">// 导航末页</span><br><br>    <span class="hljs-comment">// 返回封装好的分页结果</span><br>    return result;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>我觉得注释已经够详细了。</strong></p><h2 id="RelationRecord接口"><a href="#RelationRecord接口" class="headerlink" title="RelationRecord接口"></a>RelationRecord接口</h2><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReminderRecordServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReminderRecordService</span> {<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ReminderRecordMapper</span> mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">PageInfo</span>&lt;<span class="hljs-title class_">ReminderRecord</span>&gt; <span class="hljs-title function_">getPageList</span>(<span class="hljs-params">Integer page, Integer size, Integer relationshipId</span>) {<br>        <span class="hljs-title class_">PageHelper</span>.<span class="hljs-title function_">startPage</span>(page, size);<br>        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">ReminderRecord</span>&gt; list = mapper.<span class="hljs-title function_">selectAll</span>(relationshipId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(list);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReminderRecord</span> <span class="hljs-title function_">getById</span>(<span class="hljs-params">Integer id</span>) {<br>        <span class="hljs-keyword">return</span> mapper.<span class="hljs-title function_">selectById</span>(id);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">markAsProcessed</span>(<span class="hljs-params">Integer id</span>) {<br>        <span class="hljs-comment">// 标记为已处理状态，未实装</span><br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">ReminderRecord</span>&gt; <span class="hljs-title function_">getPendingRecords</span>(<span class="hljs-params"></span>)<br>    {<br>        <span class="hljs-keyword">return</span> mapper.<span class="hljs-title function_">selectPendingRecords</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="RelationPlan接口"><a href="#RelationPlan接口" class="headerlink" title="RelationPlan接口"></a>RelationPlan接口</h3><p><strong>该接口需要进行复杂的任务，请保持耐心</strong></p><h4 id="Plan方法"><a href="#Plan方法" class="headerlink" title="Plan方法"></a>Plan方法</h4><p><strong>为指定的亲友关系创建提醒计划。</strong></p><p><del>话说为什么答辩的时候脑子突然宕机了呢</del></p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义方法，接收一个Relationship对象作为参数</span><br>public void plan(Relationship relationship) {<br>    <span class="hljs-comment">// 检查传入的relationship是否为null，如果是则直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">relationship</span>)</span>){<br>        return;<br>    }<br><br>    <span class="hljs-comment">// 删除该亲友ID关联的所有旧提醒计划</span><br>    mapper.delete<span class="hljs-constructor">ByRelationshipId(<span class="hljs-params">relationship</span>.<span class="hljs-params">getId</span>()</span>);<br><br>    <span class="hljs-comment">// 验证必要参数（生日月份、日期和用户邮箱）</span><br>    validate<span class="hljs-constructor">Params(<span class="hljs-params">relationship</span>)</span>;<br><br>    <span class="hljs-comment">// 计算下一个生日日期,LocalDate是不带时间的日期类型。</span><br>    LocalDate birthday = calculate<span class="hljs-constructor">Birthday(<span class="hljs-params">relationship</span>)</span>;<br>    <span class="hljs-comment">// 获取当前日期</span><br>    LocalDate now = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalDate</span>.</span></span>now<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 创建一个空的提醒计划列表</span><br>    List&lt;ReminderPlan&gt; plans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// 1. 制定提醒用户的计划（reminderType=0）</span><br>    <span class="hljs-comment">// 检查是否启用了提醒功能（remindEnabled为1）</span><br>    <span class="hljs-keyword">if</span> (relationship.get<span class="hljs-constructor">RemindEnabled()</span> != null<span class="hljs-operator"> &amp;&amp; </span>relationship.get<span class="hljs-constructor">RemindEnabled()</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>) {<br>        <span class="hljs-comment">// 获取提前提醒天数列表（例如：[1, 3, 7] 表示提前1天、3天、7天提醒）</span><br>        List&lt;Integer&gt; daysBefore = relationship.get<span class="hljs-constructor">DaysBefore()</span>;<br>        <span class="hljs-comment">// 检查daysBefore列表是否不为空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CollectionUtil</span>.</span></span>is<span class="hljs-constructor">NotEmpty(<span class="hljs-params">daysBefore</span>)</span>) {<br>            <span class="hljs-comment">// 遍历每个提前提醒天数</span><br>            <span class="hljs-keyword">for</span> (Integer bf : daysBefore) {<br>                <span class="hljs-comment">// 计算提醒日期：生日日期减去提前提醒天数</span><br>                LocalDate reminderDate = birthday.minus<span class="hljs-constructor">Days(<span class="hljs-params">bf</span>)</span>;<br>                <span class="hljs-comment">// 如果当前日期已经过了提醒日期，则跳过该计划</span><br>                <span class="hljs-keyword">if</span> (now.is<span class="hljs-constructor">After(<span class="hljs-params">reminderDate</span>)</span>) {<br>                    continue;<br>                }<br>                <span class="hljs-comment">// 创建基础提醒计划</span><br>                ReminderPlan plan = build<span class="hljs-constructor">BasicPlan(<span class="hljs-params">relationship</span>)</span>;<br>                plan.set<span class="hljs-constructor">ReminderType(0)</span>;  <span class="hljs-comment">// 设置为提醒用户类型</span><br>                plan.set<span class="hljs-constructor">ReminderDate(<span class="hljs-params">reminderDate</span>)</span>;  <span class="hljs-comment">// 设置提醒日期</span><br>                plan.set<span class="hljs-constructor">DaysBefore(<span class="hljs-params">bf</span>)</span>;   <span class="hljs-comment">// 设置提前提醒天数</span><br>                plans.add(plan);  <span class="hljs-comment">// 将计划添加到列表</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 2. 制定自动祝贺计划（reminderType=1）</span><br>    <span class="hljs-comment">// 检查是否启用了自动祝贺功能（congratulateEnabled为1）</span><br>    <span class="hljs-keyword">if</span> (relationship.get<span class="hljs-constructor">CongratulateEnabled()</span> != null<span class="hljs-operator"> &amp;&amp; </span>relationship.get<span class="hljs-constructor">CongratulateEnabled()</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>) {<br>        <span class="hljs-comment">// 检查亲友邮箱是否为空</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StrUtil</span>.</span></span>is<span class="hljs-constructor">Blank(<span class="hljs-params">relationship</span>.<span class="hljs-params">getRelationshipEmail</span>()</span>)) {<br>            <span class="hljs-comment">// 如果邮箱为空，记录警告日志并跳过祝贺计划</span><br>            log.warn(<span class="hljs-string">"亲友 {} 启用了祝贺功能但没有设置邮箱，跳过祝贺计划"</span>, relationship.get<span class="hljs-constructor">Name()</span>);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 检查当前日期是否还没过生日</span><br>            <span class="hljs-keyword">if</span> (!now.is<span class="hljs-constructor">After(<span class="hljs-params">birthday</span>)</span>) {<br>                <span class="hljs-comment">// 创建祝贺计划</span><br>                ReminderPlan congratulatePlan = build<span class="hljs-constructor">BasicPlan(<span class="hljs-params">relationship</span>)</span>;<br>                congratulatePlan.set<span class="hljs-constructor">ReminderType(1)</span>;  <span class="hljs-comment">// 设置为发送祝贺类型</span><br>                congratulatePlan.set<span class="hljs-constructor">ReminderDate(<span class="hljs-params">birthday</span>)</span>;  <span class="hljs-comment">// 设置为生日当天</span><br>                congratulatePlan.set<span class="hljs-constructor">DaysBefore(0)</span>;  <span class="hljs-comment">// 当天发送，提前提醒天数为0</span><br>                plans.add(congratulatePlan);  <span class="hljs-comment">// 添加到计划列表</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 如果计划列表不为空，则批量保存到数据库</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CollectionUtil</span>.</span></span>is<span class="hljs-constructor">NotEmpty(<span class="hljs-params">plans</span>)</span>) {<br>        mapper.save<span class="hljs-constructor">Batch(<span class="hljs-params">plans</span>)</span>;  <span class="hljs-comment">// 批量保存所有计划</span><br>        log.info(<span class="hljs-string">"为亲友 {} 创建了 {} 条计划"</span>, relationship.get<span class="hljs-constructor">Name()</span>, plans.size<span class="hljs-literal">()</span>);  <span class="hljs-comment">// 记录日志</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="executePlan方法"><a href="#executePlan方法" class="headerlink" title="executePlan方法"></a>executePlan方法</h2><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 标记方法为重写方法，并使用事务管理</span><br>@Override<br>@Transactional<br>public void execute<span class="hljs-constructor">Plan(LocalDate <span class="hljs-params">now</span>)</span> {<br>    <span class="hljs-comment">// 查询当天所有未执行的提醒计划</span><br>    List&lt;ReminderPlan&gt; plans = mapper.<span class="hljs-built_in">list</span><span class="hljs-constructor">UndoPlans(<span class="hljs-params">now</span>)</span>;<br>    <span class="hljs-comment">// 检查是否有待执行的计划</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CollUtil</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">plans</span>)</span>) {<br>        log.info(<span class="hljs-string">"当前没有执行计划"</span>);  <span class="hljs-comment">// 如果没有计划，记录日志并返回</span><br>        return;<br>    }<br><br>    log.info(<span class="hljs-string">"找到 {} 条待执行的提醒计划"</span>, plans.size<span class="hljs-literal">()</span>);  <span class="hljs-comment">// 记录找到的计划数量</span><br><br>    <span class="hljs-comment">// 遍历每个待执行的计划</span><br>    <span class="hljs-keyword">for</span> (ReminderPlan plan : plans) {<br>        <span class="hljs-keyword">try</span> {<br>            log.info(<span class="hljs-string">"开始执行计划：{}"</span>, plan);  <span class="hljs-comment">// 记录开始执行的计划信息</span><br><br>            <span class="hljs-comment">// 获取计划关联的亲友信息</span><br>            Relationship relationship = relationshipMapper.select<span class="hljs-constructor">ById(<span class="hljs-params">plan</span>.<span class="hljs-params">getRelationshipId</span>()</span>);<br>            <span class="hljs-comment">// 检查亲友信息是否存在</span><br>            <span class="hljs-keyword">if</span> (relationship<span class="hljs-operator"> == </span>null) {<br>                log.warn(<span class="hljs-string">"计划ID {} 关联的亲友信息不存在，跳过"</span>, plan.get<span class="hljs-constructor">Id()</span>);  <span class="hljs-comment">// 如果不存在，记录警告并跳过</span><br>                continue;<br>            }<br><br>            <span class="hljs-comment">// 检查用户邮箱是否存在</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StrUtil</span>.</span></span>is<span class="hljs-constructor">Blank(<span class="hljs-params">relationship</span>.<span class="hljs-params">getMyEmail</span>()</span>)) {<br>                log.warn(<span class="hljs-string">"计划ID {} 关联的亲友 {} 没有邮箱，跳过"</span>, plan.get<span class="hljs-constructor">Id()</span>, relationship.get<span class="hljs-constructor">Name()</span>);  <span class="hljs-comment">// 如果邮箱为空，记录警告并跳过</span><br>                continue;<br>            }<br><br>            <span class="hljs-comment">// 创建提醒记录</span><br>            ReminderRecord record = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReminderRecord()</span>;<br>            record.set<span class="hljs-constructor">RelationshipId(<span class="hljs-params">plan</span>.<span class="hljs-params">getRelationshipId</span>()</span>);  <span class="hljs-comment">// 设置关联的亲友ID</span><br>            record.set<span class="hljs-constructor">ReminderTime(LocalDateTime.<span class="hljs-params">now</span>()</span>);         <span class="hljs-comment">// 设置提醒时间为当前时间</span><br>            record.set<span class="hljs-constructor">ReminderType(<span class="hljs-params">plan</span>.<span class="hljs-params">getReminderType</span>()</span>);      <span class="hljs-comment">// 设置提醒类型</span><br><br>            <span class="hljs-comment">// 根据提醒类型设置不同的接收者邮箱</span><br>            <span class="hljs-keyword">if</span> (plan.get<span class="hljs-constructor">ReminderType()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) {<br>                <span class="hljs-comment">// 0-提醒用户：发送到用户邮箱</span><br>                record.set<span class="hljs-constructor">Receiver(<span class="hljs-params">relationship</span>.<span class="hljs-params">getMyEmail</span>()</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (plan.get<span class="hljs-constructor">ReminderType()</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>) {<br>                <span class="hljs-comment">// 1-发送祝贺：发送到亲友邮箱</span><br>                record.set<span class="hljs-constructor">Receiver(<span class="hljs-params">relationship</span>.<span class="hljs-params">getRelationshipEmail</span>()</span>);<br>            }<br><br>            <span class="hljs-comment">// 保存提醒记录到数据库</span><br>            reminderRecordMapper.insert(record);<br>            log.info(<span class="hljs-string">"已创建提醒记录：亲友 {}, 接收者 {}"</span>, relationship.get<span class="hljs-constructor">Name()</span>, relationship.get<span class="hljs-constructor">MyEmail()</span>);<br><br>            <span class="hljs-comment">// 更新计划状态为已执行</span><br>            plan.set<span class="hljs-constructor">ExecutionStatus(1)</span>;  <span class="hljs-comment">// 设置执行状态为1（已执行）</span><br>            mapper.update(plan);         <span class="hljs-comment">// 更新数据库中的计划状态</span><br>            log.info(<span class="hljs-string">"计划ID {} 执行完成"</span>, plan.get<span class="hljs-constructor">Id()</span>);  <span class="hljs-comment">// 记录计划执行完成信息</span><br><br>        } catch (Exception e) {<br>            <span class="hljs-comment">// 如果执行过程中出现异常，记录错误日志</span><br>            log.error(<span class="hljs-string">"执行计划ID {} 失败: {}"</span>, plan.get<span class="hljs-constructor">Id()</span>, e.get<span class="hljs-constructor">Message()</span>, e);<br>        }<br>    }<br><br>    log.info(<span class="hljs-string">"提醒计划执行完毕，共处理 {} 条计划"</span>, plans.size<span class="hljs-literal">()</span>);  <span class="hljs-comment">// 记录执行完成信息</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>剩下几个比较基础的增删改查就不赘述了。</strong></p><h2 id="Task层"><a href="#Task层" class="headerlink" title="Task层"></a>Task层</h2><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">BirthdayReminderJob</span> {<br><br>    <span class="hljs-variable">@Autowired</span><br>    private RelationPlanService planService;<br><br>    <span class="hljs-variable">@Scheduled</span>(cron = <span class="hljs-string">"0 0 9,12,20 * * ?"</span>)<span class="hljs-comment">//cron表达式，代表执行频率</span><br><br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">reminder</span>() {<br>        <span class="hljs-comment">// 扫描当天未执行的计划</span><br>        <span class="hljs-selector-tag">planService</span><span class="hljs-selector-class">.executePlan</span>(LocalDate.<span class="hljs-built_in">now</span>());<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>cron表达式使用如下：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">┌───────────── 秒（0<span class="hljs-string">-59</span>）<br>│ ┌─────────── 分钟（0<span class="hljs-string">-59</span>）<br>│ │ ┌───────── 小时（0<span class="hljs-string">-23</span>）<br>│ │ │ ┌─────── 日（1<span class="hljs-string">-31</span>）<br>│ │ │ │ ┌───── 月（1<span class="hljs-string">-12</span> 或 JAN-DEC）<br>│ │ │ │ │ ┌─── 周几（0<span class="hljs-string">-7</span> 或 SUN-SAT，0和7均代表周日）<br>│ │ │ │ │ │<br>* * * * * ? *（可选年字段，1970<span class="hljs-string">-2099</span>）<br></code></pre></td></tr></tbody></table></figure><h2 id="VO层"><a href="#VO层" class="headerlink" title="VO层"></a>VO层</h2><p><strong>和前端连起来需要格式化输出和一个响应体类，VO层就是解决这个问题。</strong></p><p><strong>PageVO和RelationshipVO几乎是Domain层的复刻，但是我想说的是ResponseEntity。</strong></p><p><strong>后端需要响应到前端，就需要一个响应体，体内应该有状态码等信息，还需要封装基本的方法。</strong></p><p><strong>使用泛型T是因为响应体通用，处理的对象类型不应受限制。</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否成功</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> success;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提示信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> message;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> code;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 具体的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> T data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; <span class="hljs-title function_">success</span>(<span class="hljs-params">T data</span>){  <span class="hljs-comment">//下面几个都是状态函数，用于检查运行状态和标注状态码等信息</span><br>        <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; response=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt;();<br>        response.<span class="hljs-property">success</span>=<span class="hljs-literal">true</span>;<br>        response.<span class="hljs-property">data</span>=data;<br>        response.<span class="hljs-property">code</span>=<span class="hljs-string">"200"</span>; <span class="hljs-comment">//200表示成功</span><br>        <span class="hljs-keyword">return</span> response;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; <span class="hljs-title function_">success</span>(<span class="hljs-params"></span>){<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(<span class="hljs-literal">null</span>);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; <span class="hljs-title function_">fail</span>(<span class="hljs-params">T data,<span class="hljs-built_in">String</span> message</span>){<br>        <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; response=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt;();<br>        response.<span class="hljs-property">success</span>=<span class="hljs-literal">false</span>;<br>        response.<span class="hljs-property">data</span>=data;<br>        response.<span class="hljs-property">code</span>=<span class="hljs-string">"500"</span>;  <span class="hljs-comment">//500表示错误</span><br>        response.<span class="hljs-property">message</span>=message;<br>        <span class="hljs-keyword">return</span> response;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; <span class="hljs-title function_">fail</span>(<span class="hljs-params"></span>){<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(<span class="hljs-literal">null</span>);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-title class_">ResponseEntity</span>&lt;T&gt; <span class="hljs-title function_">fail</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>){<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(<span class="hljs-literal">null</span>,message);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2><h3 id="Relationship控制器"><a href="#Relationship控制器" class="headerlink" title="Relationship控制器"></a>Relationship控制器</h3><blockquote><p><strong>该控制器和其他层耦合严重，请配合源码阅读。</strong></p></blockquote><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 标记为REST控制器，处理HTTP请求</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-comment">// 设置基础请求路径</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/api/relationship"</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RelationshipController</span> {<br>    <span class="hljs-comment">// 注入关系计划服务</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RelationPlanService relationPlanService;<br><br>    <span class="hljs-comment">// 注入亲友服务</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RelationshipService relationshipService;<br><br>    <span class="hljs-comment">// GET请求处理分页查询</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">"/page"</span>)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;PageVO&lt;RelationshipPageVO&gt;&gt; page(RelationshipPageDTO dto){<br>        <span class="hljs-comment">// 验证并设置默认页码</span><br>        <span class="hljs-keyword">if</span> (dto.getPage() == <span class="hljs-literal">null</span> || dto.getPage() &lt;= <span class="hljs-number">0</span>) {<br>            dto.setPage(<span class="hljs-number">1</span>);<br>        }<br>        <span class="hljs-comment">// 验证并设置默认页面大小</span><br>        <span class="hljs-keyword">if</span> (dto.getSize() == <span class="hljs-literal">null</span> || dto.getSize() &lt;= <span class="hljs-number">0</span>) {<br>            dto.setSize(<span class="hljs-number">10</span>);<br>        }<br><br>        <span class="hljs-comment">// 调用服务层获取分页数据</span><br>        PageInfo&lt;RelationshipPageVO&gt; pageInfo = relationshipService.queryRelationshipPage(dto);<br>        <span class="hljs-comment">// 构建分页响应对象</span><br>        PageVO&lt;RelationshipPageVO&gt; pageVO = new PageVO&lt;&gt;(<br>                pageInfo.getList(),        <span class="hljs-comment">// 数据列表</span><br>                pageInfo.getPages(),       <span class="hljs-comment">// 总页数</span><br>                pageInfo.getPageNum(),     <span class="hljs-comment">// 当前页码</span><br>                pageInfo.getPageSize(),    <span class="hljs-comment">// 每页大小</span><br>                pageInfo.getTotal()        <span class="hljs-comment">// 总记录数</span><br>        );<br>        <span class="hljs-comment">// 返回成功响应</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.success(pageVO);<br>    }<br><br>    <span class="hljs-comment">// GET请求根据ID获取单个亲友信息</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">"/{id}"</span>)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;Relationship&gt; <span class="hljs-keyword">get</span>(<span class="hljs-meta">@PathVariable</span> Integer id) {<br>        <span class="hljs-keyword">return</span> ResponseEntity.success(relationshipService.getRelationship(id));<br>    }<br><br>    <span class="hljs-comment">// POST请求创建新的亲友关系</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-meta">@Transactional</span>  <span class="hljs-comment">// 启用事务管理</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;Integer&gt; create(<span class="hljs-meta">@RequestBody</span> Relationship relationship) {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 创建亲友关系</span><br>            Relationship relation = relationshipService.createRelationship(relationship);<br>            <span class="hljs-comment">// 为新创建的亲友生成提醒计划</span><br>            relationPlanService.plan(relation);<br>            <span class="hljs-comment">// 返回新创建的亲友ID</span><br>            <span class="hljs-keyword">return</span> ResponseEntity.success(relation.getId());<br>        } <span class="hljs-keyword">catch</span> (Exception e) {<br>            e.printStackTrace();<br>            <span class="hljs-comment">// 返回失败响应</span><br>            <span class="hljs-keyword">return</span> ResponseEntity.fail(<span class="hljs-string">"创建亲友关系失败: "</span> + e.getMessage());<br>        }<br>    }<br><br>    <span class="hljs-comment">// PUT请求更新亲友信息</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-meta">@Transactional</span>  <span class="hljs-comment">// 启用事务管理</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-built_in">Boolean</span>&gt; update(<span class="hljs-meta">@RequestBody</span> Relationship relationship) {<br>        <span class="hljs-comment">// 更新亲友信息</span><br>        <span class="hljs-built_in">Boolean</span> b = relationshipService.updateRelationship(relationship);<br>        <span class="hljs-comment">// 重新生成提醒计划</span><br>        relationPlanService.plan(relationship);<br>        <span class="hljs-keyword">return</span> ResponseEntity.success(b);<br>    }<br><br>    <span class="hljs-comment">// DELETE请求删除亲友信息</span><br>    <span class="hljs-meta">@DeleteMapping(<span class="hljs-string">"/{id}"</span>)</span><br>    <span class="hljs-meta">@Transactional</span>  <span class="hljs-comment">// 启用事务管理</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-built_in">Boolean</span>&gt; delete(<span class="hljs-meta">@PathVariable</span> Integer id) {<br>        <span class="hljs-comment">// 删除亲友信息</span><br>        <span class="hljs-built_in">Boolean</span> b = relationshipService.deleteRelationship(id);<br>        <span class="hljs-comment">// 删除关联的提醒计划</span><br>        relationPlanService.deleteByRelationshipId(id);<br>        <span class="hljs-keyword">return</span> ResponseEntity.success(b);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="RelationshipReminder控制器"><a href="#RelationshipReminder控制器" class="headerlink" title="RelationshipReminder控制器"></a>RelationshipReminder控制器</h3><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">ResponseEntity</span>&lt;<span class="hljs-type">PageVO</span>&lt;<span class="hljs-type">ReminderPlan</span>&gt;&gt; getList(<br>            <span class="hljs-meta">@RequestParam</span>(defaultValue <span class="hljs-operator">=</span> <span class="hljs-string">"0"</span>) <span class="hljs-type">Integer</span> page,<br>            <span class="hljs-meta">@RequestParam</span>(defaultValue <span class="hljs-operator">=</span> <span class="hljs-string">"10"</span>) <span class="hljs-type">Integer</span> size,<br>            <span class="hljs-meta">@RequestParam</span>(<span class="hljs-keyword">required</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>) <span class="hljs-type">Integer</span> relationshipId) {<br>        <span class="hljs-type">PageInfo</span>&lt;<span class="hljs-type">ReminderPlan</span>&gt; pageInfo <span class="hljs-operator">=</span> relationPlanService.getPageList(page <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, size, relationshipId);<br>        <span class="hljs-type">PageVO</span>&lt;<span class="hljs-type">ReminderPlan</span>&gt; pageVO <span class="hljs-operator">=</span> new <span class="hljs-type">PageVO</span>&lt;&gt;(<br>                pageInfo.getList(),<br>                pageInfo.getPages(),<br>                pageInfo.getPageNum(),<br>                pageInfo.getPageSize(),<br>                pageInfo.getTotal()<br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ResponseEntity</span>.success(pageVO);<br>    }    <span class="hljs-comment">//依旧PageHelper插件传参，如果没问题就返回一个响应体，响应体中带200状态码和内容</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据ID获取提醒计划</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/{id}"</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">ResponseEntity</span>&lt;<span class="hljs-type">ReminderPlan</span>&gt; getById(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">Integer</span> id) {<br>        <span class="hljs-type">ReminderPlan</span> plan <span class="hljs-operator">=</span> relationPlanService.getById(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ResponseEntity</span>.success(plan);<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建提醒计划</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">ResponseEntity</span>&lt;<span class="hljs-type">ReminderPlan</span>&gt; create(<span class="hljs-meta">@RequestBody</span> <span class="hljs-type">ReminderPlan</span> reminderPlan) {<br>        <span class="hljs-keyword">try</span> {<br>            relationPlanService.create(reminderPlan);<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">ResponseEntity</span>.success(reminderPlan);<br>        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) {<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">ResponseEntity</span>.fail(<span class="hljs-string">"创建提醒计划失败: "</span> <span class="hljs-operator">+</span> e.getMessage());<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新提醒计划</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/{id}"</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">ResponseEntity</span>&lt;<span class="hljs-type">Void</span>&gt; update(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">Integer</span> id, <span class="hljs-meta">@RequestBody</span> <span class="hljs-type">ReminderPlan</span> reminderPlan) {<br>        reminderPlan.setId(id);<br>        relationPlanService.update(reminderPlan);<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ResponseEntity</span>.success();<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除提醒计划</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/{id}"</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">ResponseEntity</span>&lt;<span class="hljs-type">Void</span>&gt; delete(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">Integer</span> id) {<br>        relationPlanService.deleteById(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ResponseEntity</span>.success();<br>    }<br>}<br><span class="hljs-comment">//这几个增删改查的方法在Service层中写有。</span><br></code></pre></td></tr></tbody></table></figure><h2 id="Yaml配置"><a href="#Yaml配置" class="headerlink" title="Yaml配置"></a>Yaml配置</h2><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>  <span class="hljs-comment">##使用8080端口</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Birthday_reminder</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/table_Birthday?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span>  <span class="hljs-comment">##数据库配置</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.qq.com</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">587</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">example@qq.com</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxxxxxxxxxxxx</span>  <span class="hljs-comment"># 授权码，不是密码，怎么开启使用请自行查找</span><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">mail:</span><br>        <span class="hljs-attr">smtp:</span><br>          <span class="hljs-attr">auth:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">starttls:</span><br>            <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">devtools:</span><br>    <span class="hljs-attr">restart:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">additional-paths:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">src/main/java</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">src/main/resources</span><br><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.Birthday_reminder.domain</span><br><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.Birthday_reminder:</span> <span class="hljs-string">DEBUG</span><br>    <span class="hljs-attr">org.springframework.jdbc:</span> <span class="hljs-string">DEBUG</span><br>    <span class="hljs-attr">org.springframework.boot.autoconfigure.jdbc:</span> <span class="hljs-string">DEBUG</span><br></code></pre></td></tr></tbody></table></figure><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>见<a href="https://github.com/Dr-WillMos/Birthday_reminder">Github仓库</a>，如果有问题可以通过邮箱与我交流。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>JAVA</tag>
      
      <tag>项目</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC中的请求方法</title>
    <link href="/posts/SpringMVC_request/"/>
    <url>/posts/SpringMVC_request/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC中的请求方法"><a href="#SpringMVC中的请求方法" class="headerlink" title="SpringMVC中的请求方法"></a>SpringMVC中的请求方法</h1><p><strong>在HTTP协议中，请求方法（也被称为HTTP方法或HTTP动词）定义了请求所执行的操作类型。在Spring MVC中，你可以使用这些HTTP请求方法来定义你的控制器（Controller）中的方法，以便它们可以根据不同的HTTP请求方法执行不同的操作。</strong></p><h3 id="GET（重要）："><a href="#GET（重要）：" class="headerlink" title="GET（重要）："></a>GET（重要）：</h3><ul><li><strong>用于请求指定的资源。请求中通常不包含请求体。</strong></li><li><strong>例子：从服务器获取一个网页或API数据。</strong></li><li><strong>工作中一般用做查询请求。</strong></li></ul><h3 id="POST（重要）："><a href="#POST（重要）：" class="headerlink" title="POST（重要）："></a>POST（重要）：</h3><ul><li><strong>用于提交数据到指定的资源，请求数据包含在请求体中。</strong></li><li><strong>通常用于提交表单数据或上传文件。POST请求可能会导致新的资源的创建或现有资源的修改。</strong></li><li><strong>工作中一般用于新增请求。</strong></li></ul><h3 id="PUT（重要）："><a href="#PUT（重要）：" class="headerlink" title="PUT（重要）："></a>PUT（重要）：</h3><ul><li><strong>用于替换目标资源的所有当前表示形式。如果资源不存在，则可能创建新资源。</strong></li><li><strong>请求数据包含在请求体中，并且URL标识要替换的资源。</strong></li><li><strong>工作中一般用于更新请求。</strong></li></ul><h3 id="PATCH（一般）："><a href="#PATCH（一般）：" class="headerlink" title="PATCH（一般）："></a>PATCH（一般）：</h3><ul><li><strong>用于对资源进行部分修改。与PUT不同，PATCH只更新资源的部分属性。</strong></li><li><strong>请求数据包含在请求体中，并描述要更改的属性。</strong></li></ul><h3 id="DELETE（重要）："><a href="#DELETE（重要）：" class="headerlink" title="DELETE（重要）："></a>DELETE（重要）：</h3><ul><li><strong>用于请求服务器删除指定的资源。</strong></li><li><strong>例子：从服务器删除一个文件或数据库记录。</strong></li><li><strong>工作中一般用于删除请求。</strong></li></ul><h3 id="HEAD："><a href="#HEAD：" class="headerlink" title="HEAD："></a>HEAD：</h3><ul><li><strong>类似于GET请求，但服务器在响应中只返回响应头，而不返回响应体。</strong></li><li><strong>通常用于检查资源的可用性或元数据，如资源的修改日期。</strong></li></ul><h3 id="OPTIONS："><a href="#OPTIONS：" class="headerlink" title="OPTIONS："></a>OPTIONS：</h3><ul><li><strong>用于获取目标资源所支持的通信选项。</strong></li><li><strong>这通常用于CORS（跨源资源共享）预检请求，以检查服务器是否允许来自特定源的请求。</strong></li></ul><h3 id="TRACE："><a href="#TRACE：" class="headerlink" title="TRACE："></a>TRACE：</h3><ul><li><strong>用于回显服务器收到的请求，以便客户端可以看到请求链中的任何更改或添加。</strong></li><li><strong>通常用于诊断目的，但在实际生产环境中很少使用。</strong></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p><strong>这是一个通用的注解，用于映射HTTP请求到处理方法上。它可以处理任意HTTP方法。通常与method属性一起使用来指定请求方法，如@RequestMapping(method = RequestMethod.GET)。如果不指定method，则默认处理所有HTTP方法。</strong></p><h4 id="该注解中的属性："><a href="#该注解中的属性：" class="headerlink" title="该注解中的属性："></a>该注解中的属性：</h4><p><strong>name：为映射指定一个名称。</strong></p><p><strong>value 和 path：指定请求的URL路径，支持Ant风格的路径模式和占位符。</strong></p><p><strong>method：指定请求的HTTP方法，如GET、POST等。</strong></p><p><strong>params：指定请求的参数，用于进一步限制映射。</strong></p><p><strong>headers：指定请求的头信息，用于进一步限制映射。</strong></p><p><strong>与params类似，不过headers参数针对的是请求头中的信息。</strong></p><p><strong>consumes：指定处理方法可以消费的媒体类型，用于内容协商。</strong></p><p><strong>例如</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/search"</span>, params = {<span class="hljs-string">"query"</span>, <span class="hljs-string">"!filter"</span>}, method = <span class="hljs-title class_">RequestMethod</span>.<span class="hljs-property">GET</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">searchWithQueryOnly</span>(<span class="hljs-params"></span>) {<br> &nbsp; &nbsp;<span class="hljs-comment">// 只有当请求中包含query参数且不包含filter参数时，此方法被调用，且路径在/search</span><br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-string">"searchResults"</span>;<br>}<br><br><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/search"</span>, params = <span class="hljs-string">"filter"</span>, method = <span class="hljs-title class_">RequestMethod</span>.<span class="hljs-property">GET</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">searchWithFilter</span>(<span class="hljs-params"></span>) {<br> &nbsp; &nbsp;<span class="hljs-comment">// 当请求中包含filter参数时，此方法被调用</span><br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-string">"filteredSearchResults"</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>@GetMapping是@RequestMapping+method = RequestMethod.GET的特化。</strong></p><p><strong>类似地，还有@PostMapping，@PutMapping，@DeleteMapping和@PatchMapping等</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>JAVA</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC入门和控制器</title>
    <link href="/posts/SpringMVC_start/"/>
    <url>/posts/SpringMVC_start/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC入门和控制器"><a href="#SpringMVC入门和控制器" class="headerlink" title="SpringMVC入门和控制器"></a>SpringMVC入门和控制器</h1><p><strong>了解SpringMVC之前需要了解三层架构，三层架构是一种经典的软件设计模式，通过将应用进行分层，来实现应用内部的解耦，提升可扩展性和可维护性。定位：****系统级分层（垂直拆分）。</strong></p><ul><li><strong>表现层：处理用户交互、接收参数、展示数据</strong></li><li><strong>业务层：处理业务逻辑，（例如用户注册就是一个业务）判断用户是否注册，如果已经注册，则给出异常提示等。</strong></li><li><strong>持久层（又名数据访问层）：与数据源交互，例如我们之前学的mybatis就是持久层的框架。</strong></li></ul><p><img src="https://s2.loli.net/2026/01/01/S32ExRGsK9U8jth.png"></p><p><strong>这样的三层架构被称为MVC架构，分开来就是三个单词的首字母：Model,View,Controller一种软件设计模式，其核心在于通过数据、界面、控制分离，让代码更清晰。</strong></p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.25.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><strong>请根据自己的java版本选择适配的依赖版本。</strong></p></blockquote><p><strong>将项目的打包方式设定为war包</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>引入Tomcat</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">uriEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">uriEncoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>用类配置</strong></p><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.example.mvc"</span>)<br><span class="hljs-variable">@EnableWebMvc</span><br>public class SpringMvcConfig implements WebMvcConfigurer {<br><br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">addResourceHandlers</span>(ResourceHandlerRegistry registry) {<br>        <span class="hljs-comment">// 针对前后端不分离的项目，可配置静态资源放行</span><br>        <span class="hljs-selector-tag">registry</span><br>                <span class="hljs-comment">// 表示所有以/static/开头的请求都会被这个处理器处理</span><br>                <span class="hljs-selector-class">.addResourceHandler</span>(<span class="hljs-string">"/static/**"</span>)<br>                <span class="hljs-comment">// classpath:/static/表示这些资源位于类路径下的static目录中</span><br>                <span class="hljs-selector-class">.addResourceLocations</span>(<span class="hljs-string">"classpath:/static/"</span>)<br>                <span class="hljs-comment">// 缓存一年</span><br>                <span class="hljs-selector-class">.setCacheControl</span>(CacheControl.<span class="hljs-built_in">maxAge</span>(Duration.<span class="hljs-built_in">ofDays</span>(<span class="hljs-number">365</span>)));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>配置servlet</strong></p><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.springframework.web.servlet.support.<span class="hljs-type">AbstractAnnotationConfigDispatcherServletInitializer</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>{<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getRootConfigClasses() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getServletConfigClasses() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[]{<span class="hljs-type">SpringMvcConfig</span>.<span class="hljs-keyword">class</span>};<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span>[] getServletMappings() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[]{<span class="hljs-string">"/"</span>};<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>写一个测试Controller</strong></p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ResponseBody;<br><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/mvc"</span>)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcController</span> {<br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/test"</span>)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String test() {<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;<br>    }<br><br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/index"</span>)</span><br>    <span class="hljs-keyword">public</span> String index() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"/static/index.html"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>测试路径是/mvc/test和/mvc/index</strong></p><p><strong>写一个静态界面</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试用例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个测试界面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>测试完毕<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>访问</strong><a href="http://localhost:8080/mvc/test">http://localhost:8080/mvc/test</a>和<a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a>来展示效果</p><h2 id="关于控制器注释"><a href="#关于控制器注释" class="headerlink" title="关于控制器注释"></a>关于控制器注释</h2><p>Controller即控制器，<strong>是处理客户端请求、执行业务逻辑并返回响应的核心组件，是MVC中的C</strong></p><table><thead><tr><th><strong>职责</strong></th><th><strong>具体说明</strong></th></tr></thead><tbody><tr><td><strong>请求接收</strong></td><td><strong>接收HTTP请求（GET、POST、PUT、DELETE等）</strong></td></tr><tr><td><strong>参数绑定</strong></td><td><strong>从请求中提取参数（URL参数、表单数据、JSON、文件等）</strong></td></tr><tr><td><strong>业务处理</strong></td><td><strong>调用Service层处理业务逻辑</strong></td></tr><tr><td><strong>响应构建</strong></td><td><strong>返回视图名称、JSON数据、重定向等响应</strong></td></tr><tr><td><strong>异常处理</strong></td><td><strong>处理请求过程中的异常情况</strong></td></tr></tbody></table><p><strong>我们写的每一个控制器都要用@Controller注释标记，才能被Spring容器所管理，然而能够起到相同作用的注释有四个，约定俗成上有不同的适用场景。</strong></p><ul><li><strong>Controller注解：通常用在控制器上。（非常常用）</strong></li><li><strong>Service注解：通常用在我们的业务实现类上（非常常用）</strong></li><li><strong>Repository注解：通常用在持久层上，跟数据库交互的类上（取决于你使用的持久层框架）</strong></li><li><strong>Indexed注解：通常用在类或方法上（相对较少使用）</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>JAVA</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring中的事务</title>
    <link href="/posts/Spring_Transactional/"/>
    <url>/posts/Spring_Transactional/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring中的事务"><a href="#Spring中的事务" class="headerlink" title="Spring中的事务"></a>Spring中的事务</h1><p>请类比MySQL中的事务，因为数据库操作不是原子性的，所以可能存在一些问题。例如我们代码的执行过程中，需要在表A中新增一条数据，在表B中也新增一条有关的数据。如果因为线路不稳定，表A新增成功了，表B新增失败了。最终结果自然是失败。但是数据库中会多出一条脏数据。因为表A已经新增成功了。所以我们就需要使用事务这一功能将操作强制原子化。</p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>Spring-JDBC是Spring框架中对JDBC的增强工具类，通过Maven引入</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.39<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>使用类来进行配置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> {<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>很简单，在有关数据库操作的函数前加上<code>@Transactional</code>注释就能够声明为事务管理操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {<br>        <span class="hljs-comment">// 数据库操作1</span><br>        orderDao.insert(order);<br>        <span class="hljs-comment">// 数据库操作2</span><br>        inventoryDao.deduct(order.getItemId());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>使用该注释的参数模板是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(</span><br><span class="hljs-meta">    isolation = Isolation.READ_COMMITTED, // 隔离级别</span><br><span class="hljs-meta">    propagation = Propagation.REQUIRED,   // 传播行为</span><br><span class="hljs-meta">    timeout = 30,                        // 超时秒数</span><br><span class="hljs-meta">    rollbackFor = Exception.class        // 回滚异常</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></tbody></table></figure><p>事务隔离级别定义了多个事务并发执行时，彼此之间的可见性和影响程度。Spring支持标准SQL定义的4种隔离级别，用于解决并发事务可能引发的数据一致性问题。</p><h4 id="1-读未提交（READ-UNCOMMITTED）"><a href="#1-读未提交（READ-UNCOMMITTED）" class="headerlink" title="1. 读未提交（READ_UNCOMMITTED）"></a>1. <strong>读未提交（READ_UNCOMMITTED）</strong></h4><ul><li><strong>问题</strong>：允许读取其他事务未提交的修改。</li><li><strong>风险</strong>：脏读（Dirty Read）、不可重复读（Non-Repeatable Read）、幻读（Phantom Read）。</li><li><strong>适用场景</strong>：对一致性要求极低，追求高并发性能。</li></ul><h4 id="2-读已提交（READ-COMMITTED）"><a href="#2-读已提交（READ-COMMITTED）" class="headerlink" title="2. 读已提交（READ_COMMITTED）"></a>2. <strong>读已提交（READ_COMMITTED）</strong></h4><ul><li><strong>默认值</strong>：多数数据库（如Oracle）的默认隔离级别。</li><li><strong>解决</strong>：避免脏读，但允许不可重复读和幻读。</li><li><strong>适用场景</strong>：允许事务间看到已提交的数据变化（如统计报表）。</li></ul><h4 id="3-可重复读（REPEATABLE-READ）"><a href="#3-可重复读（REPEATABLE-READ）" class="headerlink" title="3. 可重复读（REPEATABLE_READ）"></a>3. <strong>可重复读（REPEATABLE_READ）</strong></h4><ul><li><strong>默认值</strong>：MySQL的默认隔离级别。</li><li><strong>解决</strong>：避免脏读和不可重复读，但允许幻读。</li><li><strong>机制</strong>：事务内多次读取同一数据的结果一致，但新增数据可能被其他事务插入（幻读）。</li></ul><h4 id="4-串行化（SERIALIZABLE）"><a href="#4-串行化（SERIALIZABLE）" class="headerlink" title="4. 串行化（SERIALIZABLE）"></a>4. <strong>串行化（SERIALIZABLE）</strong></h4><ul><li><strong>解决</strong>：强制事务串行执行，避免所有并发问题（脏读、不可重复读、幻读）。</li><li><strong>代价</strong>：性能最低，仅适用于严格要求一致性且并发量小的场景。</li></ul><h3 id="传播行为："><a href="#传播行为：" class="headerlink" title="传播行为："></a>传播行为：</h3><p>传播行为定义了事务方法在调用其他事务方法时，事务如何传播。Spring提供了7种传播行为，以下是常见类型：</p><h4 id="1-REQUIRED（默认）"><a href="#1-REQUIRED（默认）" class="headerlink" title="1. REQUIRED（默认）"></a>1. <strong>REQUIRED（默认）</strong></h4><ul><li><strong>规则</strong>：如果当前存在事务，则加入该事务；否则新建一个事务。</li><li><strong>场景</strong>：大多数业务方法（如订单和库存操作需在同一个事务中）。</li></ul><h4 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <strong>REQUIRES_NEW</strong></h4><ul><li><strong>规则</strong>：无论当前是否存在事务，都新建一个事务，并挂起当前事务（如果存在）。</li><li><strong>场景</strong>：日志记录（即使主事务回滚，日志仍需提交）。</li></ul><h4 id="3-NESTED"><a href="#3-NESTED" class="headerlink" title="3. NESTED"></a>3. <strong>NESTED</strong></h4><ul><li><strong>规则</strong>：如果当前存在事务，则在嵌套事务（保存点）中执行；否则新建事务。</li><li><strong>特点</strong>：嵌套事务回滚不影响外层事务，但外层事务回滚会导致嵌套事务回滚。</li><li><strong>场景</strong>：复杂业务的分步操作（如订单创建成功后，部分子操作可独立回滚）。</li></ul><h4 id="4-SUPPORTS"><a href="#4-SUPPORTS" class="headerlink" title="4. SUPPORTS"></a>4. <strong>SUPPORTS</strong></h4><ul><li><strong>规则</strong>：如果当前存在事务，则加入；否则以非事务方式运行。</li><li><strong>场景</strong>：查询方法可适应有无事务的环境。</li></ul><h4 id="5-NOT-SUPPORTED"><a href="#5-NOT-SUPPORTED" class="headerlink" title="5. NOT_SUPPORTED"></a>5. <strong>NOT_SUPPORTED</strong></h4><ul><li><strong>规则</strong>：以非事务方式执行，挂起当前事务（如果存在）。</li><li><strong>场景</strong>：某些不需要事务的操作（如发送消息）。</li></ul><h4 id="6-MANDATORY"><a href="#6-MANDATORY" class="headerlink" title="6. MANDATORY"></a>6. <strong>MANDATORY</strong></h4><ul><li><strong>规则</strong>：强制当前必须存在事务，否则抛出异常。</li><li><strong>场景</strong>：确保方法必须在事务上下文中调用。</li></ul><h4 id="7-NEVER"><a href="#7-NEVER" class="headerlink" title="7. NEVER"></a>7. <strong>NEVER</strong></h4><ul><li><strong>规则</strong>：强制当前不能存在事务，否则抛出异常。</li><li><strong>场景</strong>：禁止事务的方法（如性能敏感的只读操作）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>JAVA</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP:面向切面编程</title>
    <link href="/posts/AOP/"/>
    <url>/posts/AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP:面向切面编程"></a>AOP:面向切面编程</h1><p>AOP：首先需要明确一点，AOP不是spring、甚至不是java特有的概念。</p><p>面向切面编程（AOP，Aspect-Oriented Programming）是一种代码组织和复用范式，其核心思想是将传统的<strong>纵向处理</strong>，改为<strong>横向切割</strong>，从而实现<strong>通用业务</strong>和<strong>核心业务</strong>逻辑分离。可以达到代码的复用、解耦。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/21919408/1741918867282-0519af90-f8d6-4957-b64d-bd908efe0a37.jpeg" alt="img"></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.24.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在Springconfig中如下配置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span>  <span class="hljs-comment">//激活AOP</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> {<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>好比我们接下来要设定一个创建新用户——权限检验——成功创建的逻辑</p><p>新建用户类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring;<br><br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span>   <span class="hljs-comment">//让Spring扫描到</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Userdemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_user</span> <span class="hljs-params">()</span><br>    {<br>        System.out.println(<span class="hljs-string">"添加用户"</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get_user</span> <span class="hljs-params">()</span><br>    {<br>        System.out.println(<span class="hljs-string">"已获取用户："</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Authaspect</span> {<br>    <span class="hljs-comment">// 切入点</span><br>    <span class="hljs-meta">@Pointcut("bean(userdemo)")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointCut</span><span class="hljs-params">()</span> {<br>    }<br><br><br>    <span class="hljs-comment">// 切入后你要进行什么操作</span><br>    <span class="hljs-meta">@Before("pointCut()")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doLog</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"正在进行权限校验"</span>);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>AOP就是锚定指定类的受Spring管理下的对象，拦截他们的方法并在执行之前执行开发者想要执行的逻辑。</p><p>执行，在<code>SpringDemo</code>中执行</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    {<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-type">Userdemo</span> <span class="hljs-variable">nmsl</span> <span class="hljs-operator">=</span> context.getBean(Userdemo.class);<br>        nmsl.add_user();<br>        System.out.println(<span class="hljs-string">"------------------"</span>);  <span class="hljs-comment">//两个操作的分界线</span><br>        nmsl.get_user();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我来更正一下说法，我们基于AOP，对源对象方法的拦截插入等操作一般叫做“增强”，因为拦截插入使得整个程序有了统一的出口和入口，整体上性能有所提升。并且，在方法之前插入或者之后插入被称为“通知”。</p><h3 id="几种通知类型："><a href="#几种通知类型：" class="headerlink" title="几种通知类型："></a>几种通知类型：</h3><p>执行前通知：Before</p><p>执行后通知：After</p><p>正常返回结果后通知： AfterReturning</p><p>抛出异常后通知：AfterThrowing</p><p>环绕通知：Around</p><p>使用通式就是这么写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Authaspect</span> {<br>    <span class="hljs-comment">// 你要对谁进行切面处理？</span><br>    <span class="hljs-meta">@Pointcut("bean(userdemo)")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointCut</span><span class="hljs-params">()</span> {<br>    }<br><br><br>    <span class="hljs-comment">// 你要进行什么增强</span><br>    <span class="hljs-meta">@Before("pointCut()")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doLog</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"正在进行权限校验————————权限校验通过"</span>);<br>    }<br><br>    <span class="hljs-meta">@After("pointCut()")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfter</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"doAfter"</span>);<br>    }<br><br>    <span class="hljs-meta">@AfterReturning("pointCut()")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterReturning</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"doAfterReturning"</span>);<br>    }<br><br>    <span class="hljs-meta">@AfterThrowing("pointCut()")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterThrowing</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"doAfterThrowing"</span>);<br>    }<br><br>    <span class="hljs-meta">@Around("pointCut()")</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        System.out.println(<span class="hljs-string">"doAround before"</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br>        System.out.println(<span class="hljs-string">"doAround after"</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>有时候，为每个类单独锚定切入点是很困难的，所以我们会使用别的查找方法来批量切入。</p><h3 id="一、execution：方法执行（最常用）"><a href="#一、execution：方法执行（最常用）" class="headerlink" title="一、execution：方法执行（最常用）"></a>一、execution：方法执行（最常用）</h3><p>AOP 中的 <code>execution</code>方法是定义<strong>切入点（Pointcut）</strong>的核心方式，它通过编写表达式来<strong>精确匹配哪些方法需要被增强</strong>。你可以把它想象成一个功能强大的“瞄准镜”，负责在众多方法中锁定那些需要被注入通用功能（如日志、事务等）的目标。</p><h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<br>    [修饰符] 返回类型 [包路径.类名.方法名](参数列表) [<span class="hljs-keyword">throws</span> 异常]<br>)<br></code></pre></td></tr></tbody></table></figure><h4 id="通配符说明"><a href="#通配符说明" class="headerlink" title="通配符说明"></a>通配符说明</h4><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意单个元素</td><td><code>java.*.Service</code></td></tr><tr><td><code>..</code></td><td>匹配多个元素（包/参数）</td><td><code>com.example..*</code></td></tr></tbody></table><h4 id="典型示例"><a href="#典型示例" class="headerlink" title="典型示例"></a>典型示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配Service包下所有类的public方法</span><br><span class="hljs-meta">@Pointcut("execution(public * com.example.service.*.*(..))")</span><br><br><span class="hljs-comment">// 匹配UserService中所有get开头的方法</span><br><span class="hljs-meta">@Pointcut("execution(* com.example.service.UserService.get*(..))")</span><br><br><span class="hljs-comment">// 匹配所有返回String的无参方法</span><br><span class="hljs-meta">@Pointcut("execution(String *())")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="二、within：类-x2F-包范围限定"><a href="#二、within：类-x2F-包范围限定" class="headerlink" title="二、within：类/包范围限定"></a>二、within：类/包范围限定</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>快速匹配整个类或包下的所有方法</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配service包下所有类</span><br><span class="hljs-meta">@Pointcut("within(com.example.service.*)")</span><br><br><span class="hljs-comment">// 匹配service包及其子包</span><br><span class="hljs-meta">@Pointcut("within(com.example.service..*)")</span><br><br><span class="hljs-comment">// 匹配具体实现类（对接口无效）</span><br><span class="hljs-meta">@Pointcut("within(com.example.service.UserServiceImpl)")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="三、this：代理对象类型匹配"><a href="#三、this：代理对象类型匹配" class="headerlink" title="三、this：代理对象类型匹配"></a>三、this：代理对象类型匹配</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>基于JDK动态代理时匹配接口类型</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配代理对象实现UserService接口的方法</span><br><span class="hljs-meta">@Pointcut("this(com.example.service.UserService)")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="四、target：目标对象类型匹配"><a href="#四、target：目标对象类型匹配" class="headerlink" title="四、target：目标对象类型匹配"></a>四、target：目标对象类型匹配</h3><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>基于CGLIB代理时匹配实现类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配目标对象是UserServiceImpl类的方法</span><br><span class="hljs-meta">@Pointcut("target(com.example.service.UserServiceImpl)")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="五、args：参数类型匹配"><a href="#五、args：参数类型匹配" class="headerlink" title="五、args：参数类型匹配"></a>五、args：参数类型匹配</h3><h4 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配第一个参数为Long类型的方法</span><br><span class="hljs-meta">@Pointcut("args(Long, ..)")</span><br><br><span class="hljs-comment">// 配合通知获取参数值</span><br><span class="hljs-meta">@Before("args(userId, ..) &amp;&amp; target(service)")</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(Long userId, UserService service)</span> {<br>    System.out.println(<span class="hljs-string">"操作用户ID："</span> + userId);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="六、-annotation：方法注解匹配"><a href="#六、-annotation：方法注解匹配" class="headerlink" title="六、@annotation：方法注解匹配"></a>六、@annotation：方法注解匹配</h3><h4 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AuditLog {}<br><br><span class="hljs-comment">// 切入带注解的方法</span><br><span class="hljs-meta">@Pointcut("@annotation(com.example.AuditLog)")</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">auditPointcut</span><span class="hljs-params">()</span> {}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-meta">@AuditLog</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sensitiveOperation</span><span class="hljs-params">()</span> { <span class="hljs-comment">/*...*/</span> }<br></code></pre></td></tr></tbody></table></figure><h3 id="七、-within：类注解匹配"><a href="#七、-within：类注解匹配" class="headerlink" title="七、@within：类注解匹配"></a>七、@within：类注解匹配</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>匹配带有指定注解的类中的所有方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义类注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecureApi {}<br><br><span class="hljs-comment">// 切入点配置</span><br><span class="hljs-meta">@Pointcut("@within(com.example.SecureApi)")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="八、bean：Spring-Bean名称匹配"><a href="#八、bean：Spring-Bean名称匹配" class="headerlink" title="八、bean：Spring Bean名称匹配"></a>八、bean：Spring Bean名称匹配</h3><h4 id="Spring特有语法"><a href="#Spring特有语法" class="headerlink" title="Spring特有语法"></a>Spring特有语法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配ID为userService的Bean</span><br><span class="hljs-meta">@Pointcut("bean(userService)")</span><br><br><span class="hljs-comment">// 匹配名称以Service结尾的Bean</span><br><span class="hljs-meta">@Pointcut("bean(*Service)")</span><br><br><span class="hljs-comment">// 排除指定Bean</span><br><span class="hljs-meta">@Pointcut("bean(userService) &amp;&amp; !bean(adminService)")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="组合表达式技巧"><a href="#组合表达式技巧" class="headerlink" title="组合表达式技巧"></a>组合表达式技巧</h3><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td><td><code>execution(* save*(..)) &amp;&amp; within(com.example.service)</code></td></tr><tr><td>||</td><td>逻辑或</td><td>`@annotation(AuditLog)</td></tr><tr><td>!</td><td>逻辑非</td><td><code>execution(* *(..)) &amp;&amp; !bean(testService)</code></td></tr></tbody></table><h4 id="复杂组合示例"><a href="#复杂组合示例" class="headerlink" title="复杂组合示例"></a>复杂组合示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配service包下非测试环境的方法调用</span><br><span class="hljs-meta">@Pointcut("execution(* com.example.service.*.*(..)) " +</span><br><span class="hljs-meta">          "&amp;&amp; !@annotation(DevOnly) " +</span><br><span class="hljs-meta">          "&amp;&amp; !within(com.example.service.test.*)")</span><br></code></pre></td></tr></tbody></table></figure><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><ol><li><strong>缩小匹配范围</strong>：优先使用<code>within</code>缩小包范围</li><li><strong>避免过度通配</strong>：<code>*Service</code>比<code>*.*</code>效率高10倍以上</li><li><strong>缓存切入点</strong>：使用<code>@Pointcut</code>定义可复用的切入点</li></ol><h2 id="AOP中的一些术语"><a href="#AOP中的一些术语" class="headerlink" title="AOP中的一些术语"></a>AOP中的一些术语</h2><p>只是帮助理解</p><ul><li><strong>切面：</strong>一系列切点+通知的集合，一个关注点的模块化。（例如日志切面主要负责处理日志，认证切面主要负责处理认证相关）</li><li><strong>连接点</strong>：程序执行过程中的一个点，例如方法的执行或异常的处理。在Spring AOP中，连接点始终表示方法执行。我们可以在连接点来进行拦截和增强。（例子：spring中，所有可以被增强的方法都是连接点）（秀女选妃，所有秀女都是连接点）（反向例子：我想在方法的一半来进行拦截，spring中是做不到的）</li><li><strong>通知：</strong>简单来说，就是你要干嘛。（例如我要记录日志、权限校验等。）</li><li><strong>切点：</strong>简单来说，就是我要在哪些连接点进行增强。不增强的点叫连接点，增强的点就是切点。（秀女选妃，选上了的就是切点）</li><li><strong>引入：</strong>特殊增强：为类动态添加新接口。</li><li><strong>目标对象：</strong>简单来说，就是我们切面进行了增强的原始对象。</li><li><strong>代理：</strong>在spring中，主要使用<strong>JDK动态代理（基于接口）</strong> 和<strong>CGLIB代理（基于类继承）</strong></li><li><strong>织入：</strong>就是把我们的通知插入切点的过程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>AOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架</title>
    <link href="/posts/Spring_framework/"/>
    <url>/posts/Spring_framework/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring框架是Java开发领域极为著名且功能强大的一个框架。如今，众多应用都围绕Spring进行开发，使其成为每位Java开发者必须掌握的核心技能。随着Spring的不断发展，其内涵也经历了相应的演变与扩展，但在这里，我们特指Spring Framework这一核心框架。</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>使用Maven引入Spring依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.39<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="使用java类进行配置"><a href="#使用java类进行配置" class="headerlink" title="使用java类进行配置"></a>使用java类进行配置</h2><p>新建一个java文件，写入</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>    <span class="hljs-comment">//声明这是配置文件</span><br><span class="hljs-meta">@ComponentScan</span>    <span class="hljs-comment">//提示Spring框架去扫描项目中带有@Component注解的组件（方法，类，成员等）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> {<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入是Spring框架中的基本操作之一，<strong>它是指对象的依赖关系（即它需要协作的其他对象）由外部容器（Spring IoC 容器）在运行期动态地注入，而不是由对象自身在内部直接创建。</strong></p><p>详细一点，请看下面的演示</p><p>创建文件<code>ProductionService.java</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span>     <span class="hljs-comment">//声明注解，只有加了这个注解才能被Spring扫描到</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductionService</span>{<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetProduction</span><span class="hljs-params">(Long product_id)</span><br>    {<br>       <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">" "</span>+product_id ;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>创建文件<code>OrderService.java</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span>         <span class="hljs-comment">//声明注解，只有加了这个注解才能被Spring扫描到</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">getorder</span> {<br>    <span class="hljs-meta">@Autowired</span>           <span class="hljs-comment">//这里是注入点</span><br>    ProductionService productionService ;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Getorder</span> <span class="hljs-params">(Long order_id)</span><br>    {<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productionService.GetProduction(<span class="hljs-number">10010L</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"你的订单是 "</span>+ order_id + <span class="hljs-string">"你的产品是"</span>+product;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果没有Spring，我们想要调用<code>get_order</code>服务，那么我们就需要在代码中new一个类为ProductService的对象才能使用他的方法，这在大型项目开发中具有很高的耦合度并且很麻烦。但是如果使用Spring来调用，如下：</p><p>创建文件<code>SpringDemo.java</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Spring;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>         <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> context.getBean(OrderService.class);  <span class="hljs-comment">//Spring容器开始查找并管理OrderSeervice类的对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderService.Getorder(<span class="hljs-number">9999L</span>);<br>        System.out.println(order);<br>    }<br></code></pre></td></tr></tbody></table></figure><p>运行， 就会发现我们无需手动创建<code>ProductService</code>对象，就能直接使用其方法。</p><p>所以，注入这一基本操作我们只需要记住两个注解就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br>  声明一个组件<br><span class="hljs-meta">@Autowired</span><br>  注入<br></code></pre></td></tr></tbody></table></figure><h2 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h2><p>IOC，全称<code>Inversion of Control</code>，中文译为控制反转。在传统的编程模式中，对象之间的创建、组装和管理都是由开发人员手动完成的。而在IOC模式下，这些责任被委托给一个容器（如Spring容器）来管理。这意味着对象不再自行创建和管理其依赖对象，而是由容器在运行时动态地创建和注入这些依赖对象。控制权从代码反转到了容器。从对象内部控制反转到了外部容器控制。</p><p>我们上面的例子就是，将本来的开发者创建并管理类变量的工作转变为了容器来承担。</p><p>DI，（<code>Dependency Injection</code>，依赖注入）是一种实现控制反转（IoC）的设计模式，可以说是一种特殊的IOC。</p><p>依赖：对象a里面需要用到对象b、对象c。可以说对象a依赖对象b、对象c。</p><p>注入：把对象b、对象c放到对象a的过程叫做注入。</p><p>在上面的例子中，我们的获取订单服务，需要用到商品服务，那么就是订单服务依赖于商品服务。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/posts/Mybatis/"/>
    <url>/posts/Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>框架（Framework）是一种<strong>半成品软件</strong>，它提供了一套完整的、可重用的设计、代码和库，旨在帮助开发者<strong>解决特定领域或类型的问题</strong>。框架通常规定了软件系统的整体结构、主要组件及其之间的关系，以及它们之间的交互方式。框架相对于库不仅提供了一组工具，还规定了应用的结构和流程。开发者需要在框架的约束下工作，通过实现特定的接口或继承特定的类来完成应用的功能。</p><h2 id="JDBC的问题"><a href="#JDBC的问题" class="headerlink" title="JDBC的问题"></a>JDBC的问题</h2><p>JDBC（Java Database Connectivity）是Java语言中用于执行SQL语句的应用程序接口（API），它为Java程序提供了一种与各种关系型数据库进行交互的标准方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.servlet;<br><br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCexample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">jdbcURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jdbc:mysql://localhost:3306/willmo_cms"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"root"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"root"</span>;            <br><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(jdbcURL, username, password)) {<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) {<br>                System.out.println(<span class="hljs-string">"Connected to the database!"</span>);<br>            }<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(jdbcURL, username, password);<br>             <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">"INSERT INTO test_table1 (id, Name,age) VALUES (12, 'JDBC插入测试',123)"</span>)) {<br><br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsAffected</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            <span class="hljs-keyword">if</span> (rowsAffected &gt; <span class="hljs-number">0</span>) {<br>                System.out.println(<span class="hljs-string">"A new row has been inserted."</span>);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这对我们来说有几个问题</p><ul><li>繁冗赘余</li><li>SQL和java代码紧紧耦合在一起，难以分开处理</li></ul><p><code>Mybatis</code>正是为了解决这个问题。</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>MyBatis 是一款优秀的<strong>持久层框架</strong>，它支持<strong>自定义 SQL</strong>、存储过程以及<strong>高级映射</strong>。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><table><thead><tr><th>步骤</th><th>核心任务</th><th>关键产出</th><th>简要说明</th></tr></thead><tbody><tr><td>1</td><td><strong>项目初始化</strong></td><td><code>pom.xml</code>(Maven)</td><td>在项目中引入 MyBatis 及其数据库驱动等依赖。</td></tr><tr><td>2</td><td><strong>核心配置</strong></td><td><code>mybatis-config.xml</code></td><td>配置数据源（数据库连接）、事务管理器、以及映射文件路径等。</td></tr><tr><td>3</td><td><strong>创建实体类</strong></td><td>例如 <code>User.java</code></td><td>创建与数据库表结构对应的 Java 类（POJO）。</td></tr><tr><td>4</td><td><strong>创建Mapper接口</strong></td><td>例如 <code>UserMapper.java</code></td><td>定义数据操作的方法（如 <code>selectUserById</code>）。</td></tr><tr><td>5</td><td><strong>编写SQL映射</strong></td><td>例如 <code>UserMapper.xml</code></td><td>在 XML 文件或注解中具体实现 SQL 语句，这一步是为了打开操作数据库的窗口。</td></tr><tr><td>6</td><td><strong>使用SqlSession</strong></td><td>测试代码</td><td>获取 <code>SqlSession</code>，得到 Mapper 接口实例，调用方法完成数据库操作。</td></tr></tbody></table><h3 id="引入依赖和配置"><a href="#引入依赖和配置" class="headerlink" title="引入依赖和配置"></a>引入依赖和配置</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a>Mybatis配置</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-string">"https://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/willmo_cms"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>   <br>                <span class="hljs-comment">&lt;!-- 配置数据库的地址，操作账号和密码 --&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"Mapper/UserMapper.xml"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="创建用户类"><a href="#创建用户类" class="headerlink" title="创建用户类"></a>创建用户类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.servlet;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>}   <span class="hljs-comment">//对应了数据库中存在的三个字段，姓名年龄ID</span><br></code></pre></td></tr></tbody></table></figure><h3 id="创建Mapper接口"><a href="#创建Mapper接口" class="headerlink" title="创建Mapper接口"></a>创建Mapper接口</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Mybatis_demo;<br><br><span class="hljs-keyword">import</span> org.example.servlet.User;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> {     <span class="hljs-comment">//这仅仅是一个接口，方法主体的sql语句将在另一个SQL映射文件填充</span><br> List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br> User <span class="hljs-title function_">GetById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="创建SQL映射文件"><a href="#创建SQL映射文件" class="headerlink" title="创建SQL映射文件"></a>创建SQL映射文件</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-string">"https://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"Mybatis_demo.UserMapper"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span>&gt;</span><br>        insert into test_table1(id,Name,age) values(#{id},#{name},#{age})<br>        <span class="hljs-comment">&lt;!-- #{}是引用java方法中传入的参数名 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在这里写sql语句尽量不要在末尾加分号--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.servlet.User"</span>&gt;</span><br>        select id,Name,age from test_table1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"GetById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.servlet.User"</span>&gt;</span><br>        select id,Name,age from test_table1 where id = #{id}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="使用sqlsession"><a href="#使用sqlsession" class="headerlink" title="使用sqlsession"></a>使用sqlsession</h3><blockquote><p>这是在主方法直接使用Mybatis的部分，我们需要将sqlseesion实例化才能使用Mybatis对应的方法。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Mybatis_demo;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.example.servlet.User;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">mybatisDemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 读取配置文件</span><br>        InputStream inputStream;<br><br>        {<br>            <span class="hljs-keyword">try</span> {<br>                inputStream = Resources.getResourceAsStream(<span class="hljs-string">"mybatis-config.xml"</span>);<br>            } <span class="hljs-keyword">catch</span> (IOException e) {<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            }<br>        }<br><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream); <span class="hljs-comment">//新建工厂类</span><br>        <span class="hljs-comment">// 获得会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; list = userMapper.list();<br>        <span class="hljs-comment">// 获取相关的执行器</span><br>        System.out.println(<span class="hljs-string">"总和用户数量为"</span>+list.size());<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br>        user1.setAge(<span class="hljs-number">90</span>);<br>        user1.setId(<span class="hljs-number">10</span>);<br>        user1.setName(<span class="hljs-string">"插入测试"</span>);<br>        userMapper.insert(user1);<br>        sqlSession.commit();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;= list.size()+<span class="hljs-number">1</span>;i++) {<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.GetById(i);<br>            System.out.println(user);<br>        }<br>    sqlSession.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="Mybatis的核心配置"><a href="#Mybatis的核心配置" class="headerlink" title="Mybatis的核心配置"></a>Mybatis的核心配置</h1><p>可以上滑查看Mybatis配置，这就是我们连接数据库的配置，它解释了连接哪个数据库，操作的账号密码，操作模式等等。为了后续的开发更轻松，我们有必要学习一些配置的技巧</p><blockquote><p><strong>配置是有顺序的</strong>，请保证顺序正确，否则会报错</p></blockquote><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p><p>例如方法实现</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>"list" resultType<span class="hljs-operator">=</span>"org.example.servlet.User"<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>其中的 <code>org.example.servlet.User</code>是一个全限定类名，写起来可能有些繁琐，如果我们限定类名</p><p><code>&lt;typeAliases&gt; &lt;typeAlias alias="User" type="org.example.servlet.User"/&gt; &lt;/typeAliases&gt;</code></p><p>就能够直接使用 <code>User</code>来确认返回值。</p><blockquote><p>尊重xml语法，定义别名需要包含在typeAliases标签里。</p></blockquote><h2 id="SQL标签"><a href="#SQL标签" class="headerlink" title="SQL标签"></a>SQL标签</h2><table><thead><tr><th>resultType</th><th>期望从这条语句中返回结果的类全限定名或别名。                注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。</th></tr></thead><tbody><tr><td>resultMap</td><td>对外部 resultMap 的命名引用。结果映射是 MyBatis                最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。</td></tr></tbody></table><p>这两个指定返回值类型只能使用一个，他们都能够将数据库返回类型转换成java数据类型，但是resultMap更加灵活，可以指定字段的映射规则。</p><p>java方法传入参数名和数据库字段相同时，就能够自动映射完成sql语句的执行。但是有时候，java方法传入参数的字段，和数据库里的字段对不上，那就会造成错误，而resultmap能够给我们创建一个映射来解决这个问题。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Getuser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.servlet.User"</span>&gt;</span><br>        select id,Name,age from test_table1 ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>但是你的用户类定义是</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.servlet;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">public</span> String User_name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里的User_name和数据库字段Name对不上，我们就可以创建映射来使二者关联起来</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"userMap"</span> <span class="hljs-attr">type</span> = <span class="hljs-string">"org.example.Servlet.User"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span> = <span class="hljs-string">"Name"</span> <span class="hljs-attr">property</span> = <span class="hljs-string">"User_name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>由此，我们的数据库字段和java中的User类就可以遵循各自的命名规范。</p><h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><p>动态 SQL 可以在 XML 层根据方法传入的参数动态拼装 SQL，避免手写大量不同情况的 SQL 字符串。常用标签：<code>&lt;if&gt;</code>、<code>&lt;where&gt;</code>、<code>&lt;trim&gt;</code>、<code>&lt;foreach&gt;</code>。</p><p>在模糊查找的时候可用。</p><h3 id="1-lt-if-gt-—-条件片段"><a href="#1-lt-if-gt-—-条件片段" class="headerlink" title="1. <if> — 条件片段"></a>1. <code>&lt;if&gt;</code> — 条件片段</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"searchUsers"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"map"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.domain.User"</span>&gt;</span><br>  SELECT id, Name, age<br>  FROM test_table1<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null and name != ''"</span>&gt;</span><br>      AND Name = #{name}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"minAge != null"</span>&gt;</span><br>      AND age &gt;= #{minAge}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"maxAge != null"</span>&gt;</span><br>      AND age &lt;= #{maxAge}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>&lt;if&gt;</code> 根据参数决定是否插入 SQL 片段。</li><li>结合 <code>&lt;where&gt;</code> 自动处理开头的 <code>AND/OR</code>（见下）。</li></ul><h3 id="2-lt-where-gt-—-自动处理前导逻辑运算符"><a href="#2-lt-where-gt-—-自动处理前导逻辑运算符" class="headerlink" title="2. <where> — 自动处理前导逻辑运算符"></a>2. <code>&lt;where&gt;</code> — 自动处理前导逻辑运算符</h3><p><code>&lt;where&gt;</code> 会在包含的 SQL 片段前自动加 <code>WHERE</code>，并去除多余的前导 <code>AND/OR</code>。<br>（上例演示 <code>&lt;where&gt;</code> 的常见用法）</p><h3 id="3-lt-trim-gt-—-更灵活的前后缀裁剪"><a href="#3-lt-trim-gt-—-更灵活的前后缀裁剪" class="headerlink" title="3. <trim> — 更灵活的前后缀裁剪"></a>3. <code>&lt;trim&gt;</code> — 更灵活的前后缀裁剪</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.example.domain.User"</span>&gt;</span><br>  UPDATE test_table1<br>  <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span>&gt;</span> Name = #{name}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"age != null"</span>&gt;</span> age = #{age}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>  WHERE id = #{id}<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>或使用 <code>&lt;trim&gt;</code>：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"SET"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span>&gt;</span> Name = #{name}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"age != null"</span>&gt;</span> age = #{age}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>&lt;set&gt;</code> 是 <code>&lt;trim prefix="SET" suffixOverrides=",""&gt;</code> 的语法糖，适用于 <code>UPDATE</code> 的字段拼接。</li></ul><h3 id="4-lt-foreach-gt-—-列表（IN）与批量插入"><a href="#4-lt-foreach-gt-—-列表（IN）与批量插入" class="headerlink" title="4. <foreach> — 列表（IN）与批量插入"></a>4. <code>&lt;foreach&gt;</code> — 列表（IN）与批量插入</h3><ul><li>用于 <code>IN</code> 子句：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getByIds"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.domain.User"</span>&gt;</span><br>  SELECT id, Name, age FROM test_table1<br>  WHERE id IN<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span>&gt;</span><br>    #{id}<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>用于批量插入（配合事务）：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"batchInsert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"list"</span>&gt;</span><br>  INSERT INTO test_table1 (Name, age)<br>  VALUES<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span>&gt;</span><br>    (#{user.name}, #{user.age})<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>使用批量插入时，注意数据库与驱动的批量性能，必要时启用 JDBC 批处理或分批提交以避免内存过大。</li></ul><hr><h1 id="性能-x2F-安全"><a href="#性能-x2F-安全" class="headerlink" title="性能 / 安全"></a>性能 / 安全</h1><h3 id="1-使用-避免-SQL-注入（不要用-）"><a href="#1-使用-避免-SQL-注入（不要用-）" class="headerlink" title="1. 使用 #{} 避免 SQL 注入（不要用 ${}）"></a>1. 使用 <code>#{}</code> 避免 SQL 注入（不要用 <code>${}</code>）</h3><ul><li><p><code>#{}</code>：使用预编译参数，自动进行类型处理与转义，它会将用户输入的数据以字符串的形式而不是sql命令输入控制台，能有效防止 SQL 注入。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">WHERE Name = #{name}<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>${}</code>：直接字符串替换（危险），仅在必须动态拼接 SQL 片段（如表名、列名）且确保来源受控时使用。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 不要这样处理用户输入 --&gt;</span><br>WHERE Name = '${name}'<br></code></pre></td></tr></tbody></table></figure></li><li><p>总结：对用户输入的值一律用 <code>#{}</code>；只有在拼接 SQL 语法（表名、排序字段等）且已校验白名单时再考虑 <code>${}</code>。</p></li></ul><h3 id="2-批量插入与性能"><a href="#2-批量插入与性能" class="headerlink" title="2. 批量插入与性能"></a>2. 批量插入与性能</h3><ul><li>对大量数据的插入，使用 <code>&lt;foreach&gt;</code> 批量插入比逐条插入更高效；也可以结合 JDBC 批处理（<code>ExecutorType.BATCH</code>）或分批次提交（例如每 500 条 commit 一次）。</li><li>注意：一次性插入过多记录可能导致单条 SQL 较大或内存问题，建议分批。</li></ul><h3 id="3-索引与-SQL-优化（建议）"><a href="#3-索引与-SQL-优化（建议）" class="headerlink" title="3. 索引与 SQL 优化（建议）"></a>3. 索引与 SQL 优化（建议）</h3><ul><li>为常用的 <code>WHERE</code>/<code>ORDER BY</code> 字段建立索引；对慢查询使用 <code>EXPLAIN</code> 分析。</li><li>避免 SELECT *（按需列出），减少传输与解析开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/posts/Lombok/"/>
    <url>/posts/Lombok/</url>
    
    <content type="html"><![CDATA[<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>Lombok是一个Java库，旨在通过注解的方式在编译期间自动生成getter、setter、equals、hashCode、toString等方法。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 替换为下载的Lombok版本 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Maven项目直接引入依赖即可。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>Java体现的是一切皆为对象的思想，好比说我们定义了一个用户类，这个类有名字，密码，年龄，性别等信息，那么如果我们需要操作这个类的实例化对象，因为他不是最基本的数据类型，也不是JAVA自己已经定义的数据结构，所以我们就必须重写他的getter(获取)、setter(设置)、equals(判断等同)、hashCode(判断逻辑等同)、toString(字符串形式表述)等方法，才能方便地使用它，但是随着工程量上升，这一部分往往是枯燥且麻烦的工作，所以Lombok被设计出来能够帮我们完成这个任务。</p><p>Lombok不会直接修改项目的源代码，他会在 <strong>Java 编译过程中</strong> 默默工作的“代码助手”。它并非在运行时通过反射等机制动态生成代码，而是直接在源代码编译为字节码的阶段，通过修改编译器的 <strong>抽象语法树（AST）</strong> 来“添加”代码，最终生成的 <code>.class</code>文件就已经包含了所有完整的方法。</p><h2 id="Lombok常见注解方法"><a href="#Lombok常见注解方法" class="headerlink" title="Lombok常见注解方法"></a>Lombok常见注解方法</h2><ol><li>@Getter 和 @Setter：<br>自动生成属性的getter和setter方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Getter;<br><span class="hljs-keyword">import</span> lombok.Setter;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Setter</span> <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Setter</span> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>@NoArgsConstructor：<br>自动生成无参构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br> <br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>@AllArgsConstructor：<br>自动生成全参构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br> <br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>@RequiredArgsConstructor：<br>自动生成包含final属性和@NonNull属性的构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.NonNull;<br> <br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>@ToString：<br>自动生成toString方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.ToString;<br> <br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="6"><li>@EqualsAndHashCode：<br>自动生成equals和hashCode方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;<br> <br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="7"><li>@Data：<br>组合了@Getter、@Setter、@ToString、@EqualsAndHashCode和@RequiredArgsConstructor的功能。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br> <br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="8"><li>@Slf4j：<br>自动生成名为log的日志记录器字段。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br> <br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> {<br>        log.info(<span class="hljs-string">"Logging something..."</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/posts/Mysql/"/>
    <url>/posts/Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>在网络开发中，大量的用户数据必须存储在<code>网页后端</code>，为此，数据库为我们提供了支持。数据库类似于Excel表格，允许我们以高度结构化的形式存储用户数据并能够与程序产生交互。</p><p>数据库分为<strong>关系型数据库</strong>和<strong>非关系型数据库</strong>，关系型数据库是基于关系模型来存储和管理数据的数据库系统。关系就是基于表格的数据模型，它使用行和列来表示数据，并通过主键和外键来定义表之间的关系。而非关系型数据库则不强制要求使用关系模型来存储数据，这一点是倒是更灵活。</p><p>目前主流的关系型数据库有：<code>Mysql</code>，<code>Sql Server</code>，<code>Oracle</code>，<code>DB2</code>，<code>DM达梦</code>。</p><p>我们以最广泛的开源数据库<code>Mysql</code>展开讨论。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>安装过程中需要设置用户，建议设置一个管理员用户和一个普通用户，我个人习惯是管理员用户名和密码都是root，期间安装程序会提醒你输入原有已经输入的密码，安装过程才能继续。</p><p>完成后，我们就能够通过命令行来使用数据库，但这很麻烦，毕竟在计算机性能发达的今天，图形化才是趋势。</p><h2 id="DBeaver"><a href="#DBeaver" class="headerlink" title="DBeaver"></a>DBeaver</h2><p>下载地址：<a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a></p><p>安装过程略过</p><p>安装完成后创建连接：</p><p><img src="https://s2.loli.net/2025/10/22/L59GUItEfFzHSOm.webp" alt="image"></p><p>然后你就能在DBeaver中操作数据库的表了。</p><p>但是，这一类可视化图形工具起到的作用只是简化操作，帮我们输入并执行SQL语句而已，作为开发人员我们需要具备使用命令行实现增删改查的能力。</p><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>SQL语句不是像java一样的命令式编程语言，而是<strong>声明式编程语言</strong>，就和开源项目的命令行使用方法类似。</p><p>这一部分不会比我们之前学习的java难，放松。</p><p>SQL语句适用于大多数关系型数据库，是统一操作语言，但某些关系型数据库在语法解析上可能有细微差别，你可以理解成编译器不同导致的输出不同。SQL语句和根据数据库不同特征化的语句可以理解为是普通话和方言一样。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><ul><li>数据库 (Database)</li></ul><p>一个存储数据的仓库，可以包含多个表，用于组织和管理大量结构化数据。</p><ul><li>表 (Table)</li></ul><p>数据库中的一种数据结构，由行和列组成，用于存储特定类型的数据（如用户表、订单表）。</p><ul><li>列名 (Column Name)</li></ul><p>表中的每一列都有一个名称，用于标识该列存储的数据（如 username、age）。</p><ul><li>数据类型 (Data Type)</li></ul><p>定义列中数据的类型，如整数 (INT)、字符串 (VARCHAR)、日期 (DATE) 等。</p><ul><li>自增 (Auto Increment)</li></ul><p>一种属性，通常用于主键列，每次插入新数据时自动递增（如 1, 2, 3…）。</p><ul><li>非空 (NOT NULL)</li></ul><p>一种约束，确保列中不能存储空值（必须填写数据）。</p><ul><li>唯一 (UNIQUE)</li></ul><p>一种约束，确保列中的值不能重复（但允许空值）。</p><ul><li>主键 (Primary Key)</li></ul><p>一种唯一且非空的列（或列组合），用于唯一标识表中的每一行。</p><ul><li>外键 (Foreign Key)</li></ul><p>一种列，用于关联另一张表的主键，确保数据的一致性和完整性。</p><ul><li>默认值 (Default Value)</li></ul><p>如果插入数据时未指定值，列将自动填充的预设值（如 DEFAULT 0）。</p><ul><li>注释 (Comment)</li></ul><p>对表、列或索引的说明，用于帮助理解其用途（如 COMMENT ‘用户姓名’）。</p><ul><li>索引 (Index)</li></ul><p>一种数据结构，用于加快数据检索速度（类似于书的目录），但会增加写入数据的开销。</p><p><strong>总结一下，数据库包含表，表又包含列和行，其中列起到锚定作用，自增，唯一，主键，外键，都是列的属性或者类型，行起到保存数据作用，行和列围成的格子中存放的原子数据又包含了不同的数据类型。</strong></p><h3 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a><strong>SQL的分类</strong></h3><ol><li><strong>DDL（Data Definition Language，数据定义语言）</strong>：用于创建、修改和删除数据库中的各种对象，如表、索引、视图、触发器等。常见的DDL命令包括CREATE（创建）、ALTER（修改）和DROP（删除）。例如，CREATE TABLE用于创建新的数据库表，ALTER TABLE用于修改表的结构，DROP TABLE则用于删除表。</li><li><strong>DML（Data Manipulation Language，数据操纵语言）</strong>：允许用户对数据库中的数据进行基本操作，如插入、更新、删除和查询数据记录。常见的DML命令有INSERT（插入）、UPDATE（更新）、DELETE（删除）和SELECT（查询）。其中，SELECT是SQL语言的基础，用于从数据库中检索数据。</li><li><strong>DQL（Data Query Language，数据查询语言）</strong>：主要用于从数据库中检索数据，其核心指令是SELECT。DQL是DML的一个子集，专注于数据查询操作。</li><li><strong>DCL（Data Control Language，数据控制语言）</strong>：用于控制数据库用户访问权限和安全性的语言。DCL包括授予和撤销用户权限的命令，以及管理数据库对象的权限。常见的DCL命令有GRANT（授予）和REVOKE（撤销）。通过DCL，数据库管理员可以设定哪些用户有权访问哪些数据库对象，以及他们可以进行哪些操作。</li><li><strong>TCL（Transaction Control Language，事务控制语言）</strong>：用于管理事务的语言，包括开始事务、提交事务、回滚事务等命令。常见的TCL命令有BEGIN（开始事务）、COMMIT（提交事务）和ROLLBACK（回滚事务）。TCL在快速原型开发、脚本编程、GUI和测试等方面非常有用，它允许将一系列操作组合为一个逻辑事务，从而确保数据的完整性和一致性。</li></ol><h1 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h1><h3 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> DateBase [数据库名]；<br></code></pre></td></tr></tbody></table></figure><p>例如：创建名为<code>willmo</code>的数据库</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> datebase willmo;<br></code></pre></td></tr></tbody></table></figure><p>SQL语句对关键字大小写不敏感，但是对名称等标识敏感。</p><p>其他的参考java的编程语言书写规范就可以了。</p><p>你可以在图形化软件操作后查看操作对应的sql语句,例如在创建表的同时新建列，并列出列的属性：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (<br>    列名<span class="hljs-number">1</span> 数据类型 [约束条件],<br>    列名<span class="hljs-number">2</span> 数据类型 [约束条件],<br>    ...<br>    [表级约束]<br>);<br></code></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> willmo.test (           <span class="hljs-comment">--这里是全限定表名，提及了数据库名willmo，如果选中了数据库就不用提及数据库名，这和绝对路径和相对路径是一个道理。</span><br>  id <span class="hljs-type">INT</span> auto_increment <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'id'</span>,  <span class="hljs-comment">--列名为id,属性是自增非空，数据类型是INT整型</span><br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'姓名'</span>,<span class="hljs-comment">--列名为name,属性是非空，别名为“姓名”，数据类型字符串</span><br>  <span class="hljs-keyword">CONSTRAINT</span> test_pk <span class="hljs-keyword">PRIMARY</span> KEY (id     <span class="hljs-comment">--设置id为主键，也就是起唯一标识作用的列</span><br>)<br>ENGINE<span class="hljs-operator">=</span>InnoDB                            <span class="hljs-comment">--指定引擎</span><br><span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;                 <span class="hljs-comment">--指定字符集，utf8mb4相较于utf8他能够存储表情</span><br></code></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在MySQL中，为列选择合适的数据类型至关重要，因为它直接影响到数据的存储效率、查询性能以及数据的完整性。以下是根据数据类型和用途给出的一些推荐：</p><h6 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h6><ol><li><strong>整数类型</strong></li></ol><ul><li><strong>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</strong>：根据数值的范围选择合适的大小。例如，如果确定数值不会超过255，那么使用TINYINT可以节省存储空间。</li><li><strong>UNSIGNED</strong>：如果数值不需要负数，使用UNSIGNED属性可以将正数的范围扩大一倍。</li><li><strong>AUTO_INCREMENT</strong>：如果需要自动生成唯一的标识符，可以在主键列上使用AUTO_INCREMENT属性。</li></ul><ol><li><strong>浮点数类型</strong></li></ol><ul><li><strong>FLOAT、DOUBLE</strong>：用于存储近似数值。FLOAT占用4个字节，DOUBLE占用8个字节。如果需要更高的精度，可以选择DOUBLE。</li><li><strong>DECIMAL</strong>：用于存储精确数值，如金融计算。DECIMAL类型可以指定小数点前后的位数，如DECIMAL(10,2)表示总共10位数字，其中小数点后有2位。</li></ul><h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6><ol><li><strong>CHAR</strong></li></ol><ul><li>用于存储固定长度的字符串。如果字符串长度几乎相同，或者长度很短且变更不频繁，CHAR是更好的选择。</li><li>CHAR类型会删除字符串末尾的空格，并根据需要填充空格以方便比较。</li></ul><ol><li><strong>VARCHAR</strong></li></ol><ul><li>用于存储可变长度的字符串。VARCHAR类型仅使用必要的空间，因此比CHAR更节省空间。</li><li>当字符串列的最大长度远大于平均长度时，或者字符串经常更新时，VARCHAR是更好的选择。</li></ul><ol><li><strong>TEXT类型</strong></li></ol><ul><li>用于存储大文本数据。TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT分别可以存储不同大小的数据。</li><li>如果需要存储非常大的文本数据，可以选择LONGTEXT。</li></ul><h6 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h6><ol><li><strong>DATE</strong>：用于存储日期值，格式为YYYY-MM-DD。</li><li><strong>TIME</strong>：用于存储时间值，格式为HH:MM:SS。</li><li><strong>DATETIME</strong>：用于存储日期和时间值，格式为YYYY-MM-DD HH:MM:SS。</li><li><strong>TIMESTAMP</strong>：用于存储UNIX时间戳，表示从1970年1月1日以来的秒数。TIMESTAMP值依赖于时区设置。</li></ol><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询我们使用这个格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,... <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></tbody></table></figure><p>当然你也可以使用通配符<code>*</code>，虽然这么做可能引发性能问题。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></tbody></table></figure><p>使用<code>select</code>能够找出相应列，但是我们需要使用<code>where</code>来实现条件查询</p><p>比如：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">5000</span>;     <span class="hljs-comment">--找出5000块工资以上的职员</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> category <span class="hljs-operator">=</span> <span class="hljs-string">'Electronics'</span>    <span class="hljs-comment">--找出电子类和1000块以下的产品</span><br><span class="hljs-keyword">AND</span> price <span class="hljs-operator">&lt;</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></tbody></table></figure><p>查询条件：</p><ul><li><code>=</code>, <code>&lt;&gt;</code>/<code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li><li>BETWEEN … AND …<ul><li>意思是查找区间范围的数据，如找12-19的数据可以是<code>select number from  num Between 12 and 19</code></li></ul></li><li>LIKE（配合%和_使用）<ul><li>LIKE是模糊查询，如果你想找张某某，你可以查询<code>select name from user LIKE "张%";</code></li></ul></li><li>IN (值列表)，比如<code>IN 12,13,15,16</code>;</li></ul><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 按工资降序排列</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 获取前10条记录（不同数据库语法可能不同）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br>LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></tbody></table></figure><p><code>asc</code>是顺序排序，<code>desc</code>是逆向排序。</p><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total_employees,   <span class="hljs-comment">--输出全体职员的数量</span><br>      <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-keyword">AS</span> sum_salary,   <span class="hljs-comment">--求薪水之和</span><br>    <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> average_salary, <span class="hljs-comment">--使用关键字计算平均薪水</span><br>    <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> max_salary,<br>    <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">AS</span> min_salary<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></tbody></table></figure><p>你可以使用<code>having</code>语句和<code>group by </code>语句来实现对某一群体进行聚合查询和计算</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">6000</span>;   <span class="hljs-comment">--计算所以6000薪资以上的职员的平均工资</span><br></code></pre></td></tr></tbody></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>你一定能够注意到，查询的结果返回的也是一个表，那么我们就能够对返回表再做一次查询。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> price <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(price) <span class="hljs-keyword">FROM</span> products);    <span class="hljs-comment">--查询出高于产品平均价的那一批产品</span><br></code></pre></td></tr></tbody></table></figure><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p>使用<code>INSERT</code>关键字来实现</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ..., 字段N)<br><span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ..., 值N);<br></code></pre></td></tr></tbody></table></figure><p>如果你向插入一行完整的数据，就可以省略字段</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ..., 值N);   <span class="hljs-comment">--确保只有N列</span><br></code></pre></td></tr></tbody></table></figure><p>你也可以批量新增</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ..., 字段N)<br><span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>_1, 值<span class="hljs-number">1</span>_2, ..., 值<span class="hljs-number">1</span>_N),<br>    (值<span class="hljs-number">2</span>_1, 值<span class="hljs-number">2</span>_2, ..., 值<span class="hljs-number">2</span>_N),<br>    ...,<br>    (值M_1, 值M_2, ..., 值M_N);<br></code></pre></td></tr></tbody></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名<br><span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 新值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 新值<span class="hljs-number">2</span>, ...<br><span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></tbody></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：where条件查询关键字的缺失不会引发编译错误，但是增加删除修改等破坏性操作如果没有where关键字那操作对象就是整个表格，很可能会对全表格造成增删改的不可逆破坏。</strong></p><h3 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h3><h5 id="第一范式（1NF-First-Normal-Form）"><a href="#第一范式（1NF-First-Normal-Form）" class="headerlink" title="第一范式（1NF, First Normal Form）"></a>第一范式（1NF, First Normal Form）</h5><p><strong>简单来说</strong>： 每个字段只存储一项信息，每一列都是原子的，不可再分。</p><p><strong>例子</strong>： 假设有一个记录学生信息的表格，如果有一个字段叫做“个人信息”，里面包含了姓名、年龄和性别等多个信息，这就违反了第一范式。正确的做法是将“个人信息”这个字段拆分成姓名、年龄、性别等多个字段，每个字段只存储一项信息。</p><h5 id="第二范式（2NF-Second-Normal-Form）"><a href="#第二范式（2NF-Second-Normal-Form）" class="headerlink" title="第二范式（2NF, Second Normal Form）"></a>第二范式（2NF, Second Normal Form）</h5><p><strong>简单来说</strong>： 在满足第一范式的基础上，要求表格中的每一非主键字段都完全依赖于主键字段，而不能依赖于主键的一部分或是其他非主键字段。</p><h6 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h6><table><thead><tr><th><strong>学生ID</strong></th><th><strong>课程ID</strong></th><th><strong>课程名称</strong></th><th><strong>授课教师</strong></th><th><strong>学分</strong></th></tr></thead><tbody><tr><td>S001</td><td>C01</td><td>数学</td><td>王老师</td><td>3</td></tr><tr><td>S001</td><td>C02</td><td>英语</td><td>李老师</td><td>2</td></tr><tr><td>S002</td><td>C01</td><td>数学</td><td>王老师</td><td>3</td></tr></tbody></table><ul><li><strong>主键</strong>：<code>(学生ID, 课程ID)</code>（复合主键）</li><li><strong>问题</strong>：</li><li><code>课程名称</code> 和 <code>授课教师</code> 仅依赖于 <code>课程ID</code>（主键的一部分），而非完整主键。</li><li><code>学分</code> 也仅依赖于 <code>课程ID</code>。</li><li><strong>结论</strong>：存在非主属性对主键的<strong>部分依赖</strong>，满足1NF（所有列原子），但不满足2NF。</li></ul><h5 id="第三范式（3NF-Third-Normal-Form）"><a href="#第三范式（3NF-Third-Normal-Form）" class="headerlink" title="第三范式（3NF, Third Normal Form）"></a>第三范式（3NF, Third Normal Form）</h5><p><strong>简单来说</strong>： 在满足第二范式的基础上，要求表格中的每一非主键字段都直接依赖于主键字段，而不能通过其他非主键字段间接依赖于主键字段。换句话说，非主键字段之间不能有传递依赖关系。</p><p><strong>例子</strong>：</p><table><thead><tr><th><strong>学生ID</strong></th><th><strong>姓名</strong></th><th><strong>年龄</strong></th><th><strong>所在学院</strong></th><th><strong>学院电话</strong></th></tr></thead><tbody><tr><td>S001</td><td>张三</td><td>20</td><td>计算机学院</td><td>021-1234</td></tr><tr><td>S002</td><td>李四</td><td>21</td><td>经济管理学院</td><td>021-5678</td></tr></tbody></table><ul><li><strong>主键</strong>：<code>学生ID</code></li><li><strong>问题</strong>：</li><li><code>学院电话</code> 依赖于 <code>所在学院</code>，而 <code>所在学院</code> 又依赖于 <code>学生ID</code>。</li><li>存在非主属性 <code>学院电话</code> 对主键的<strong>传递依赖</strong>。</li><li><strong>结论</strong>：满足2NF（无部分依赖），但不满足3NF（存在传递依赖）。</li></ul><h5 id="反范式化（Denormalization）"><a href="#反范式化（Denormalization）" class="headerlink" title="反范式化（Denormalization）"></a><strong>反范式化（Denormalization）</strong></h5><p>话虽如此，但是在实际业务中，尤其是对查询性能要求很高的场景（如大数据分析、报表系统），<strong>有时会故意违反更高的范式，允许一定的数据冗余，这就是反范式化</strong>。这是因为范化（规范化）在减少冗余的同时，也增加了表的数量，复杂的查询可能需要关联多张表，从而<strong>降低查询速度</strong>。因此，数据库设计往往是在<strong>数据冗余</strong>和<strong>查询性能</strong>之间做出权衡。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>外键起到链接两个表的作用，简单来说，就是一个数据库表中的字段，它指向另一个表的主键。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 子表名 (<br>    子表字段<span class="hljs-number">1</span> 数据类型 约束条件,<br>    子表字段<span class="hljs-number">2</span> 数据类型 约束条件,<br>    ...<br>    外键字段 数据类型,<br>    ...<br>    <span class="hljs-keyword">CONSTRAINT</span> 外键约束名 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表主键字段)<br>    [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>]<br>    [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>]<br>);<br></code></pre></td></tr></tbody></table></figure><p>如果表已经存在</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 子表名<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键约束名 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表主键字段)<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>];<br></code></pre></td></tr></tbody></table></figure><h4 id="关于外键的补充"><a href="#关于外键的补充" class="headerlink" title="关于外键的补充"></a>关于外键的补充</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>数据完整性：</li></ol><ul><li>外键约束确保了子表中的外键值必须存在于父表对应的主键或唯一键中，从而避免了孤立记录的出现，维护了数据的引用完整性。</li></ul><ol start="2"><li>级联操作：</li></ol><ul><li>外键可以配置为自动处理相关表中的数据更新或删除操作，如级联更新和级联删除。这有助于保持数据的一致性，并减少了手动维护数据关系的复杂性。</li></ul><ol start="3"><li>减少应用程序代码复杂度：</li></ol><ul><li>通过数据库层面的约束来管理数据关系，可以减轻应用程序开发人员在业务逻辑中实现这些规则的负担，使代码更加简洁和易于维护。</li></ul><ol start="4"><li>提高数据质量：</li></ol><ul><li>自动化的检查和维护有助于保持数据的准确性和一致性，减少了人为错误的可能性。</li></ul><ol start="5"><li>索引支持：</li></ol><ul><li>通常情况下，外键会被自动创建索引，这不仅加速了对关联数据的查找，也提高了连接查询（JOIN）的效率。</li></ul><ol start="6"><li>查询优化器辅助：</li></ol><ul><li>外键信息可以帮助数据库查询优化器更好地理解表间的关系，从而生成更高效的执行计划。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>性能开销：</li></ol><ul><li>外键约束会增加数据库的维护成本。每次插入、更新或删除涉及外键的记录时，数据库都需要检查外键约束是否得到满足，这可能会导致额外的性能开销。在高并发或大数据量的系统中，这种性能开销可能更加明显。</li></ul><ol start="2"><li>级联操作风险：</li></ol><ul><li>虽然级联操作有助于保持数据的一致性，但在某些情况下，它可能不是期望的行为。例如，删除一个记录可能会意外地删除与之相关的多个记录，导致数据丢失。</li></ul><ol start="3"><li>增加数据库复杂性：</li></ol><ul><li>使用外键会增加数据库的复杂性，使得数据库结构更难理解和维护。特别是在大型系统中，多个表之间的复杂关系可能导致混淆和错误。</li></ul><ol start="4"><li>依赖性问题：</li></ol><ul><li>外键创建了一种依赖性，即一个表中的数据依赖于另一个表中的数据。这种依赖性可能导致数据迁移或重构时的困难。</li></ul><ol start="5"><li>死锁风险：</li></ol><ul><li>在高并发环境中，外键可能导致死锁问题。当多个事务试图同时更新涉及外键的数据时，可能会出现死锁，导致系统性能下降。</li></ul><ol start="6"><li>灵活性限制：</li></ol><ul><li>使用外键可能会限制数据库结构的灵活性。例如，在分区或分表操作时，外键可能会成为一种约束，限制数据库设计的变化。</li></ul><h2 id="多表查询-x2F-连接查询"><a href="#多表查询-x2F-连接查询" class="headerlink" title="多表查询/连接查询"></a>多表查询/连接查询</h2><p>多表查询允许你一次在多张表中查询</p><h4 id="常见的连接"><a href="#常见的连接" class="headerlink" title="常见的连接"></a>常见的连接</h4><table><thead><tr><th>连接类型</th><th>关键词</th><th>数据保留方向</th><th>未匹配数据处理</th><th>SQL示例</th></tr></thead><tbody><tr><td>内连接</td><td>INNER JOIN</td><td>仅保留两个表中匹配的行</td><td>丢弃不匹配的行</td><td><code>SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;</code></td></tr><tr><td>左外连接</td><td>LEFT JOIN</td><td>保留左表所有行及与右表匹配的行</td><td>右表未匹配部分填充NULL</td><td><code>SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;</code></td></tr><tr><td>右外连接</td><td>RIGHT JOIN</td><td>保留右表所有行及与左表匹配的行</td><td>左表未匹配部分填充NULL</td><td><code>SELECT * FROM table1 RIGHT JOIN table2 ON table1.id = table2.id;</code></td></tr><tr><td>全外连接</td><td>FULL JOIN</td><td>保留左表和右表中的所有行</td><td>未匹配部分在相应侧填充NULL</td><td><code>SELECT * FROM table1 FULL JOIN table2 ON table1.id = table2.id;</code>（注意：不是所有数据库都支持FULL JOIN，有些数据库使用UNION ALL结合LEFT JOIN和RIGHT JOIN来实现类似功能）</td></tr><tr><td>交叉连接（笛卡尔积）</td><td>CROSS JOIN</td><td>生成两个表中所有行的组合（笛卡尔积）</td><td>无特殊处理（所有组合均保留）</td><td><code>SELECT * FROM table1 CROSS JOIN table2;</code> 或简单地 <code>SELECT * FROM table1, table2;</code></td></tr></tbody></table><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>SQL是操作语言，而操作必须是原子化的，事务的作用就是保证原子化。事务是一系列数据库操作的集合，这些操作被视为一个单一的工作单元。事务中的操作要么全部执行成功，要么在遇到错误时全部撤销。</p><p>事务具有四个关键特性，通常称为ACID特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。事务在执行过程中发生错误，则会回滚到事务开始前的状态。</li><li><strong>一致性（Consistency）</strong>：事务执行前后，数据库都必须处于一致性状态。这意味着事务执行的结果必须是有效的，符合所有定义的规则、约束和触发器。</li><li><strong>隔离性（Isolation）</strong>：并发执行的事务之间不会互相干扰。一个事务内部的操作对其他并发事务是不可见的，直到该事务提交。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，它对数据库的影响是永久的，即使系统崩溃也不会丢失。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat</title>
    <link href="/posts/Tomcat/"/>
    <url>/posts/Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><blockquote><p>Tomcat 是一个 Java Servlet 容器（应用服务器），用于运行 Java web 应用（Servlet / JSP / WAR）。<br>Nginx 不是 Servlet 容器——它不能直接运行 Java servlet，但常用于静态文件、反向代理、负载均衡和 TLS 终端，通常会把请求转发到 Tomcat 或其他应用服务器。</p></blockquote><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><ul><li>官方下载地址：<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></li><li>解压（或安装）后进入 Tomcat 根目录。Windows 下启动脚本位于 <code>bin\startup.bat</code>（或 <code>catalina.bat</code>），Linux/macOS 下为 <code>bin/startup.sh</code>（或 <code>catalina.sh</code>）。生产环境通常使用 systemd 服务或进程管理器来启动和守护 Tomcat（不要直接在生产机上双击脚本）。</li><li><strong>环境变量</strong>：确保系统已安装合适版本的 Java 并设置 <code>JAVA_HOME</code>（以及可选的 <code>CATALINA_HOME</code> / <code>CATALINA_BASE</code>）。在选择 Tomcat 版本前，请先确认该 Tomcat 对应的 JDK/Java 要求（参见 Tomcat 官方的<a href="https://tomcat.apache.org/whichversion.html">“Which version”</a> 页面）。</li></ul><h2 id="本地截图"><a href="#本地截图" class="headerlink" title="本地截图"></a>本地截图</h2><p><img src="https://s2.loli.net/2025/10/20/jYHJGyDdqS2VOWC.png" alt="image-20251020115944381"></p><p><img src="https://s2.loli.net/2025/10/20/ea9sMRmXqfAL3iT.png" alt="image-20251020115936464"></p><h2 id="关于-Java-EE-x2F-Jakarta-EE（简明）"><a href="#关于-Java-EE-x2F-Jakarta-EE（简明）" class="headerlink" title="关于 Java EE / Jakarta EE（简明）"></a>关于 Java EE / Jakarta EE（简明）</h2><ol><li><strong>背景</strong>：Oracle 在 2017 年把 Java EE 移交给 Eclipse Foundation，随后更名为 Jakarta EE。:contentReference[oaicite:4]{index=4}</li><li><strong>包名变化</strong>：从 Jakarta EE 9 开始，标准 API 的包名由 <code>javax.*</code> 迁移为 <code>jakarta.*</code>。这会导致依赖旧 <code>javax.*</code> 的应用在 Tomcat 10（及更高、基于 Jakarta API 的容器）上无法直接运行，除非进行迁移或使用兼容工具。:contentReference[oaicite:5]{index=5}</li><li><strong>实务建议</strong>：<ul><li>如果你的项目还使用 <code>javax.*</code>（很多老项目/第三方库如此），可以继续使用 Tomcat 9.x（兼容 javax）直到完成迁移；</li><li>或者使用 <strong>Apache Tomcat 的迁移工具</strong>（migration tool for Jakarta EE）将已有的 WAR/binaries 从 <code>javax</code> 转为 <code>jakarta</code>；也可以在源码层面升级依赖并重新编译。:contentReference[oaicite:6]{index=6}</li></ul></li></ol><h2 id="部署（常用方法）"><a href="#部署（常用方法）" class="headerlink" title="部署（常用方法）"></a>部署（常用方法）</h2><ul><li><strong>直接部署 WAR</strong>：把 <code>yourapp.war</code> 拷贝到 Tomcat 的 <code>webapps/</code> 目录，Tomcat 会自动展开并部署（默认）。这是最简单的本地部署方式。:contentReference[oaicite:7]{index=7}</li><li><strong>使用 Manager</strong>：通过 Tomcat Manager 可以网页方式或 HTTP 接口部署、卸载应用；需要在 <code>conf/tomcat-users.xml</code> 为管理用户配置 <code>manager-gui</code> / <code>manager-script</code> 等角色。开发/测试环境常用此方式。:contentReference[oaicite:8]{index=8}</li><li><strong>其它方式</strong>：还可以使用 CI/CD 工具、远程部署脚本或 Tomcat Deployer 客户端等流程化部署方式（适合生产）。:contentReference[oaicite:9]{index=9}</li></ul><h2 id="常见配置与注意事项"><a href="#常见配置与注意事项" class="headerlink" title="常见配置与注意事项"></a>常见配置与注意事项</h2><ul><li><strong>默认端口</strong>：<code>8080</code>（在 <code>conf/server.xml</code> 中可修改）。</li><li><strong>安全建议</strong>：不要直接把 Tomcat 端口暴露在公网；在生产环境常见做法是把 Nginx 放在前面做反向代理、TLS 终端和静态资源处理，Tomcat 只监听内网访问。</li><li><strong>JDK 版本</strong>：务必根据你选的 Tomcat 版本检查所需的 Java 版本（64-bit），并使用受支持的 JDK。官方“Which version”页面有对应表格。</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  Licensed to the Apache Software Foundation (ASF)...</span><br><span class="hljs-comment">  （原始许可证头略）</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 顶层 Server 元素：代表 Tomcat 实例级别的配置（不是容器本身）</span><br><span class="hljs-comment">     主要属性：</span><br><span class="hljs-comment">       port: 用于监听关闭命令的端口。默认通常是 8005。设置为 -1 则禁用通过端口关闭（更安全）。</span><br><span class="hljs-comment">       shutdown: 发送到 port 的字符串命令，若匹配则触发正常关闭。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"-1"</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">"SHUTDOWN"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 下面是若干 Listener（监听器），在 Tomcat 启动/关闭过程中执行初始化或清理工作 --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 记录版本信息（启动时打印 Tomcat/组件版本）--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 可选的安全监听器（已注释），用于增强安全相关初始化 --&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  &lt;Listener className="org.apache.catalina.security.SecurityListener" /&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- APR（Tomcat Native / OpenSSL）生命周期监听器，</span><br><span class="hljs-comment">       当安装了 Tomcat Native / APR 时可以使用以提升性能/SSL 支持。</span><br><span class="hljs-comment">       注意：需要额外本地库，非必须。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.AprLifecycleListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- OpenSSL 的替代（基于 Java 22 的 FFM API）示例（被注释）。</span><br><span class="hljs-comment">       如果启用，和 AprLifecycleListener 的作用类似：提供 OpenSSL 支持。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;Listener className="org.apache.catalina.core.OpenSSLLifecycleListener" /&gt; --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 防止常见的 JRE/JEE API 导致的内存泄漏（如 JDBC 驱动、线程本地变量等） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 管理全局 JNDI 资源的生命周期（例如全局 DataSource、UserDatabase） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 预防 ThreadLocal 导致的泄漏（在某些类库使用 ThreadLocal 时有帮助） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 全局 JNDI 资源（GlobalNamingResources）</span><br><span class="hljs-comment">       在这里定义的资源可以被 webapp 或 Realm 等通过 JNDI 引用。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- UserDatabase：内存可编辑的用户数据库资源示例</span><br><span class="hljs-comment">         属性说明：</span><br><span class="hljs-comment">           name: JNDI 名称（引用该资源时使用的名字）</span><br><span class="hljs-comment">           auth: Container / Application（谁来管理认证）</span><br><span class="hljs-comment">           type: Java 类型（接口/类）</span><br><span class="hljs-comment">           description: 描述</span><br><span class="hljs-comment">           factory: 生产该资源实例的工厂类</span><br><span class="hljs-comment">           pathname: 资源的数据文件路径，这里指向 conf/tomcat-users.xml（保存用户和角色）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"UserDatabase"</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">type</span>=<span class="hljs-string">"org.apache.catalina.UserDatabase"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">description</span>=<span class="hljs-string">"User database that can be updated and saved"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">factory</span>=<span class="hljs-string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">pathname</span>=<span class="hljs-string">"conf/tomcat-users.xml"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">GlobalNamingResources</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Service：一个 Service 下可以包含多个 Connector（端点），共享同一个 Engine（容器）</span><br><span class="hljs-comment">       name: 服务名（任意，例如 "Catalina"）</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Executor：可选的线程池定义（被注释）。</span><br><span class="hljs-comment">         定义后多个 Connector 可以复用同一个线程池（通过 executor 属性）。</span><br><span class="hljs-comment">         属性示例：</span><br><span class="hljs-comment">           name: 线程池名字</span><br><span class="hljs-comment">           namePrefix: 线程名前缀</span><br><span class="hljs-comment">           maxThreads: 最大线程数</span><br><span class="hljs-comment">           minSpareThreads: 最少空闲线程</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"</span><br><span class="hljs-comment">        maxThreads="150" minSpareThreads="4"/&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Connector：表示接受请求的网络端点（HTTP、AJP 等）</span><br><span class="hljs-comment">         常见属性：</span><br><span class="hljs-comment">           port: 监听端口（例如 8080）</span><br><span class="hljs-comment">           protocol: 协议实现（HTTP/1.1、AJP/1.3 或特定的 Http11NioProtocol 等）</span><br><span class="hljs-comment">           connectionTimeout: 毫秒为单位，连接空闲或等待时间</span><br><span class="hljs-comment">           redirectPort: 当需要 SSL 时重定向到的端口（通常 8443）</span><br><span class="hljs-comment">           executor: 指向上面定义的线程池名字（如果使用共享线程池）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 如果使用共享线程池 (Executor)，Connector 可以写成下面这种形式（示例被注释） --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Connector executor="tomcatThreadPool"</span><br><span class="hljs-comment">               port="8080" protocol="HTTP/1.1"</span><br><span class="hljs-comment">               connectionTimeout="20000"</span><br><span class="hljs-comment">               redirectPort="8443" /&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- SSL/TLS Connector 示例（注释掉），展示如何配置 HTTPS（8443）和 HTTP/2</span><br><span class="hljs-comment">         重要点：</span><br><span class="hljs-comment">           SSLEnabled="true" 开启 SSL</span><br><span class="hljs-comment">           使用 &lt;SSLHostConfig&gt; 和 &lt;Certificate&gt; 指定 keystore 或证书信息</span><br><span class="hljs-comment">           可以选用不同的协议实现（NIO、APR 等）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"</span><br><span class="hljs-comment">               maxThreads="150" SSLEnabled="true"&gt;</span><br><span class="hljs-comment">        &lt;!-- 启用 HTTP/2 协议支持 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">UpgradeProtocol</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.coyote.http2.Http2Protocol"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">SSLHostConfig</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Certificate</span> <span class="hljs-attr">certificateKeystoreFile</span>=<span class="hljs-string">"conf/localhost-rsa.jks"</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">certificateKeystorePassword</span>=<span class="hljs-string">"changeit"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"RSA"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">SSLHostConfig</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span><br>    --&gt;<br><br>    <span class="hljs-comment">&lt;!-- AJP Connector 示例（注释）</span><br><span class="hljs-comment">         AJP（Apache JServ Protocol）常用于与前端服务器（如 Apache httpd 或早期的代理）通信。</span><br><span class="hljs-comment">         安全提醒：AJP 在过去存在配置不当导致远程代码执行的高危问题（如 Ghostcat），</span><br><span class="hljs-comment">         因此如果不使用最好禁用，或限制绑定地址为本地回环并做访问控制。</span><br><span class="hljs-comment">         常用属性：</span><br><span class="hljs-comment">           protocol="AJP/1.3"</span><br><span class="hljs-comment">           address: 绑定地址（可限制为 127.0.0.1 或 ::1）</span><br><span class="hljs-comment">           port: AJP 端口（默认 8009）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Connector protocol="AJP/1.3"</span><br><span class="hljs-comment">               address="::1"</span><br><span class="hljs-comment">               port="8009"</span><br><span class="hljs-comment">               redirectPort="8443" /&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Engine：Catalina 引擎，处理所有请求并根据 Host 分发</span><br><span class="hljs-comment">         常用属性：</span><br><span class="hljs-comment">           name: 引擎名字</span><br><span class="hljs-comment">           defaultHost: 默认虚拟主机（Host）的名字（当请求不匹配任何 Host 时使用）</span><br><span class="hljs-comment">           jvmRoute: 用于负载均衡和 session 粘滞（在使用 AJP / 负载均衡器时有用）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 说明：建议在使用集群或负载均衡时配置 jvmRoute（eg. jvm1、jvm2） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Engine</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span> <span class="hljs-attr">defaultHost</span>=<span class="hljs-string">"localhost"</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- Cluster（集群）配置示例（被注释）。如需启用会话复制等功能，可参考文档 --&gt;</span><br>      <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">      &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;</span><br><span class="hljs-comment">      --&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- Realm（身份认证与授权）配置：</span><br><span class="hljs-comment">           外层 LockOutRealm 用来保护内部 Realm，防暴力破解（如超过失败次数会锁定账户）。</span><br><span class="hljs-comment">           内层 UserDatabaseRealm 从全局 JNDI 的 UserDatabase（conf/tomcat-users.xml）读取用户/角色信息。</span><br><span class="hljs-comment">           常用 Realm 类型还有 JDBCRealm、DataSourceRealm、JNDIRealm 等（用于生产环境接 LDAP/DB）。</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Realm</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里的 UserDatabaseRealm 使用 GlobalNamingResources 中的 UserDatabase 资源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Realm</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">resourceName</span>=<span class="hljs-string">"UserDatabase"</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">Realm</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- Host：表示一个虚拟主机（virtual host）</span><br><span class="hljs-comment">           常用属性：</span><br><span class="hljs-comment">             name: 主机名（必须对应请求的 Host header 或者是 defaultHost）</span><br><span class="hljs-comment">             appBase: webapp 存放目录（相对于 CATALINA_BASE 或绝对路径）</span><br><span class="hljs-comment">             unpackWARs: 是否自动解压 war 包（true/false）</span><br><span class="hljs-comment">             autoDeploy: 是否在运行时自动扫描并部署 webapps（开发方便，生产通常禁用）</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"localhost"</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span></span><br><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- SingleSignOn Valve（注释）</span><br><span class="hljs-comment">             用途：在同一 Engine 内的多个 webapp 之间共享认证信息（登录一次，多个应用免登陆）。</span><br><span class="hljs-comment">             注意：使用 SSO 时需评估安全性与会话管理。</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- AccessLogValve：访问日志记录器</span><br><span class="hljs-comment">             常用属性：</span><br><span class="hljs-comment">               className: 实现类</span><br><span class="hljs-comment">               directory: 日志输出目录（相对于 CATALINA_BASE）</span><br><span class="hljs-comment">               prefix/suffix: 日志文件前后缀</span><br><span class="hljs-comment">               pattern: 日志格式（类似 Apache httpd 的格式，Tomcat 支持很多占位符）</span><br><span class="hljs-comment">             pattern 示例中：</span><br><span class="hljs-comment">               %h 客户端 IP</span><br><span class="hljs-comment">               %l 远程逻辑用户（通常为 -）</span><br><span class="hljs-comment">               %u 认证用户名</span><br><span class="hljs-comment">               %t 时间</span><br><span class="hljs-comment">               "%r" 请求第一行（方法与 URL 与 协议）</span><br><span class="hljs-comment">               %s 状态码</span><br><span class="hljs-comment">               %b 返回字节数</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">prefix</span>=<span class="hljs-string">"localhost_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b"</span> /&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="快速参考（链接）"><a href="#快速参考（链接）" class="headerlink" title="快速参考（链接）"></a>快速参考（链接）</h2><ul><li>Tomcat 官网（下载与文档）：<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></li><li>Which version（Tomcat 与 Java 对应表）：<a href="https://tomcat.apache.org/whichversion.html%E3%80%82">https://tomcat.apache.org/whichversion.html。</a> :contentReference[oaicite:11]{index=11}</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/posts/Maven/"/>
    <url>/posts/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>上文提到的Servlet包属于是外部依赖，我们在开发中往往需要引入很多这样的依赖，但是手动下载和引入是一件麻烦的事情，所以我们需要一个统一的包管理工具Maven，来帮助我们管理jar包和构建项目。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p>安装后解压，配置环境变量</p><p>与jdk配置环境变量的方式类似。</p><ol><li>高级系统设置</li><li>环境变量</li><li>示例：配置MAVEN_HOME  =  D:\Programs\apache-maven-3.9.9</li><li>配置path：新增：%MAVEN_HOME%\bin</li><li>点击确定</li></ol><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>打开<code>cmd</code>命令行，输入<code>mvn -version</code>如果出现版本号，那就是安装成功了。</p><p>配置镜像站在<a href="https://blog.csdn.net/m0_73804764/article/details/139898041">这里</a></p><h2 id="IDEA中配置MAVEN"><a href="#IDEA中配置MAVEN" class="headerlink" title="IDEA中配置MAVEN"></a>IDEA中配置MAVEN</h2><ol><li>打开设置（File - Settings）</li><li>找到maven（Build,Execution… - Build Tools - Maven）</li><li>配置maven路径、配置文件、本地仓库</li><li>安装Maven-Helper插件</li></ol><p>建议按照以下文件结构继续：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">src: 源代码<br>  -main：核心代码<br>    --java：java代码的位置<br>    --resources：资源，例如配置文件、图片等<br>  -test: 测试代码<br>    --java：测试相关java代码的位置<br>    --resources：测试相关资源，例如配置文件、图片等<br>pom.xml： 项目对象模型的配置文件。<br><br>External Libraries：用到的外部依赖<br></code></pre></td></tr></tbody></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>POM.xml是Maven的核心配置文件，修改POM.xml文件，Maven就会解析该文件并引入对应的包。</p><p>如，在<code>dependencies</code>标签中添加Servlet和hutool依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.35<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>随后点击<code>Dependency Analyer</code>—-<code>Reimport</code>引入我们需要的包。</p><p><a href="https://imgchr.com/i/pVLo9aj"><img src="https://s21.ax1x.com/2025/10/20/pVLo9aj.png" alt="pVLo9aj.png"></a></p><h1 id="使用Maven一键运行Tomcat项目"><a href="#使用Maven一键运行Tomcat项目" class="headerlink" title="使用Maven一键运行Tomcat项目"></a>使用Maven一键运行Tomcat项目</h1><h3 id="引入Tomcat依赖"><a href="#引入Tomcat依赖" class="headerlink" title="引入Tomcat依赖"></a>引入Tomcat依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">uriEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">uriEncoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>随后右键pom.xml,Run Maven ——- tomcat7:run</p><p>打开<a href="http://localhost:8080/(Html%E6%96%87%E4%BB%B6%E5%90%8D)%E6%9D%A5%E6%89%93%E5%BC%80%E9%A2%84%E8%A7%88%E7%95%8C%E9%9D%A2%E3%80%82">http://localhost:8080/(Html文件名)来打开预览界面。</a></p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/posts/Servlet/"/>
    <url>/posts/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet（Server Applet）是 <strong>Java Servlet</strong> 的简称，也叫“小型服务程序”或“服务连接器”。它是使用 <strong>Java</strong> 编写的服务器端组件，具有跨平台和与协议无关的特性。Servlet 主要用于在 Web 环境中进行交互式的数据处理与动态内容生成。</p><hr><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><ul><li><strong>狭义定义</strong>：Servlet 是 Java 中的一个接口。</li><li><strong>广义定义</strong>：Servlet 是任何实现了该接口的类。</li></ul><hr><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>Servlet 运行在 <strong>Java 应用服务器</strong> 中，例如 <strong>Tomcat</strong>。<br>它能够响应客户端请求，处理数据并动态生成网页内容，从而满足 Web 应用对动态页面的需求。</p><hr><h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><ol><li><strong>接收请求</strong><br>用户在浏览器中执行操作（如点击链接或提交表单），浏览器会向服务器发送请求。</li><li><strong>处理请求</strong><br>服务器接收到请求后，会根据请求路径将其分发给相应的 Servlet。<br>Servlet 容器（如 Tomcat）负责管理 Servlet 的整个生命周期，包括加载、初始化、请求处理和销毁。<br>Servlet 会从请求中读取数据，执行相应的业务逻辑，并生成响应内容。</li><li><strong>生成响应</strong><br>Servlet 通过 <code>HttpServletResponse</code> 对象将生成的内容（例如 HTML、JSON、XML 等）写入响应流。</li><li><strong>返回响应</strong><br>服务器将响应内容返回给客户端，浏览器最终展示结果页面。</li></ol><hr><h2 id="四、生命周期"><a href="#四、生命周期" class="headerlink" title="四、生命周期"></a>四、生命周期</h2><p>Servlet 的生命周期是从 <strong>创建到销毁</strong> 的完整过程，由 <strong>Servlet 容器</strong> 全权管理。其主要阶段如下：</p><ol><li><strong>加载与实例化</strong><br>当服务器启动或首次访问某个 Servlet 时，容器会加载其类并创建实例。<br>此过程只执行一次，一个 Servlet 实例可以同时处理多个请求。</li><li><strong>初始化（init）</strong><br>实例创建后，容器调用 <code>init()</code> 方法完成初始化工作。<br>通常用于读取配置、连接数据库或加载资源。<br><code>init()</code> 方法在整个生命周期中只执行一次。</li><li><strong>请求处理（service）</strong><br>每当有新的请求到达时，容器会调用 <code>service()</code> 方法。<br>该方法会根据请求类型（GET、POST 等）自动分发到 <code>doGet()</code>、<code>doPost()</code> 等具体处理方法。<br>这一步会被多次调用，用于实际的业务处理。</li><li><strong>销毁（destroy）</strong><br>当服务器关闭或容器需要释放资源时，会调用 <code>destroy()</code> 方法销毁 Servlet 实例。<br>通常用于关闭连接、释放资源或执行清理操作。</li></ol><hr><h2 id="五、相关说明"><a href="#五、相关说明" class="headerlink" title="五、相关说明"></a>五、相关说明</h2><p>在 Tomcat 的安装目录中，可以找到 <code>servlet-api.jar</code> 文件。<br>该文件包含了 Servlet 的接口定义，是 Web 开发中必不可少的外部依赖库。</p><hr><p><img src="https://s21.ax1x.com/2025/10/20/pVLI2P1.png" alt="Servlet"></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Servlet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/posts/Nginx/"/>
    <url>/posts/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>nginx是高性能HTTP服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。它具有并发处理能力强、内存占用少、运行稳定等特点，并支持跨平台运行，如Linux和Windows。</p><p>它能够运行静态网页，包括本博客就是用Nginx运行的。</p><p><img src="https://s2.loli.net/2025/10/20/LWxGM9l5XQwE73B.png" alt="image-20251020111026989"></p><h1 id="安装地址："><a href="#安装地址：" class="headerlink" title="安装地址："></a>安装地址：</h1><p><a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><p>解压后双击Nginx.exe启动</p><p><img src="https://s2.loli.net/2025/10/20/GvJUV7w8dehOYqE.png" alt="image-20251020111725464"></p><p>html文件夹下放html文件，就可以展示对应界面。</p><p>本地预览地址是<a href="http://localhost/(html%E6%96%87%E4%BB%B6%E5%90%8D)">http://localhost:80/(html文件名)</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置文件在/nginx/conf/nginx.conf</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 定义运行Nginx进程的用户和用户组，默认nobody（所有用户可运行）</span><br><span class="hljs-comment">#user  nobody;</span><br><br><span class="hljs-comment"># 设置工作进程数量（通常等于CPU核心数或auto自动检测）</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment"># 错误日志配置（可设置不同级别：debug|info|notice|warn|error|crit）</span><br><span class="hljs-comment">#error_log  logs/error.log;           # 默认错误日志</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;  # 通知级别日志</span><br><span class="hljs-comment">#error_log  logs/error.log  info;     # 信息级别日志（最详细）</span><br><br><span class="hljs-comment"># 进程ID存储文件路径</span><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><span class="hljs-comment"># 事件处理模块配置</span><br><span class="hljs-section">events</span> {<br>    <span class="hljs-comment"># 单个工作进程的最大并发连接数（总并发= worker_processes * worker_connections）</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>}<br><br><span class="hljs-comment"># HTTP服务器核心配置块</span><br><span class="hljs-section">http</span> {<br>    <span class="hljs-comment"># 引入MIME类型映射文件（定义文件扩展名与Content-Type的对应关系）</span><br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <br>    <span class="hljs-comment"># 默认MIME类型（当无法识别文件类型时使用application/octet-stream）</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment"># 定义日志格式模板（main为格式名称）</span><br>    <span class="hljs-comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br>    <span class="hljs-comment">#                  '$status $body_bytes_sent "$http_referer" '</span><br>    <span class="hljs-comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><br>    <span class="hljs-comment"># 访问日志设置（使用main格式，路径为logs/access.log）</span><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-comment"># 开启高效文件传输模式（零拷贝技术，提升静态文件传输性能）</span><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <br>    <span class="hljs-comment"># 在sendfile模式下，将数据包累积到一定大小再发送（提升网络效率）</span><br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment"># 连接超时时间设置（0表示禁用长连接）</span><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;  <span class="hljs-comment"># 长连接超时时间（秒）</span><br><br>    <span class="hljs-comment"># Gzip压缩开关（开启可减少传输数据量，但增加CPU开销）</span><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-comment"># 虚拟主机配置（一个server块代表一个虚拟主机）</span><br>    <span class="hljs-section">server</span> {<br>        <span class="hljs-comment"># 监听端口（可指定IP:端口，如listen 127.0.0.1:80）</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <br>        <span class="hljs-comment"># 服务器名称（支持域名、通配符、正则匹配，多个用空格分隔）</span><br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-comment"># 字符集设置（默认使用系统字符集，可设置为koi8-r、utf-8等）</span><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment"># 本虚拟主机的访问日志（可覆盖http块中的全局设置）</span><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br><br>        <span class="hljs-comment"># 位置块配置：匹配所有以/开头的请求</span><br>        <span class="hljs-section">location</span> / {<br>            <span class="hljs-comment"># 设置请求的根目录（相对路径基于nginx安装目录）</span><br>            <span class="hljs-attribute">root</span>   html;<br>            <br>            <span class="hljs-comment"># 设置默认索引文件（按从左到右优先级查找）</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        }<br><br>        <span class="hljs-comment"># 自定义错误页面（当出现404错误时返回/404.html）</span><br>        <span class="hljs-comment">#error_page  404              /404.html;</span><br><br>        <span class="hljs-comment"># 重定向服务器错误页到静态页面/50x.html</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <br>        <span class="hljs-comment"># 精确匹配路径/50x.html（=表示精确匹配，优先级最高）</span><br>        <span class="hljs-section">location</span> = /50x.html {<br>            <span class="hljs-attribute">root</span>   html;  <span class="hljs-comment"># 错误页面所在目录</span><br>        }<br><br>        <span class="hljs-comment"># PHP脚本代理到Apache（示例配置，需要取消注释并修改）</span><br>        <span class="hljs-comment">#location ~ \.php$ {</span><br>        <span class="hljs-comment">#    proxy_pass   http://127.0.0.1;  # 转发到本机Apache</span><br>        <span class="hljs-comment">#}</span><br><br>        <span class="hljs-comment"># PHP脚本通过FastCGI处理（需要PHP-FPM服务运行在9000端口）</span><br>        <span class="hljs-comment">#location ~ \.php$ {</span><br>        <span class="hljs-comment">#    root           html;</span><br>        <span class="hljs-comment">#    fastcgi_pass   127.0.0.1:9000;  # PHP-FPM地址</span><br>        <span class="hljs-comment">#    fastcgi_index  index.php;</span><br>        <span class="hljs-comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>        <span class="hljs-comment">#    include        fastcgi_params;   # 引入FastCGI参数文件</span><br>        <span class="hljs-comment">#}</span><br><br>        <span class="hljs-comment"># 禁止访问.htaccess文件（Apache配置文件，增强安全性）</span><br>        <span class="hljs-comment">#location ~ /\.ht {</span><br>        <span class="hljs-comment">#    deny  all;  # 拒绝所有访问</span><br>        <span class="hljs-comment">#}</span><br>    }<br><br>    <span class="hljs-comment"># 另一个虚拟主机示例（基于IP、域名和端口的混合配置）</span><br>    <span class="hljs-comment">#server {</span><br>    <span class="hljs-comment">#    listen       8000;                   # 监听8000端口</span><br>    <span class="hljs-comment">#    listen       somename:8080;          # 监听8080端口并指定主机名</span><br>    <span class="hljs-comment">#    server_name  somename  alias  another.alias;  # 多域名配置</span><br>    <br>    <span class="hljs-comment">#    location / {</span><br>    <span class="hljs-comment">#        root   html;</span><br>    <span class="hljs-comment">#        index  index.html index.htm;</span><br>    <span class="hljs-comment">#    }</span><br>    <span class="hljs-comment">#}</span><br><br>    <span class="hljs-comment"># HTTPS服务器配置示例（需要SSL证书）</span><br>    <span class="hljs-comment">#server {</span><br>    <span class="hljs-comment">#    listen       443 ssl;                # 监听443端口并启用SSL</span><br>    <span class="hljs-comment">#    server_name  localhost;</span><br>    <br>    <span class="hljs-comment">#    # SSL证书文件路径（需替换为实际证书）</span><br>    <span class="hljs-comment">#    ssl_certificate      cert.pem;</span><br>    <span class="hljs-comment">#    ssl_certificate_key  cert.key;</span><br>    <br>    <span class="hljs-comment">#    # SSL会话缓存设置（shared表示多个工作进程共享缓存）</span><br>    <span class="hljs-comment">#    ssl_session_cache    shared:SSL:1m;</span><br>    <span class="hljs-comment">#    ssl_session_timeout  5m;              # 会话超时时间</span><br>    <br>    <span class="hljs-comment">#    # 加密套件配置（禁用弱算法增强安全性）</span><br>    <span class="hljs-comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br>    <span class="hljs-comment">#    ssl_prefer_server_ciphers  on;        # 优先使用服务器端加密套件</span><br>    <br>    <span class="hljs-comment">#    location / {</span><br>    <span class="hljs-comment">#        root   html;</span><br>    <span class="hljs-comment">#        index  index.html index.htm;</span><br>    <span class="hljs-comment">#    }</span><br>    <span class="hljs-comment">#}</span><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/posts/JSON/"/>
    <url>/posts/JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h1><p><strong>JSON（JavaScript Object Notation）</strong> 是一种轻量级、文本性的数据交换格式，便于人阅读与编写，也易于机器解析和生成。尽管起源于 JavaScript 的语法子集，JSON 已成为与语言无关的通用数据格式，广泛被各种编程语言支持。</p><hr><h2 id="1-简介-——-什么是-JSON？"><a href="#1-简介-——-什么是-JSON？" class="headerlink" title="1. 简介 —— 什么是 JSON？"></a>1. 简介 —— 什么是 JSON？</h2><p>JSON 用键值对（key–value）来表示结构化数据，支持嵌套对象与数组，从而能够描述复杂的数据结构。它常用于前后端交互、配置文件和轻量级数据存储。</p><hr><h2 id="2-JSON-的主要特点"><a href="#2-JSON-的主要特点" class="headerlink" title="2. JSON 的主要特点"></a>2. JSON 的主要特点</h2><ul><li><strong>可读性高</strong>：采用清晰的文本表示，结构直观。</li><li><strong>易于编写</strong>：语法简单，不需要复杂标记。</li><li><strong>易于解析</strong>：多数语言提供标准库或第三方库用于解析/生成。</li><li><strong>轻量级</strong>：相较于 XML 等格式更为紧凑，传输效率高。</li></ul><hr><h2 id="3-基本结构"><a href="#3-基本结构" class="headerlink" title="3. 基本结构"></a>3. 基本结构</h2><p>JSON 有两种顶级结构：<strong>对象（Object）</strong> 和 <strong>数组（Array）</strong>。</p><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>对象由若干键值对组成，使用大括号 <code>{}</code> 包围，键必须是字符串（双引号），值可以是字符串、数字、布尔值、<code>null</code>、对象或数组。</p><p>示例：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"张三"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"isStudent"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"address"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"city"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"北京"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"street"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"长安街"</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><p>数组由一系列值组成，使用中括号 <code>[]</code> 包围，元素之间用逗号分隔。数组元素类型可以混合（字符串、数字、对象等）。</p><p>示例：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-string">"苹果"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">"香蕉"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"橙子"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"color"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"橙色"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">3.14</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="4-语法规则要点"><a href="#4-语法规则要点" class="headerlink" title="4. 语法规则要点"></a>4. 语法规则要点</h2><ol><li><strong>键名（Key）</strong>：必须是字符串，<strong>必须</strong>用双引号 <code>"</code> 包围。</li><li><strong>值（Value）</strong>：可以是：<ul><li>字符串（双引号）</li><li>数字（整数或浮点数）</li><li>布尔值：<code>true</code> / <code>false</code></li><li><code>null</code></li><li>对象（嵌套 <code>{}</code>）</li><li>数组（<code>[]</code>）</li></ul></li><li><strong>分隔符</strong>：对象的键值对与数组元素之间用逗号 <code>,</code> 分隔；最后一项后不能有多余的逗号（严格 JSON 不允许尾随逗号）。</li><li><strong>字符串转义</strong>：特殊字符需用反斜杠 <code>\</code> 转义，例如：<code>\n</code>（换行）、<code>\t</code>（制表）、<code>\"</code>（双引号）、<code>\\</code>（反斜杠）等。</li></ol><hr><h2 id="5-常见用途"><a href="#5-常见用途" class="headerlink" title="5. 常见用途"></a>5. 常见用途</h2><ul><li><strong>前后端数据交换</strong>：浏览器通过 AJAX / fetch 获取后端返回的 JSON 数据，然后转换为对象进行处理。</li><li><strong>配置文件</strong>：许多工具和库使用 JSON 作为配置文件格式（可读、可编辑）。</li><li><strong>数据存储</strong>：NoSQL 数据库（如 MongoDB）使用 JSON 风格的文档存储数据。</li><li><strong>日志与接口标准</strong>：在微服务与接口设计中，JSON 常用作请求/响应的标准格式。</li></ul><hr><h2 id="6-解析与生成（示例）"><a href="#6-解析与生成（示例）" class="headerlink" title="6. 解析与生成（示例）"></a>6. 解析与生成（示例）</h2><p>不同语言通常都有内置或常用库进行 JSON 操作。</p><ul><li><p><strong>JavaScript</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonString);      <span class="hljs-comment">// 将 JSON 字符串解析为对象/数组</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);         <span class="hljs-comment">// 将对象/数组转换为 JSON 字符串</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>Python</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>obj = json.loads(json_string)            <span class="hljs-comment"># 解析</span><br>s = json.dumps(obj, ensure_ascii=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 生成（ensure_ascii=False 保持中文）</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>Java（示例库）</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Gson</span><br><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> gson.fromJson(jsonString, MyClass.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> gson.toJson(obj);<br></code></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="7-注意事项与最佳实践"><a href="#7-注意事项与最佳实践" class="headerlink" title="7. 注意事项与最佳实践"></a>7. 注意事项与最佳实践</h2><ul><li><strong>键名唯一</strong>：同一对象中不要重复使用相同键名（行为未定义或后者覆盖前者）。</li><li><strong>类型明确</strong>：注意区分字符串和数字，避免将数字写成带引号的字符串（除非确有需要）。</li><li><strong>不要有尾随逗号</strong>：严格 JSON 禁止最后一项后多余逗号，例如 <code>{ "a": 1, }</code> 是非法的。</li><li><strong>字符编码</strong>：一般使用 UTF-8 编码，处理中文时注意编码一致性。</li><li><strong>安全性</strong>：处理来自不可信来源的 JSON 时，注意避免注入或反序列化漏洞；不要将 <code>eval</code> 用于解析 JSON。</li><li><strong>合理的结构设计</strong>：为接口或配置设计清晰、扁平或层次分明的结构，便于维护与演进。</li></ul><hr><h2 id="8-常见错误示例（便于排查）"><a href="#8-常见错误示例（便于排查）" class="headerlink" title="8. 常见错误示例（便于排查）"></a>8. 常见错误示例（便于排查）</h2><ul><li><p>使用单引号代替双引号（非法）：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span> 'name'<span class="hljs-punctuation">:</span> '张三' <span class="hljs-punctuation">}</span>   <span class="hljs-comment">// 错误：键与字符串必须用双引号</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>尾随逗号（非法）：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">}</span>         <span class="hljs-comment">// 错误：最后不能有逗号</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>未转义特殊字符（可能导致解析失败）：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"text"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"第一行</span><br><span class="hljs-string">第二行"</span> <span class="hljs-punctuation">}</span>           <span class="hljs-comment">// 错误：换行应使用 \n 转义</span><br></code></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p>JSON 是一种简洁、通用的数据交换格式，适合绝大多数前后端通信与轻量级数据存储场景。掌握其基本语法（字符串需双引号、无尾逗号、类型与转义）和常用解析/生成方法，可以在绝大多数开发任务中提高效率与互操作性。</p><hr>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML</title>
    <link href="/posts/XML/"/>
    <url>/posts/XML/</url>
    
    <content type="html"><![CDATA[<h1 id="XML（可扩展标记语言）"><a href="#XML（可扩展标记语言）" class="headerlink" title="XML（可扩展标记语言）"></a>XML（可扩展标记语言）</h1><p>XML（Extensible Markup Language，可扩展标记语言）是一种用于<strong>存储和传输数据</strong>的标记语言。<br>与 HTML 不同，XML 的标签不是预定义的，而是由用户自定义的，这使得 XML 非常适合于各种应用，如数据存储、配置文件、网络传输等。</p><hr><h2 id="一、XML-简介"><a href="#一、XML-简介" class="headerlink" title="一、XML 简介"></a>一、XML 简介</h2><h3 id="什么是-XML？"><a href="#什么是-XML？" class="headerlink" title="什么是 XML？"></a>什么是 XML？</h3><p>XML 是一种标记语言，用于描述数据。它允许用户定义自己的标签来存储信息。</p><h3 id="XML-的特点："><a href="#XML-的特点：" class="headerlink" title="XML 的特点："></a>XML 的特点：</h3><ul><li><strong>自描述性</strong>：标签描述了数据的含义。</li><li><strong>平台无关性</strong>：XML 文件可以在任何操作系统和平台上使用。</li><li><strong>数据驱动</strong>：XML 关注数据本身，而不是显示格式。</li><li><strong>易于扩展</strong>：用户可以定义自己的标签。</li></ul><hr><h2 id="二、XML-文档结构"><a href="#二、XML-文档结构" class="headerlink" title="二、XML 文档结构"></a>二、XML 文档结构</h2><p>一个基本的 XML 文档示例如下：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>````<br><br>**结构说明：**<br><br>* **XML 声明**：`<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>` 指定了 XML 的版本和字符编码。<br>* **根元素**：`<span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>` 是根元素，所有其他元素都嵌套在其中。<br>* **子元素**：`<span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>` 是根元素 `<span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>` 的子元素。<br><br>---<br><br>## 三、XML 语法规则<br><br>1. **所有标签都必须有闭合：**<br><br>   ```xml<br>   <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>   自闭合标签（空元素）：</p>   <figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tag</span> /&gt;</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><p><strong>标签名称区分大小写：</strong><br><code>&lt;Note&gt;</code> 和 <code>&lt;note&gt;</code> 是不同的标签。</p></li><li><p><strong>属性值必须用引号括起来：</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"John Doe"</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"30"</span>/&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>元素必须正确嵌套：</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">outer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">inner</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">inner</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">outer</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>特殊字符需要使用实体引用：</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;  表示小于号 <span class="hljs-comment">(&lt;)</span><br>&gt;  表示大于号 <span class="hljs-comment">(&gt;)</span><br>&amp; 表示和号 <span class="hljs-comment">(&amp;)</span><br><span class="hljs-string">' 表示单引号 ('</span>)<br><span class="hljs-string">" 表示双引号 ("</span>)<br></code></pre></td></tr></tbody></table></figure></li></ol><hr><h2 id="四、XML-元素和属性"><a href="#四、XML-元素和属性" class="headerlink" title="四、XML 元素和属性"></a>四、XML 元素和属性</h2><h3 id="元素（Element）"><a href="#元素（Element）" class="headerlink" title="元素（Element）"></a>元素（Element）</h3><p>元素是 XML 文档的基本构建块，由<strong>开始标签、内容、结束标签</strong>组成。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XML教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h3><p>属性提供元素的额外信息，放在开始标签内。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">"编程"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XML教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="五、注释与-CDATA-区"><a href="#五、注释与-CDATA-区" class="headerlink" title="五、注释与 CDATA 区"></a>五、注释与 CDATA 区</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>XML 中的注释以 <code>&lt;!--</code> 开始，以 <code>--&gt;</code> 结束。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="CDATA-区"><a href="#CDATA-区" class="headerlink" title="CDATA 区"></a>CDATA 区</h3><p>CDATA 区用于在 XML 文件中包含<strong>不被解析器解析的文本数据</strong>。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>&lt;![CDATA[这是一个包含&lt;特殊字符&gt;的文本]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="六、XML-Schema（XSD）"><a href="#六、XML-Schema（XSD）" class="headerlink" title="六、XML Schema（XSD）"></a>六、XML Schema（XSD）</h2><p>XML Schema 用于定义 XML 文档的结构和数据类型。</p><h3 id="示例-XSD-文件："><a href="#示例-XSD-文件：" class="headerlink" title="示例 XSD 文件："></a>示例 XSD 文件：</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xs:schema</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"book"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">xs:complexType</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">xs:sequence</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">xs:sequence</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">xs:complexType</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xs:element</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xs:schema</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="关联-XML-与-XSD："><a href="#关联-XML-与-XSD：" class="headerlink" title="关联 XML 与 XSD："></a>关联 XML 与 XSD：</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">"book.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XML教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="七、XML-解析方式"><a href="#七、XML-解析方式" class="headerlink" title="七、XML 解析方式"></a>七、XML 解析方式</h2><p>XML 解析器用于读取和分析 XML 文档。常见的解析方式包括：</p><ul><li><strong>DOM（Document Object Model）</strong>：将整个文档加载到内存中，形成一个树形结构，方便操作但占内存大。</li><li><strong>SAX（Simple API for XML）</strong>：逐行读取文档，事件驱动，适合处理大型文档。</li><li><strong>StAX（Streaming API for XML）</strong>：基于 Java 的流式 API，适合高效地处理大型 XML 文档。</li></ul><hr><p><strong>总结：</strong><br>XML 是一种高度灵活的数据表示语言，适用于跨平台的数据交换和存储。<br>它不关注展示，而是注重结构与意义，常用于配置文件、网络通信、Web 服务（如 SOAP）和数据存储。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程</title>
    <link href="/posts/Java_Thread/"/>
    <url>/posts/Java_Thread/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA线程"><a href="#JAVA线程" class="headerlink" title="JAVA线程"></a>JAVA线程</h1><h2 id="一、多线程基础"><a href="#一、多线程基础" class="headerlink" title="一、多线程基础"></a>一、多线程基础</h2><p><strong>进程</strong>是操作系统分配资源的最小单元，<strong>线程</strong>是操作系统调度的最小单元。一个进程中可以包含多个线程，这些线程共享进程的资源。</p><p><strong>并发</strong>是指处理器通过<strong>时间片轮转</strong>等方式，在宏观上同时处理多个任务，但微观上这些任务实际上是交替执行的。<strong>并行</strong>则是指多个处理器核心真正地同时执行多个任务。在多核CPU架构下，多线程不仅能提高程序响应速度（将耗时操作放入后台线程），还能充分利用多核计算能力。</p><p>WIN系统（以及所有现代操作系统）实现多线程确实采用了<strong>时间片轮转</strong>的调度机制。即使在单核CPU上，也可以通过快速切换执行不同的线程，给人“同时”进行的错觉。在多核CPU上，多个线程可以真正并行执行。</p><h2 id="二、创建线程的方式"><a href="#二、创建线程的方式" class="headerlink" title="二、创建线程的方式"></a>二、创建线程的方式</h2><p>多线程的具体表现形式如下，你执行后就能够发现主线程和输出abc的线程是齐头并进的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mythread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>{  <span class="hljs-comment">//继承线程Thread公共类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>    {<br>        System.out.println(<span class="hljs-string">"abc"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Th</span>{<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Mythread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mythread</span>();<br>        t.start ();<br>        System.out.println(<span class="hljs-string">"1"</span>);<br>        System.out.println(<span class="hljs-string">"2"</span>);<br>        System.out.println(<span class="hljs-string">"3"</span>);<br>        System.out.println(<span class="hljs-string">"4"</span>);<br>    }<br><br>    <br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h3><p>通过继承<code>Thread</code>类并重写<code>run</code>方法（该方法为线程的入口点）来创建线程。调用<code>start()</code>方法（而非直接调用<code>run</code>方法）来启动线程，<code>start()</code>方法会启动一个新的执行线程并调用<code>run</code>方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> { <span class="hljs-comment">// 继承Thread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 重写run方法</span><br>        System.out.println(<span class="hljs-string">"MyThread is running"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start(); <span class="hljs-comment">// 启动线程，最终由JVM调用run方法</span><br>        System.out.println(<span class="hljs-string">"Main thread"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：直接调用<code>run()</code>方法只会像普通方法一样在当前线程执行，而不会启动新线程。</p><h3 id="2-实现Runnable接口（推荐）"><a href="#2-实现Runnable接口（推荐）" class="headerlink" title="2. 实现Runnable接口（推荐）"></a>2. 实现Runnable接口（推荐）</h3><p>实现<code>Runnable</code>接口的类并非线程类，而是<strong>任务类</strong>。需要将<code>Runnable</code>实例作为参数传递给<code>Thread</code>构造函数来创建线程。这种方式更灵活，避免了单继承的限制，也更符合面向对象的思想。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> { <span class="hljs-comment">// 实现Runnable接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"MyRunnable is running"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task); <span class="hljs-comment">// 将Runnable任务传递给Thread构造函数</span><br>        t.start();<br>        System.out.println(<span class="hljs-string">"Main thread"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="三、线程的状态与生命周期"><a href="#三、线程的状态与生命周期" class="headerlink" title="三、线程的状态与生命周期"></a>三、线程的状态与生命周期</h2><p>Java线程在其生命周期中可能处于以下几种状态（定义在<code>Thread.State</code>枚举中）：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><strong>NEW</strong> (新建)</td><td>线程被创建但尚未调用<code>start()</code>方法</td></tr><tr><td><strong>RUNNABLE</strong> (可运行)</td><td>调用<code>start()</code>后，线程正在JVM中执行或等待系统资源（如CPU）</td></tr><tr><td><strong>BLOCKED</strong> (阻塞)</td><td>线程被阻塞，等待获取<strong>监视器锁</strong>（如进入<code>synchronized</code>块）</td></tr><tr><td><strong>WAITING</strong> (等待)</td><td>线程进入等待状态，需要其他线程显式唤醒（如<code>Object.wait()</code>）</td></tr><tr><td><strong>TIMED_WAITING</strong> (超时等待)</td><td>线程在指定的时间内等待（如<code>Thread.sleep(time)</code>）</td></tr><tr><td><strong>TERMINATED</strong> (终止)</td><td>线程已执行完毕（<code>run()</code>方法完成）</td></tr></tbody></table><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">stateDiagram-v2<br>    direction LR<br>    [*] --&gt; NEW<br>    NEW --&gt; RUNNABLE : start()<br>    RUNNABLE --&gt; TERMINATED : run()方法执行完毕<br>    <br>    RUNNABLE --&gt; BLOCKED : 等待进入<span class="hljs-keyword">synchronized</span>块/方法<br>    BLOCKED --&gt; RUNNABLE : 获取到锁<br>    <br>    RUNNABLE --&gt; WAITING : Object.wait()&lt;br/&gt;Thread.join()（无参）<br>    WAITING --&gt; RUNNABLE : Object.notify()/notifyAll()<br>    <br>    RUNNABLE --&gt; TIMED_WAITING : Thread.sleep(time)&lt;br/&gt;Object.wait(timeout)&lt;br/&gt;Thread.join(timeout)<br>    TIMED_WAITING --&gt; RUNNABLE : 超时/被中断/被唤醒<br></code></pre></td></tr></tbody></table></figure><h2 id="四、线程同步"><a href="#四、线程同步" class="headerlink" title="四、线程同步"></a>四、线程同步</h2><p>当多个线程访问<strong>共享资源</strong>时，可能会发生<strong>数据竞争</strong>（Data Race），导致数据不一致或其他不可预料的错误。Java提供了多种机制来保证线程安全。</p><h3 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h3><p><code>synchronized</code>是Java中最基本的同步机制，它可以同步<strong>代码块</strong>或<strong>方法</strong>。</p><ul><li><strong>同步代码块</strong>：需要显式指定一个对象作为<strong>锁</strong>。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">synchronized</span> (lockObject) { <span class="hljs-comment">// lockObject可以是任意对象，但所有线程必须共享同一个锁对象才有效</span><br>        <span class="hljs-comment">// 需要同步的代码</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>同步实例方法</strong>：锁是<strong>当前实例对象</strong>（<code>this</code>）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 方法体</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>同步静态方法</strong>：锁是<strong>当前类的Class对象</strong>（如<code>MyClass.class</code>）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>     <span class="hljs-comment">// 方法体</span><br> }<br></code></pre></td></tr></tbody></table></figure><h3 id="2-Lock-接口"><a href="#2-Lock-接口" class="headerlink" title="2. Lock 接口"></a>2. Lock 接口</h3><p>从Java 5开始，提供了<code>java.util.concurrent.locks.Lock</code>接口（如<code>ReentrantLock</code>），它提供了比<code>synchronized</code>更灵活的锁操作，如尝试非阻塞获取锁、可中断的获取锁以及超时获取锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> {<br>            count++;<br>        } <span class="hljs-keyword">finally</span> {<br>            lock.unlock(); <span class="hljs-comment">// 必须在finally块中释放锁，防止异常导致死锁</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>synchronized 与 Lock 的对比</strong></p><table><thead><tr><th>特性</th><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td><strong>实现级别</strong></td><td>JVM层面，原生语法</td><td>Java API层面</td></tr><tr><td><strong>锁的释放</strong></td><td>自动释放</td><td>必须手动调用<code>unlock()</code></td></tr><tr><td><strong>灵活性</strong></td><td>相对简单，不灵活</td><td>非常灵活，支持多种获取锁的方式</td></tr><tr><td><strong>性能</strong></td><td>早期性能较差，后续版本有优化</td><td>在高竞争环境下性能可能更好</td></tr><tr><td><strong>读写分离</strong></td><td>不支持</td><td>支持（<code>ReadWriteLock</code>）</td></tr></tbody></table><h2 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h2><p>线程间通信主要依靠<strong>等待/通知机制</strong>，核心方法是<code>Object</code>类的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>。<strong>这些方法必须在<code>synchronized</code>同步块或同步方法内调用</strong>，否则会抛出<code>IllegalMonitorStateException</code>异常。</p><ul><li><code>wait()</code>：使当前线程<strong>释放锁</strong>并进入等待（WAITING）状态，直到其他线程调用该对象的<code>notify()</code>或<code>notifyAll()</code>方法。</li><li><code>notify()</code>：随机唤醒一个在该对象上等待的线程。</li><li><code>notifyAll()</code>：唤醒所有在该对象上等待的线程。</li></ul><p>一个典型的生产者-消费者模型示例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumerExample</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Integer&gt; buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-keyword">synchronized</span> (lock) {<br>                <span class="hljs-keyword">while</span> (buffer.size() == CAPACITY) { <span class="hljs-comment">// 缓冲区满，生产者等待</span><br>                    lock.wait();<br>                }<br>                buffer.add(value++);<br>                System.out.println(<span class="hljs-string">"Produced: "</span> + value);<br>                lock.notifyAll(); <span class="hljs-comment">// 通知消费者可以消费了</span><br>            }<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟生产过程耗时</span><br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-keyword">synchronized</span> (lock) {<br>                <span class="hljs-keyword">while</span> (buffer.isEmpty()) { <span class="hljs-comment">// 缓冲区空，消费者等待</span><br>                    lock.wait();<br>                }<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> buffer.removeFirst();<br>                System.out.println(<span class="hljs-string">"Consumed: "</span> + value);<br>                lock.notifyAll(); <span class="hljs-comment">// 通知生产者可以生产了</span><br>            }<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟消费过程耗时</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="六、线程死锁"><a href="#六、线程死锁" class="headerlink" title="六、线程死锁"></a>六、线程死锁</h2><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因<strong>争夺资源</strong>而造成的一种<strong>互相等待</strong>的现象，若无外力干涉，这些线程都将无法继续执行下去</p><p>死锁产生的四个必要条件（缺一不可）：</p><p><strong>互斥条件</strong>：一个资源每次只能被一个线程使用。</p><p><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能被其他线程强行剥夺。</p><p><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</p><p><strong>避免死锁的常见方法</strong>：</p><p><strong>避免嵌套锁</strong>：尽量只获取一个锁。如果必须多个，确保所有线程以<strong>相同的顺序</strong>获取锁。</p><p><strong>使用定时锁</strong>：使用<code>Lock</code>接口的<code>tryLock(long time, TimeUnit unit)</code>方法，尝试获取锁超时则失败。</p><p><strong>减少同步范围</strong>：减小临界区范围，尽快释放锁。</p><h2 id="七、线程控制（补充）"><a href="#七、线程控制（补充）" class="headerlink" title="七、线程控制（补充）"></a>七、线程控制（补充）</h2><p><strong><code>join()</code>方法</strong>：等待目标线程执行完毕，当前线程才继续执行。可用于线程间同步。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {<br>    <span class="hljs-comment">// 一些操作</span><br>});<br>t.start();<br>t.join(); <span class="hljs-comment">// 主线程在此等待线程t执行完毕</span><br>System.out.println(<span class="hljs-string">"Thread t has finished."</span>);<br></code></pre></td></tr></tbody></table></figure><p><strong><code>sleep()</code>方法</strong>：让当前正在执行的线程<strong>休眠</strong>（暂停执行）指定的时间，但<strong>不会释放锁</strong>。</p><p><strong><code>yield()</code>方法</strong>：提示调度器当前线程愿意让出CPU，但调度器可以忽略这个提示。</p><p><strong><code>interrupt()</code>方法</strong>：中断目标线程。如果目标线程因<code>wait</code>, <code>sleep</code>, <code>join</code>而阻塞，会抛出<code>InterruptedException</code>并清除中断状态；否则，只是设置一个中断标志位，需要线程自己检查（<code>isInterrupted()</code>）并处理</p><p><strong>注意</strong>：<code>suspend()</code>, <code>resume()</code>, <code>stop()</code>等方法已被废弃，因为它们可能导致资源死锁和数据不一致，非常不安全。</p><h2 id="八、线程池"><a href="#八、线程池" class="headerlink" title="八、线程池"></a>八、线程池</h2><p>频繁创建和销毁线程开销很大。<strong>线程池</strong>可以预先创建一定数量的线程，放入池中备用。有任务时，从池中取线程执行；任务完成后，线程返回池中复用。这减少了创建销毁的开销，可以控制并发数，更有效地管理线程。</p><p>Java通过<code>java.util.concurrent.ExecutorService</code>接口及其实现类（如<code>ThreadPoolExecutor</code>）来提供线程池功能。通常使用<code>Executors</code>工具类来创建常见的线程池：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 创建一个固定大小的线程池（包含4个线程）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 提交任务给线程池执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; {<br>                System.out.println(<span class="hljs-string">"Executing task "</span> + taskId + <span class="hljs-string">" via "</span> + Thread.currentThread().getName());<br>            });<br>        }<br><br>        <span class="hljs-comment">// 关闭线程池（不再接受新任务，等待所有已提交任务完成）</span><br>        executor.shutdown();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java流</title>
    <link href="/posts/Java_Stream/"/>
    <url>/posts/Java_Stream/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA流"><a href="#JAVA流" class="headerlink" title="JAVA流"></a>JAVA流</h1><h2 id="流的基本概念"><a href="#流的基本概念" class="headerlink" title="流的基本概念"></a>流的基本概念</h2><p>流（Stream）在Java中是对<strong>数据序列的抽象</strong>，用于处理输入输出（I/O）操作。它代表了从一个源（如文件、网络套接字、内存缓冲区）到另一个目的地的数据流动。流不是特指网络套接字，而是涵盖了所有I/O操作，包括文件、控制台、网络等。</p><p>在计算机体系中，数据在磁盘、内存和CPU之间流动时，流充当了桥梁角色。但更准确地说，流操作通常涉及：</p><ul><li><strong>源</strong>（如磁盘文件）→ <strong>内存</strong>（缓冲区）→ <strong>程序（CPU处理）</strong></li><li><strong>程序</strong> → <strong>内存</strong>（缓冲区）→ <strong>目的</strong>（如磁盘文件）</li></ul><p>常见的流包括：</p><ul><li><strong>标准输入/输出流</strong>：<code>System.in</code>（标准输入），<code>System.out</code>（标准输出），<code>System.err</code>（标准错误输出）。例如 <code>System.out.println</code>使用了标准输出流。</li><li><strong>文件流</strong>：用于读写文件，如 <code>FileInputStream</code>, <code>FileOutputStream</code>, <code>FileReader</code>, <code>FileWriter</code>。</li><li><strong>缓冲流</strong>：在基础流之上增加缓冲功能，提高效率，如 <code>BufferedReader</code>, <code>BufferedWriter</code>。</li><li><strong>数据流</strong>：用于读写基本数据类型，如 <code>DataInputStream</code>, <code>DataOutputStream</code>。</li><li><strong>对象流</strong>：用于序列化对象，如 <code>ObjectInputStream</code>, <code>ObjectOutputStream</code>。</li><li><strong>网络流</strong>：用于网络通信，如 <code>Socket</code>相关的流。</li></ul><h2 id="文件流操作示例"><a href="#文件流操作示例" class="headerlink" title="文件流操作示例"></a>文件流操作示例</h2><p>文件流主要分为<strong>字节流</strong>（用于处理二进制数据）和<strong>字符流</strong>（用于处理文本数据，处理字符编码）。</p><h3 id="字节流文件复制"><a href="#字节流文件复制" class="headerlink" title="字节流文件复制"></a>字节流文件复制</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyByteStream</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1.txt"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2.txt"</span>;<br>        <span class="hljs-keyword">try</span> {<br>            copyByStream(sourceFile, targetFile);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用字节流复制文件（使用try-with-resources自动关闭资源）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sourceDir 源文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetDir 目标文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当IO操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyByStream</span><span class="hljs-params">(String sourceDir, String targetDir)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-comment">// 使用try-with-resources确保流自动关闭</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sourceDir);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(targetDir)) {<br>      <br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8192</span>]; <span class="hljs-comment">// 使用8KB缓冲区（通常比1KB更高效）</span><br>            <span class="hljs-type">int</span> length;<br>      <br>            <span class="hljs-keyword">while</span> ((length = fis.read(buffer)) != -<span class="hljs-number">1</span>) {<br>                fos.write(buffer, <span class="hljs-number">0</span>, length);<br>            }<br>      <br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        }<br>        <span class="hljs-comment">// 无需finally块 - try-with-resources自动处理关闭</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="字符流文件复制（改进版）"><a href="#字符流文件复制（改进版）" class="headerlink" title="字符流文件复制（改进版）"></a>字符流文件复制（改进版）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyCharStream</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1.txt"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2.txt"</span>;<br>        <span class="hljs-keyword">try</span> {<br>            copyByCharStream(sourceFile, targetFile);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用字符流复制文本文件（显式指定字符编码）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sourceDir 源文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetDir 目标文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当IO操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyByCharStream</span><span class="hljs-params">(String sourceDir, String targetDir)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-comment">// 使用StandardCharsets常量</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(sourceDir, StandardCharsets.UTF_8);<br>             <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(targetDir, StandardCharsets.UTF_8)) {<br>      <br>            <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-type">int</span> length;<br>      <br>            <span class="hljs-keyword">while</span> ((length = fis.read(buffer)) != -<span class="hljs-number">1</span>) {<br>                fos.write(buffer, <span class="hljs-number">0</span>, length);<br>            }<br>      <br>            <span class="hljs-comment">// flush操作会在close()中自动调用，通常无需显式调用</span><br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="缓冲流的使用（改进版）"><a href="#缓冲流的使用（改进版）" class="headerlink" title="缓冲流的使用（改进版）"></a>缓冲流的使用（改进版）</h2><p>缓冲流（Buffered Stream）通过减少底层系统的调用次数来提高I/O效率。它们确实在基础流之上添加了缓冲层，但更准确的说法是：<strong>缓冲流在内存中创建缓冲区，减少了对物理设备（如硬盘）的直接访问次数</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyBufferedStream</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1.txt"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2.txt"</span>;<br>        <span class="hljs-keyword">try</span> {<br>            copyByBufferedStream(sourceFile, targetFile);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用缓冲流复制文件（更高效的IO操作）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sourceDir 源文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetDir 目标文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当IO操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyByBufferedStream</span><span class="hljs-params">(String sourceDir, String targetDir)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-comment">// 基础流在try-with-resources中创建，缓冲流包装它们</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sourceDir);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(targetDir);<br>             <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>             <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos)) {<br>      <br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-type">int</span> length;<br>      <br>            <span class="hljs-keyword">while</span> ((length = bis.read(buffer)) != -<span class="hljs-number">1</span>) {<br>                bos.write(buffer, <span class="hljs-number">0</span>, length);<br>            }<br>      <br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>某些缓冲流（如 <code>BufferedReader</code>）支持标记位置和重置功能。</p><h2 id="使用NIO-API进行文件复制（现代方法）"><a href="#使用NIO-API进行文件复制（现代方法）" class="headerlink" title="使用NIO API进行文件复制（现代方法）"></a>使用NIO API进行文件复制（现代方法）</h2><p>Java NIO (New I/O) 提供了更简洁高效的文件操作方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyNIO</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">sourcePath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"1.txt"</span>);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">targetPath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"2.txt"</span>);<br>  <br>        <span class="hljs-keyword">try</span> {<br>            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);<br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>NIO是新型的封装好的文件操作方法。</p><h2 id="重要注意事项与最佳实践"><a href="#重要注意事项与最佳实践" class="headerlink" title="重要注意事项与最佳实践"></a>重要注意事项与最佳实践</h2><p><strong>资源管理</strong>：<strong>总是使用try-with-resources</strong>来自动关闭流，避免资源泄漏。</p><p>不要依赖手动调用 <code>close()</code>，因为异常可能导致资源无法关闭。</p><p><strong>字符编码</strong>： 处理文本文件时<strong>总是明确指定字符编码</strong>（如UTF-8）。</p><p>避免使用 <code>FileReader</code>和 <code>FileWriter</code>的默认构造函数，因为它们使用平台默认编码，可能导致跨环境问题。</p><p><strong>缓冲区大小</strong>： 缓冲区大小（如8KB）通常比小缓冲区（如1KB）性能更好，但应通过测试确定最佳大小。</p><p>对于大文件，可以考虑使用更大的缓冲区（如64KB或128KB）。</p><p><strong>flush操作</strong>： 输出流在关闭前会自动flush，通常不需要显式调用 <code>flush()</code>。</p><p>如果需要确保数据立即写入（如实时日志），可以显式调用 <code>flush()</code>。</p><p><strong>性能考量</strong>： 对于大文件，NIO的 <code>Files.copy()</code>通常是最佳选择。</p><p>缓冲流对于多次小量读写操作最有效。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA异常</title>
    <link href="/posts/JAVA_Exception/"/>
    <url>/posts/JAVA_Exception/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA异常"><a href="#JAVA异常" class="headerlink" title="JAVA异常"></a>JAVA异常</h1><h2 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h2><p>异常（Exception）是指程序在<strong>运行时</strong>发生的不被期望的事件，它阻止了程序按照预期正常执行。需要注意的是，<strong>编译时期</strong>出现的错误（如语法错误）通常称为编译错误，不属于异常处理的范畴。异常处理机制旨在让程序在运行时遇到错误时，能够按照预先设定的逻辑进行应对，从而尽可能恢复或优雅终止。</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>Java中的异常和错误都继承自 <code>Throwable</code>类，其层次结构如下</p><p><img src="https://s21.ax1x.com/2025/10/09/pVH8qmt.png" alt="异常"></p><p><strong>Error (错误)<strong>： 是程序</strong>无法处理</strong>的严重问题，通常与JVM本身或系统资源相关，应用程序不应尝试捕获处理。例如 <code>OutOfMemoryError</code>（内存耗尽）、<code>StackOverflowError</code>（栈溢出，常由无限递归引发）等</p><p><strong>Exception (异常)<strong>： 是程序本身</strong>可以并且应该处理</strong>的问题。它分为两大类：</p><p><strong>受检异常 (Checked Exception)<strong>： 指在</strong>编译时期</strong>就必须被处理的异常。如果方法可能抛出这类异常，必须在方法签名中用 <code>throws</code>声明，或者用 <code>try-catch</code>块进行捕获，否则代码无法通过编译。例如 <code>IOException</code>(输入输出异常)、<code>SQLException</code>(SQL相关异常)</p><p><strong>非受检异常 (Unchecked Exception)<strong>： 主要指 <code>RuntimeException</code>及其子类。它们在</strong>编译时期不强制要求处理</strong>，通常是由程序逻辑错误引发的，应在开发阶段通过代码修正来避免。例如 <code>NullPointerException</code>（空对象异常）、<code>ArrayIndexOutOfBoundsException</code>（数组越界异常）、<code>ArithmeticException</code>（如除以零）</p><h2 id="如何处理异常"><a href="#如何处理异常" class="headerlink" title="如何处理异常"></a>如何处理异常</h2><p>Java提供了 <code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code>关键字来处理异常</p><h3 id="1-捕获异常-try-catch-finally"><a href="#1-捕获异常-try-catch-finally" class="headerlink" title="1. 捕获异常 (try-catch-finally)"></a>1. 捕获异常 (try-catch-finally)</h3><p>基本语法结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>    <span class="hljs-comment">// 可能会发生异常的代码</span><br>} <span class="hljs-keyword">catch</span> (ExceptionType1 e1) {<br>    <span class="hljs-comment">// 捕获并处理特定类型 ExceptionType1 的异常</span><br>} <span class="hljs-keyword">catch</span> (ExceptionType2 e2) {<br>    <span class="hljs-comment">// 捕获并处理特定类型 ExceptionType2 的异常</span><br>} <span class="hljs-keyword">finally</span> {<br>    <span class="hljs-comment">// 无论是否发生异常，最终都会执行的代码块</span><br>    <span class="hljs-comment">// 通常用于释放资源（如关闭文件、数据库连接等）</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>示例：处理数组越界异常</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) { <span class="hljs-comment">// 循环最后一次 i=6 时会越界</span><br>                a[i] = i;<br>            }<br>        } <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) {<br>            System.out.println(<span class="hljs-string">"捕获到数组越界异常: "</span> + e.getMessage());<br>        } <span class="hljs-keyword">finally</span> {<br>            System.out.println(<span class="hljs-string">"这段代码总是会执行。"</span>);<br>        } <span class="hljs-comment">// 在多异常检查中，finally为所有异常提供了统一出口，一般用于关闭资源</span><br>        System.out.println(<span class="hljs-string">"Hello World"</span>); <span class="hljs-comment">// 由于异常被捕获，程序可以继续执行</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="2-声明抛出异常-throws"><a href="#2-声明抛出异常-throws" class="headerlink" title="2. 声明抛出异常 (throws)"></a>2. 声明抛出异常 (throws)</h3><p>在方法签名中使用 <code>throws</code>关键字，声明该方法可能抛出的异常，将异常的处理责任交给方法的调用者。这常用于受检异常（Checked Exception）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-comment">// 可能抛出IOException的代码</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="3-主动抛出异常-throw"><a href="#3-主动抛出异常-throw" class="headerlink" title="3. 主动抛出异常 (throw)"></a>3. 主动抛出异常 (throw)</h3><p>使用 <code>throw</code>关键字在代码中主动抛出一个异常对象（可以是内置异常或自定义异常）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">"除数不能为零"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-try-with-resources（自动资源管理）"><a href="#4-try-with-resources（自动资源管理）" class="headerlink" title="4. try-with-resources（自动资源管理）"></a>4. try-with-resources（自动资源管理）</h3><p>对于实现了 <code>AutoCloseable</code>接口的资源（如 <code>InputStream</code>, <code>OutputStream</code>, <code>Connection</code>等），强烈推荐使用 <strong>try-with-resources</strong> 语句。它可以自动关闭资源，代码更简洁，且不易出错，无需显式编写 <code>finally</code>块来关闭资源</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryWithResourcesExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 资源在try后的括号内声明和初始化，多个资源用分号隔开</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"test.txt"</span>))) {<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) {<br>                System.out.println(<span class="hljs-string">"Line =&gt; "</span> + line);<br>            }<br>        } <span class="hljs-keyword">catch</span> (IOException e) { <span class="hljs-comment">// 这里仍然需要捕获可能发生的IOException</span><br>            System.out.println(<span class="hljs-string">"读取文件时发生异常: "</span> + e.getMessage());<br>        } <span class="hljs-comment">// 无需finally块，br会自动关闭</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>当Java标准异常类无法清晰表达特定的业务逻辑错误时，可以创建自定义异常</p><p><strong>创建自定义异常的最佳实践</strong>：</p><p>通常继承自 <code>Exception</code>（创建受检异常）或 <code>RuntimeException</code>（创建非受检异常）。选择取决于错误性质：是否强制调用者处理</p><p>提供多个构造方法，通常至少包括一个带详细消息（String message）的构造方法，并调用父类构造器</p><p>可以添加自定义字段（如错误码）来提供更丰富的错误信息</p><p><strong>示例：自定义一个非受检的业务异常</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义异常类，继承RuntimeException成为非受检异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsufficientBalanceException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> currentBalance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amountRequired;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InsufficientBalanceException</span><span class="hljs-params">(String message, <span class="hljs-type">double</span> currentBalance, <span class="hljs-type">double</span> amountRequired)</span> {<br>        <span class="hljs-built_in">super</span>(message); <span class="hljs-comment">// 调用父类构造方法</span><br>        <span class="hljs-built_in">this</span>.currentBalance = currentBalance;<br>        <span class="hljs-built_in">this</span>.amountRequired = amountRequired;<br>    }<br><br>    <span class="hljs-comment">// 获取额外信息的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCurrentBalance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> currentBalance;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmountRequired</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> amountRequired;<br>    }<br><br>    <span class="hljs-comment">// 可选：重写toString以提供更详细的错误信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + <br>               <span class="hljs-string">" Current Balance: "</span> + currentBalance + <br>               <span class="hljs-string">", Amount Required: "</span> + amountRequired;<br>    }<br>}<br><br><span class="hljs-comment">// 使用自定义异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> {<br>        <span class="hljs-keyword">if</span> (amount &gt; balance) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsufficientBalanceException</span>(<span class="hljs-string">"余额不足"</span>, balance, amount);<br>        }<br>        balance -= amount;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爱情</title>
    <link href="/posts/love/"/>
    <url>/posts/love/</url>
    
    <content type="html"><![CDATA[<h1 id="一个须臾"><a href="#一个须臾" class="headerlink" title="一个须臾"></a>一个须臾</h1><p>在回家的路上，飞机进入了平流层，灯关很暗，我捧着电子书，用笔戳着平板翻页，这一切都平平静静地发生着，直到我旁边的一个女孩子靠在我的肩膀上睡着了。她的青丝散发着淡淡的香气，呼吸均匀得像潮汐拍岸。我有些慌乱，将电子书切换到夜间模式，竭力让自己的瞳孔适应微弱的亮光，左肩的压力让我有些不自在，但我尽力保持平稳，那是一种很奇妙的感觉，我的肩膀上的重量好像一颗沉入杯中的方糖，在无声中消融。我不敢在平板上写字，生怕惊醒了她睫毛上停驻的整个星空。</p><p>我不想在这里提及什么老掉牙的一见钟情的桥段，这只是发生在地球46亿年的生命中的一个瞬间罢了。也许我在那个时刻突然爱上了这个面容模糊，脾性未明的人，在黑暗中构思着我们的未来，想象着我们一起去图书馆的理想情景。但是随即这种感觉便随飞机的尾气烟消云散。</p><h1 id="白玫瑰背后的刺"><a href="#白玫瑰背后的刺" class="headerlink" title="白玫瑰背后的刺"></a>白玫瑰背后的刺</h1><p>我见过很多仓促且浮躁的“快餐式恋爱”，有人为了某人夸张露骨的打扮怦然心动，却在她的放荡和背叛中懊悔不已：也有人为了迎合“完整的大学”选择抓住一个陌生的背影，最后为自己的冲动买单。<strong>白玫瑰的刺上沾满了血</strong>，但这些故事，像未校准的罗盘，指向了除了永恒之外的所有迷途。</p><p>摄影师总是喜欢将镜头聚焦到两人一见钟情的那一刻，却略去他们相守不离的情节。他们美化相识，淡化相守，造就了我们过于理想而不切实际的憧憬和期待。<strong>然而真正的爱情绝非某个须臾，而是一段需要漫长岁月才能写就的史诗。</strong></p><h2 id="醒来"><a href="#醒来" class="headerlink" title="醒来"></a>醒来</h2><p>飞机开始俯冲着陆，云朵被撕裂成碎片，剧烈的颠簸使她醒来，梦境里美好的星空是如此短暂，须臾间就化为了白昼。我盯着屏幕上的有向图，她收拾着她的东西，谁都没有说话，好像什么都没有发生，又好像这只是一场恍惚的梦。</p>]]></content>
    
    
    <categories>
      
      <category>旅途</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> 数据结构8：图</title>
    <link href="/posts/data_struction_8/"/>
    <url>/posts/data_struction_8/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>图是由顶点的<strong>有穷非空集合</strong>和<strong>顶点之间边的集合</strong>组成的。<br>通记为 G(V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是边的集合<br>V(G) 和 E(G) 通常分别表示图 G 的顶点集合和边集合。</p><p>对于图这种数据结构，不允许没有顶点，但边集可以为空。（点可以是孤立的）</p><p><img src="https://s2.loli.net/2025/05/27/uljhSLsk1bO6HG8.png" alt="image-20250526200457954"></p><h4 id="简单图与多重图"><a href="#简单图与多重图" class="headerlink" title="简单图与多重图"></a>简单图与多重图</h4><p>1.图中不能有指向自身的环</p><p>2.同一条边在图中不能出现两次或以上</p><p>不满足以上两条限制的图称为多重图</p><h4 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h4><p>完全图：具有最多边数的图<br>对于一个具有 n 个顶点的无向完全图，边数量的最大值为 n(n - 1) / 2<br>对于一个具有 n 个顶点的有向完全图，边数量的最大值为 n(n - 1)</p><p><strong>路径和路径长度</strong><br>路径：从一个顶点开始，经过一系列的边到达另外一个顶点形成的顶点序列。<br>路径长度：路径上边的条数<br>回路（环）：起点和终点相同，路径 {0, 3, 1, 0} 是一个回路（环）</p><p><img src="https://s2.loli.net/2025/05/27/1yGrDcMltWVS32i.png"></p><p><strong>简单路径</strong><br>简单路径：如果路径中不出现相同的顶点，则称为简单路径</p><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</p><p><strong>顶点的度</strong></p><p>度：对于无向图，顶点的度指的是与顶点相关联边的数目。<br>入度：在有向图中，对于顶点 v，箭头指向 v 的边的数目。<br>出度：在有向图中，对于顶点 v，从该顶点出发的边的数目。</p><p><strong>度和边的关系</strong></p><p>在无向图中，假设具有 n 个顶点，e 条边<br>图中所有顶点度之和等于边数的两倍<br>对于有向图，所有顶点的出度之和与入度之和相等，弧的数量也相等。</p><p><strong>子图</strong></p><p>就是类似于子集之类的一个定义</p><p><strong>连通图</strong><br>连通：在无向图中，如果从顶点 V 到顶点 w 有路径，则称顶点 v 到顶点 w 是连通的。<br>如果对于图中任意两个顶点都是连通的，则称此图为连通图</p><p><strong>连通分量</strong><br><strong>无向图中的极大连通子图</strong>称为连通分量<br>连通分量为子图<br>子图为连通图<br>连通子图含有极大顶点数<br>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</p><p><strong>强连通图</strong><br>强连通图：在有向图中，对于每一对顶点 v 和 w ，从 v 到 w 和从 w 到 v 都有路径，<br>则称该有向图是强连通图。<br>有向图中的极大强连通子图称为有向图的强连通分量。</p><p><strong>生成树</strong><br>生成树：指含有图中全部顶点的极小连通子树（连通图的<strong>极小连通子图</strong>）<br><strong>注意：包含所有顶点 n，但只有足以构成一棵树的 n-1 条边</strong></p><p><strong>边的权和网</strong><br>在一个图中，每条边可以标注上一个代表某种含义的数值，该数值称为这个边的权值<br>网：边上带的权值的图，也称为带权图</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵（Adjacency Matrix）是图（Graph）的一种存储结构，通过二维数组表示顶点之间的连接关系。其核心原理是将图的顶点和边信息分别用一维数组和二维矩阵存储，适用于描述图的拓扑结构，尤其适合<strong>稠密图</strong>（边数接近顶点数平方）。</p><p><img src="https://s2.loli.net/2025/05/27/UTRLh6mtIZHG97b.png" alt="image-20250527103145031"></p><p>如果有连线在矩阵中就是1表示，如果没有就是0表示</p><p>无向图中一般是关于对角线对称的</p><p>有向图中的矩阵就不是这样</p><p>但是如果是带权值的图</p><p><img src="https://s2.loli.net/2025/05/27/ZsjWRblSOfEr3NP.png" alt="image-20250527110250144"></p><p>两个边之间没有关系在矩阵中表示为0。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表（Adjacency List）是图（Graph）的一种链式存储结构，结合了顺序存储和链式存储的特点，能够高效表示稀疏图并支持动态操作。</p><p>图中构成了四条链表，而链表的头节点就是各个顶点，这四个链表都存放在一维数组中，而第二个元素开始的数据域就是一维数组的元素的索引，所以我们可以使用这种路径来实现图的遍历。</p><p>有时候基于顶点的边不是固定顺序的，比如，下图中V0有指向V1，V2和V3的三条边，那么第一条链表中的第二第三第四元素可以自由交换位置。</p><p><img src="https://s2.loli.net/2025/05/27/yS5oRlcnk2uvtGH.png" alt="image-20250527111402078"></p><p>在有向图中，根据方向我们可以有<strong>逆邻接表</strong></p><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>它和邻接表相反，头节点是终点，后面的元素是起点。</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>十字链表（Orthogonal List）是一种专为<strong>有向图</strong>设计的链式存储结构。</p><p>十字链表有两个结构：<strong>顶点结构</strong>和<strong>边结构</strong></p><p>入边就是“进入该顶点的边\弧\箭头”，出边反之。</p><p>Vex指的是顶点，Tailvex表示弧尾，Headvex表示弧头，后面Headlink表示弧头的指针，taillink表示弧尾的指针</p><p><img src="https://s2.loli.net/2025/05/27/2VUicQpxgNmMZH9.png" alt="image-20250527133314864"></p><p>下面我们讲解一个橙色箭头的意思，根据上文，顶点结构的第二个格子应该是入边的指针，所以我们需要找到”进入”该顶点的弧，并且让该顶点的第二个格子的指针指向它。</p><p><img src="https://s2.loli.net/2025/05/27/TYwvKurpf26DNJ4.png" alt="image-20250527190943882"></p><p>用横向来表达出边的路径，用纵向来表达入边的路径，纵横交错形成了Crossing，也就是<strong>十字链表</strong>。</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><strong>邻接多重表</strong>是专为无向图设计的一种链式存储结构，通过优化邻接表的冗余存储问题，显著提升了空间效率与边操作能力。以下从结构特性、应用场景及对比分析等角度进行详细介绍：</p><p><img src="https://s2.loli.net/2025/05/27/Og7ZeMpfRBibNvQ.png" alt="image-20250527193509055"></p><p>将顶点连接到与他相关的边上，随即将link连接到未涉及的边上。</p><p><img src="https://s2.loli.net/2025/05/27/CDvrHysFlZfQMmA.png" alt="image-20250527195518243"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果你看到这里，<strong>那么这段时间对数据结构的学习算是告一段落了</strong>。按之前的安排，这之后应该还要三个章节，分别是<strong>DFS和BFS</strong>，<strong>Dijkstra最短路径算法</strong>和<strong>拓扑排序</strong>，但是我打算将他放到算法的学习章节中去。</p><p>写下这段文字的时间是六月二号，按道理，我将提前两周开始复习大学的期末考试，祝看到这里的人好运，我们再会。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构7：树与二叉树</title>
    <link href="/posts/data_struction_7/"/>
    <url>/posts/data_struction_7/</url>
    
    <content type="html"><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><p>树是一种非线性数据结构，由 <strong>n（n≥0）</strong> 个有限节点构成具有层次关系的集合。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>结点：树中的一个独立单元。<br><strong>结点的度</strong>：结点拥有的子树数称为结点的度。<br><strong>树的度</strong>：树内各结点度的最大值。<br><strong>叶子</strong>：度为 0 的结点或终端结点。<br><strong>非终端结点</strong>：度不为 0 的结点。<br><strong>双亲和孩子</strong>：结点的子树的根称为该结点的<strong>孩子</strong>，相应地，该结点称为孩子的双亲。<br><strong>层次</strong>：结点的层次从根开始定义，<br>根为第一层，根的孩子为第二层，<br>以此类推。</p><p><img src="https://s2.loli.net/2025/05/25/DWh5wJXvTG6gMsV.png" alt="image-20250523204021005"></p><h2 id="树的一些普遍性质"><a href="#树的一些普遍性质" class="headerlink" title="树的一些普遍性质"></a>树的一些普遍性质</h2><p>$$<br>\text{性质一：树中所有结点数等于所有结点的度数之和加 1。}<br>$$</p><p>$$<br>\text{性质二:对于度为 m 的树,第i层上最多有 m}^{i-1}\text{个结点。}<br>$$</p><p>$$<br>性质三：对于高度为 h，度为 m 的树，最多有(\mathrm{m^h-1})/(\mathrm{m-1})个节点<br>$$</p><h2 id="树的类型"><a href="#树的类型" class="headerlink" title="树的类型"></a>树的类型</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树（Binary Tree）是 n（ n&gt;=0）个结点<br>所构成的集合，它或为空树（n=0），或为非<br>空树。对于非空树 T：<br>（1）有且仅有一个称为根的结点<br>（2）除根结点以外的其余结点分为两个互<br>不相交的子集 T1 和 T2 ，分别称为 T 的左<br>子树和右子树，且 T1 和 T2 本身又都是二叉<br>树。<br>（3）二叉树每个结点至多只有两棵子树。<br>（4）二叉树的子树有左右之分，其次序不能任意颠倒。</p><p><img src="https://s2.loli.net/2025/11/21/5VpgDveukQXMBnz.png" alt="image-20251121145702947"></p><p><img src="https://s2.loli.net/2025/05/23/xFJWIVOsoi6hgYf.png" alt="image-20250523220257631"></p><p>$$<br>\text{性质一:二叉树的第i层最多有2}^{\mathrm{i-1}}(i\geqslant1)\text{ 个结点。}<br>$$</p><p>$$<br>性质二:深度为k的二叉树最多有2^{\mathrm{k-1}}(k\geqslant1)个节点<br>$$</p><p>$$<br>\begin{aligned}&amp;\text{性质三:对于任何非空的二叉树T,如果叶子结点的个数为n}_0,\text{而度为2的结点数为n}_2,\text{则}\&amp;\mathrm{n_0=n_2+1}\end{aligned}<br>$$</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>$$<br>满二叉树：深度为 k 且含有 2^{\mathrm{k}}-1 个结点的二叉树<br>$$</p><blockquote><p>所有的叶子结点只能出现在最后一层<br>对于同样深度的二叉树，满二叉树的结点个数最多，<br>叶子结点的数量也是最多的。<br>如果对满二叉树进行编号，根结点从1开始，从上到，<br>下从左到右，对于编号为i的结点，若存在左孩子，<br>则左孩子的编号为2i，右孩子为2i+1</p></blockquote><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>$$<br>完全二叉树：深度为 k 的、有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k<br>的满二叉树中编号从 1 至 n 的结点一一对应时，称之为完全二叉树<br>$$</p><p>完全二叉树的定义可能很模糊，我们举个例子。</p><p>比如满二叉树</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">1</span><br>      / \<br>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>    / \ / \<br>   <span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span><br></code></pre></td></tr></tbody></table></figure><p>可以发现深度为3，有7个节点。</p><p>如果有其子树</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">1</span><br>      / \<br>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>    / \ / <br>   <span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><p>可见没有7号节点，但是剩余节点和上面的满二叉树是一一对应的上的，这就是完全二叉树。</p><p>但是我们如果删除4号节点，你就会发现，节点相对于满二叉树1-7少了4，所以，这不符合<strong>与深度为 k<br>的满二叉树中编号从 1 至 n 的结点一一对应</strong>的定义，所以<strong>这不是完全二叉树</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">1</span><br>      / \<br>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>      \ / \<br>      <span class="hljs-number">5</span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span><br></code></pre></td></tr></tbody></table></figure><p>所以，完全二叉树的定义需要配合满二叉树来理解，下面是完全二叉树的性质。</p><p>$$<br>性质一:叶子结点只可能在层次最大的两层上出现；<br>$$</p><p>$$<br>性质二:对任一结点，若其右分支下的子孙的最大层次为 l，则其左分支下的子孙的最大层次必为 l 或 l+1。<br>$$</p><p>$$<br>性质三:没有左子树，不能有右子树，上一层没有铺满，不能有下一层<br>$$</p><p>$$<br>\text{性质四:具有n 个结点的完全二叉树的深度为 log}_2\text{n+1}<br>$$</p><p><img src="https://s2.loli.net/2025/11/21/C4oundiFSU1z6Ds.png" alt="image-20251121022255843"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">{</span><br>  ElemType data;<br>  TreeNode *lchild;<br>  TreeNode *rchild;<br>  }TreeNode;<br><span class="hljs-keyword">typedef</span> TreeNode* BiTree;<span class="hljs-comment">//给TreeNode类型的指针起了别名为BiTree</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2025/05/25/9OPAeUwEaslZbFc.png" alt="image-20250524201202428"></p><p>类似于用指向表头的指针来代表链表，我们使用指向根结点的指针来代表整个树。</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>对于树的遍历，我们需要使用递归。这一块可能很难理解，可以辅助代码可视化。</p><p><img src="https://s2.loli.net/2025/05/24/fCEWdaqlt1LgYGn.png" alt="image-20250524205550958"></p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>先访问根结点，然后访问左分支上遇到的每一个结点，持续这一过程，直到遇到空结点为止。这时，返回到最近的有右孩子的祖先结点，并从该结点的右孩子开始继续遍历。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(BiTree T)</span> <span class="hljs-comment">//前序遍历</span><br>{<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>{<br><span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, T-&gt;data);<br>preOrder(T-&gt;lchild);   <span class="hljs-comment">//先遍历左子节点再遍历右节点</span><br>preOrder(T-&gt;rchild);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历顺序：**A B D H K E C F I G J **</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先访问根结点，向树的左下方移动，直到遇到空结点为止，然后访问空结点的父结点。接着继续遍历该结点的右子树，如果右子树没的子树可以遍历，那么继续遍历上一层最后一个未被访问的结点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(BiTree T)</span><br>{<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>{<br><span class="hljs-keyword">return</span>;<br>}<br>inOrder(T-&gt;lchild);   <span class="hljs-comment">//顺序不一样了</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, T-&gt;data);<br>inOrder(T-&gt;rchild);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历顺序：**H K D B E A I F C G J **</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>从根结点开始先访问结点的左右儿子，再对该结点进行访问。这就意味着结点的儿子<br>将在该结点之前输出。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(BiTree T)</span><br>{<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>{<br><span class="hljs-keyword">return</span>;<br>}<br>postOrder(T-&gt;lchild);<br>postOrder(T-&gt;rchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, T-&gt;data);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历顺序：**K H D E B I F J G C A **</p><h3 id="二叉树遍历性质"><a href="#二叉树遍历性质" class="headerlink" title="二叉树遍历性质"></a>二叉树遍历性质</h3><p>已知前序遍历和中序遍历，可以唯一确定一棵二叉树。<br>已知中序遍历和后序遍历，可以唯一确定一棵二叉树。<br>已知前序遍历和后序遍历，是不能确定一棵二叉树的。</p><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p><strong>我们只有通过遍历才能得到二叉树的顺序，但是如果每次遍历都需要直接使用前序/中序/后序遍历的话会有很高的时间复杂度，所以我们考虑使用叶子结点未利用的指针来指向某一种遍历的先后次序，构造时间复杂度为O(n)的链式遍历。</strong></p><p>尽管使用一棵树的空余指针只够满足一种遍历方式的链式访问，但是实际上已经足够了。</p><p><img src="https://s2.loli.net/2025/05/25/7UxONrsKgJukYPm.png" alt="image-20250525203550711"></p><p>在使用的过程中不会出现空指针不够用的情况。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span></span><br><span class="hljs-class">{</span><br>ElemType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span> *<span class="hljs-title">lchild</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span> *<span class="hljs-title">rchild</span>;</span><br><span class="hljs-type">int</span> ltag;   <span class="hljs-comment">//tag等于1时，指向前驱或者后驱，等于0时，指向左节点或者右节点</span><br><span class="hljs-type">int</span> rtag;<br>}ThreadNode;<br><span class="hljs-keyword">typedef</span> ThreadNode* ThreadTree;<br></code></pre></td></tr></tbody></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>我们在这里称最后的遍历顺序为一个“<strong>链表</strong>”</p><p>在使用过程中，我们创造一个头节点，他的左指针指向二叉树的根。</p><p>右节点指向链表的最后一个节点。</p><p><strong>链表的第一个节点的左指针指向头节点</strong></p><p><strong>链表的最后一个节点的右指针指向头节点</strong></p><p>这么一来，我们构成了一个<strong>双向循环链表</strong></p><p>如果这个树不再需要修改，使用<strong>链表的使用方式</strong>去使用可以得到较低的时间复杂度和更高的空间利用效率。</p><p><img src="https://s2.loli.net/2025/05/25/i4NKd1ApcZVOhbk.png" alt="image-20250525210120015"></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径<br><strong>路径长度</strong>：路径上的分支数目<br><strong>树的路径长度</strong>：从树根到每一个结点的路径长度之和</p><p><strong>权：统计学上个体在总体中的权重</strong></p><p><strong>结点的权</strong>：在实际应用中，给树中的结点赋予代表某种含义的数值<br><strong>结点的带权路径长度</strong>：从该节点到树根之间的路径长度与该结点权的乘积<br><strong>树的带权路径长度（WPL）</strong>：树中所有叶节点的带权路径长度之和</p><p><strong>带权路径长度（WPL）最小的树称作哈夫曼树</strong></p><p><img src="https://s2.loli.net/2025/05/26/zrQiUZstYOB7M9e.png" alt="image-20250526180640539"></p><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><p>将权重从小到大排列</p><p>将两个最小权值的点连接同一个新节点。</p><p>将新取得的父节点取代原来两个最小节点，加入到原来的有序队列中</p><p>重复以上操作直到组成一个树</p><p>原理：权重大的距离树根近，权重小的距离树根远，所以乘起来就比较少</p><h2 id="树与二叉树之间的转换"><a href="#树与二叉树之间的转换" class="headerlink" title="树与二叉树之间的转换"></a>树与二叉树之间的转换</h2><h3 id="树转变为二叉树"><a href="#树转变为二叉树" class="headerlink" title="树转变为二叉树"></a>树转变为二叉树</h3><ol><li>加线，在所有兄弟结点之间加一条线</li><li>去线，对树中的每一个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li><li>层次调整，以树的根结点为轴心，将整棵数顺时针旋转一定角度，使之层次分明。注意第一个孩子是二叉树结点的左孩子。兄弟转过来的孩子是结点的右孩子。</li></ol><p><img src="https://s2.loli.net/2025/05/26/1obkOVtBG5KYdE3.png" alt="image-20250526191957670"></p><h3 id="二叉树转化为树"><a href="#二叉树转化为树" class="headerlink" title="二叉树转化为树"></a>二叉树转化为树</h3><ol><li>加线，若某个结点的左孩子存在，则将这个左孩子的所有右孩子结点都作为<br>此结点的孩子，将该结点与这些右孩子结点用线连起来。</li><li>去线，删除二叉树中所有结点与其右孩子结点的连线</li><li>调整，转一下</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构6：表达式求值</title>
    <link href="/posts/data_struction_6/"/>
    <url>/posts/data_struction_6/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><p><strong>C语言表达式求值是一个综合优先级、结合性、类型转换和副作用处理的复杂过程。</strong></p><p>表达式的书写形式有<strong>中缀表达式</strong>和<strong>后缀表达式</strong>两种。</p><p>中缀表达式是人类最常用的数学表达式形式，其特点是<strong>运算符位于两个操作数中间</strong>，后缀表达式将<strong>运算符置于操作数之后</strong>，后缀表达式<strong>使用栈结构</strong>对于计算机具有很高的计算效率。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><code>82/2+56*-</code>是一个后缀表达式。</p><ul><li>数字8入栈，位于栈的底层。</li><li>数字2入栈</li><li>运算符<code>/</code>入栈，以<strong>取栈顶的两个元素，靠近栈底元素为中缀表达式的第一项</strong>为原则执行8/2 == 4</li><li>和4被压入栈中</li><li>数字2入栈</li><li>继续计算直到-</li><li>将最后的元素弹出，返回给输入参数</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构5：栈和队列</title>
    <link href="/posts/Data_struction_5/"/>
    <url>/posts/Data_struction_5/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构4：栈和队列"><a href="#数据结构4：栈和队列" class="headerlink" title="数据结构4：栈和队列"></a>数据结构4：栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈（stack）是限定仅在表尾进行插入或删除操作的线性表。因此对栈来说，表尾端有其特殊含义，称为栈顶（top），相应地，表头端称为栈底（bottom）。不含元素的空表称为空栈。<br>假设 S=(a1, a2, …, an)，则称 a1 为栈底元素，an 为栈顶元素。栈中元素按 a1, a2, …,an 的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按照后进先出的原则进行的。因此，栈又称为后进先出（Last In First Out, LIFO）的线性表。</p><p><img src="https://s2.loli.net/2025/04/05/kLRzrf9y6PuW1pC.png" alt="image-20250405224822698"></p><blockquote><p>类似于手枪的弹匣，最先压进去的子弹是最后打出去的一发。</p></blockquote><p>所以，栈是限制插入和删除操作只能在一个位置进行的表，该位置是表的末端，叫作<br>栈顶（top）。对栈的基本操作有进栈（push）和出栈（Pop），前者相当于插入，<br>后者则是删除最后插入的元素。</p><h2 id="栈的设置和初始化"><a href="#栈的设置和初始化" class="headerlink" title="栈的设置和初始化"></a>栈的设置和初始化</h2><p>一个栈一般需要一个数据域和一个栈指针（用于调用栈里面的元素）。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span> {</span><br>    <span class="hljs-type">int</span> top;<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">10000</span>];<br>    } <span class="hljs-built_in">stack</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initstack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s)</span> {<br>    s-&gt;top = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//设置栈为空</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h2><p>往栈内增加元素类似于把子弹压入弹匣，故名。</p><p>代码实现:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;top == <span class="hljs-number">9999</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈满\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    s-&gt;top++;<br>    s-&gt;data[s-&gt;top] = x;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><p>删除栈内的元素类似于把子弹从弹匣内弹出，故名。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> *x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;top == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈空\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    *x = s-&gt;data[s-&gt;top];<br>    s-&gt;top--;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这会把删除的元素赋予传入参数的指针x中</p><h1 id="栈的链式结构"><a href="#栈的链式结构" class="headerlink" title="栈的链式结构"></a>栈的链式结构</h1><p>我们往往和链表一样，需要动态的内存分配的链式结构。</p><p>一般地，如果你详细阅读我之前的链表笔记，你就能理解链式结构的实现。</p><p>类似地：一个数据域，一个栈指针，一个指针域。</p><p>S是头节点，我们称它为<strong>栈顶指针</strong>，下一个节点就是<strong>栈顶</strong>。</p><p><img src="https://s2.loli.net/2025/04/06/nel7cK6RFiEqxpb.png" alt="image-20250406125858618"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>    <span class="hljs-type">int</span> *data;<br>    <span class="hljs-type">int</span> top;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span> *<span class="hljs-title">next</span>;</span><br>} <span class="hljs-built_in">stack</span>;<br><br><span class="hljs-built_in">stack</span>* <span class="hljs-title function_">init_stack</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">stack</span> *s = (<span class="hljs-built_in">stack</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>));<br>    s-&gt;data = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    s-&gt;top = <span class="hljs-number">-1</span>;<br>    s-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始栈的指针为空</span><br>    <span class="hljs-keyword">return</span> s;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链式结构的压栈"><a href="#链式结构的压栈" class="headerlink" title="链式结构的压栈"></a>链式结构的压栈</h2><p>这里使用了头插法，即新节点插入到链表的头部，也就是栈顶。</p><p>所以，头插法符合栈的结构特点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> x)</span> {<br>    <span class="hljs-built_in">stack</span> *new_s = (<span class="hljs-built_in">stack</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>));<br>    new_s-&gt;data = x;<br>    new_s-&gt;next = s -&gt; next;  <span class="hljs-comment">//如果s是栈顶指针的话，新节点的指针就是指向null</span><br>    s -&gt; next = new_s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链式结构的出栈"><a href="#链式结构的出栈" class="headerlink" title="链式结构的出栈"></a>链式结构的出栈</h2><p>出栈操作类似于链表的从头删除节点，我们通过改变栈顶的元素的指针，使得头节点和新的栈顶连接起来。</p><p><img src="https://s2.loli.net/2025/04/06/F3x78lKhimzB5CP.png" alt="image-20250406130033416"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> *x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;next == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"这个栈为空！\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    *x = s-&gt;next-&gt;data; <span class="hljs-comment">//一样地，会把删除的元素放进传入指针里</span><br>    <span class="hljs-built_in">stack</span> *temp = s-&gt;next;    <span class="hljs-comment">//临时指针</span><br>    s-&gt;next = s-&gt;next-&gt;next;   <span class="hljs-comment">//使得下一个节点成为新的栈顶</span><br>    <span class="hljs-built_in">free</span>(temp);   <span class="hljs-comment">//释放出栈节点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h2><p>没什么好说的，头节点的后继节点的数据域就是栈顶元素。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">get_top</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> *x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;next == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"这个栈为空！\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    *x = s-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="栈和单链表的关系"><a href="#栈和单链表的关系" class="headerlink" title="栈和单链表的关系"></a>栈和单链表的关系</h2><p><strong>单链表的头插法和头删法可以用来实现栈的行为。栈是一种后进先出（LIFO，Last In First Out）的数据结构，而单链表的头插法和头删法正好符合栈的操作特性。</strong></p><ol><li><strong>栈的特性</strong>：<ul><li><strong>后进先出（LIFO）</strong>：最后插入的元素最先被移除。</li><li><strong>主要操作</strong>：<ul><li><code>push</code>：将元素插入栈顶。</li><li><code>pop</code>：从栈顶移除元素。</li><li><code>peek</code>：查看栈顶元素。</li><li><code>isEmpty</code>：检查栈是否为空。</li></ul></li></ul></li><li><strong>单链表的头插法和头删法</strong>：<ul><li><strong>头插法</strong>：将新节点插入到链表的头部。</li><li><strong>头删法</strong>：从链表的头部删除节点。</li></ul></li><li><strong>栈和单链表的映射</strong>：<ul><li>栈的 <code>push</code> 操作对应单链表的头插法。</li><li>栈的 <code>pop</code> 操作对应单链表的头删法。</li><li>栈顶对应单链表的头部。</li></ul></li></ol><p>从这方面来看，栈其实是单链表的一个衍生。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列（queue）是一种先进先出（First In First Out, FIFO）的线性表。它只<br>允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端称为<br>队尾（rear）,允许删除的一端则称为队头（front）。假设队列为 q = (a1, a2, …,<br>an)，那么，a1 就是队头元素，an 就是队尾元素。队列中的元素是按照 a1, a2, …,<br>an 的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在 a1,<br>a2, …, an-1 都离开队列之后，an 才能退出队列。</p><p><img src="https://s2.loli.net/2025/04/06/CSTfqmDHVsctU1W.png" alt="image-20250406131745115"></p><p>我会展示队列的动画，可能有点长。</p><p><img src="https://s2.loli.net/2025/04/06/McpHDsvUrh2OGNZ.gif" alt="QQ录屏20250406134123"></p><h2 id="生成队列和初始化"><a href="#生成队列和初始化" class="headerlink" title="生成队列和初始化"></a>生成队列和初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>{</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-type">int</span> rear;<br>}<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    q-&gt;front= <span class="hljs-number">0</span>;<br>    q-&gt;rear= <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><p>只要队列的队头和队尾相等，就代表队列为空，至于为什么请看上面的动画。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">is_queue_empty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    <span class="hljs-keyword">if</span>(q-&gt;front == q-&gt;rear){<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is empty\n"</span>);<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is not empty\n"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    <span class="hljs-keyword">if</span>(q-&gt;front == q-&gt;rear){<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is empty\n"</span>);<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        q-&gt;front++;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="队列调整"><a href="#队列调整" class="headerlink" title="队列调整"></a>队列调整</h2><p>rear==Max_value的时候不代表队列就是<strong>满的</strong>，如下面这种情况。</p><p><img src="https://s2.loli.net/2025/04/06/edOJUmao3VtQfS5.png" alt="image-20250406135930927"></p><p>所以，我们需要调整队列，我们需要把这一连串的数据往队头移动。</p><p>不可避免地，这会造成一个比较高的时间复杂度。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">queue_full</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    <span class="hljs-keyword">if</span> (q-&gt;frint &gt; <span class="hljs-number">0</span> ){<br>        <span class="hljs-type">int</span> step = q-&gt;rear;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = q-&gt;front; i &lt;= q-&gt;rear; i++){<br>            {<br>                q -&gt; data[i-step] = q -&gt; data[i];    <span class="hljs-comment">//移动数据</span><br>            }<br>            q-&gt;front = <span class="hljs-number">0</span>;<br>            q-&gt;rear = q-&gt;rear - step;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is  full\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span>  <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q, <span class="hljs-type">int</span> data)</span>{<br>    <span class="hljs-keyword">if</span>(q-&gt;rear == <span class="hljs-number">100</span>){<br>        <span class="hljs-keyword">if</span>(!queue_full(q)){<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    q-&gt;rear++;<br>    q-&gt;data[q-&gt;rear] = data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构4：双向链表</title>
    <link href="/posts/Data_struction_4/"/>
    <url>/posts/Data_struction_4/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构4：双向链表"><a href="#数据结构4：双向链表" class="headerlink" title="数据结构4：双向链表"></a>数据结构4：双向链表</h1><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上次我们讲到了局部有环的单链表。</p><p><a href="https://imgse.com/i/pE626V1"><img src="https://s2.loli.net/2025/04/05/VsFYvybK9Azi6tq.png" alt="pE626V1.png"></a></p><h2 id="循环链表：找出入口和长度"><a href="#循环链表：找出入口和长度" class="headerlink" title="循环链表：找出入口和长度"></a>循环链表：找出入口和长度</h2><p>现在需要你找出一个循环链表的环入口。</p><p>我们的步骤是：</p><ul><li>设定快指针的速度是慢指针的两倍。</li><li>当快慢指针相遇时，慢指针已经走了 k 步，快指针走了 2k 步。</li><li>当快慢指针相遇时，我们已经进到了环中</li><li>现在设立一个新指针指向快指针，使其遍历并记录步数直到与快慢指针相遇，步数就是环长度。</li><li>初始化快慢指针为头指针，然后让快指针前进【环长度】步</li><li>让快慢指针以相同速度前进，直到相遇，相遇点就是入口</li></ul><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">findroundBegin</span> <span class="hljs-params">(Node *head)</span>{<br>    Node *fast = head;<br>    Node *slow = head;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next!= <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//循环找到环的入口</span><br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow){  <span class="hljs-comment">//如果快指针和慢指针相遇，则说明有环</span><br>            Node *p = fast;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(p-&gt; next != slow){<br>                count++;  <span class="hljs-comment">//循环计数,表示环的长度</span><br>                p = p-&gt;next;<br>            }<br>            fast = head;<br>            slow = head;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++){  <span class="hljs-comment">//循环找到环的入口</span><br>                fast = fast-&gt;next;<br>            }<br>            <span class="hljs-keyword">while</span>(fast != slow){  <span class="hljs-comment">//循环找到环的入口</span><br>                fast = fast-&gt;next;  <span class="hljs-comment">//两者的速度同步</span><br>                slow = slow-&gt;next;<br>            }<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"环的入口为：%d\n"</span>, fast-&gt;data);<br>            <span class="hljs-keyword">return</span> slow;<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>链式存储结构的节点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他节点。若要寻查结点的直接前驱、则必须从表头指针出发。换句话说，在单链表中，查找直接后继的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。<br>为克服单链表这种单向性的缺点，可利用双向链表（Double Linked List)。在双向链表的节点中有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><p>节点示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span>{</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> 8<span class="hljs-title">prev</span>,*<span class="hljs-title">next</span>;</span><br>}Node;<br></code></pre></td></tr></tbody></table></figure><p>这就生成了一个节点，该节点有一个数据域和两个指针域。</p><h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2><p><img src="https://s2.loli.net/2025/04/05/SiBWQy2NeZFcO8u.png" alt="image-20250405145646106"></p><p>类似地，插入一个新节点，我们的步骤如下：</p><ul><li>使得新节点的prev指针指向头指针，next指针指向<strong>头指针的后一个节点</strong>。</li><li>使<strong>头节点的后一个节点的prev指针</strong>指向新节点</li><li>使头节点的next指针指向新节点</li></ul><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_head</span><span class="hljs-params">(Node *head,<span class="hljs-type">int</span> data)</span><br>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;prev = head;<br>    new_node-&gt;next = head-&gt;next;<br>    <span class="hljs-keyword">if</span> (head-&gt;next != <span class="hljs-literal">NULL</span>)<br>    {<br>        head-&gt;next-&gt;prev = new_node;<br>    }<br>    head-&gt;next = new_node;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>这个相对于头插法的步骤更简单，但是时间复杂度会比较高：</p><ul><li>找到尾节点，把尾节点的next指针指向新节点</li><li>把新节点的prev指针指向尾节点，next指针指向Null</li></ul><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 尾插法,传参直接传入尾节点。</span><br>Node* <span class="hljs-title function_">insertTail</span><span class="hljs-params">(Node *tail, ElemType e)</span> {<br>    Node *p = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    p-&gt;data = e;<br>    p-&gt;prev = tail;<br>    tail-&gt;next = p;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h2><p>类似于单链表的插入，移动到指定点，然后插入。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insertAtPosition</span><span class="hljs-params">(Node** head, <span class="hljs-type">int</span> position, <span class="hljs-type">int</span> value)</span> {<br>    <span class="hljs-comment">// 创建新节点</span><br>    Node* newNode = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    newNode-&gt;data = value;<br>    newNode-&gt;prev = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果链表为空，直接设置为头节点</span><br>    <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) {<br>        *head = newNode;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-comment">// 如果插入位置为0，直接插入到头部</span><br>    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) {<br>        newNode-&gt;next = *head;<br>        (*head)-&gt;prev = newNode;<br>        *head = newNode;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-comment">// 找到插入位置的前一个节点</span><br>    Node* current = *head;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; count &lt; position - <span class="hljs-number">1</span>) {<br>        current = current-&gt;next;<br>        count++;<br>    }<br><br>    <span class="hljs-comment">// 如果位置超出链表长度，返回错误</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置超出链表长度\n"</span>);<br>        <span class="hljs-built_in">free</span>(newNode);<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-comment">// 插入新节点</span><br>    newNode-&gt;next = current-&gt;next;<br>    <span class="hljs-keyword">if</span> (current-&gt;next != <span class="hljs-literal">NULL</span>) {<br>        current-&gt;next-&gt;prev = newNode;<br>    }<br>    current-&gt;next = newNode;<br>    newNode-&gt;prev = current;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="双向链表和顺序表的对比"><a href="#双向链表和顺序表的对比" class="headerlink" title="双向链表和顺序表的对比"></a>双向链表和顺序表的对比</h2><table><thead><tr><th>比较项目</th><th>存储结构</th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td></td><td>存储空间</td><td>预先分配，会出现闲置或溢出现象</td><td>动态分配，不会出现存储空间闲置或溢出现象</td></tr><tr><td>空间</td><td>存储密度</td><td>不用为表示节点间的逻辑关系而增加额外的存储，存储密度等于 1</td><td>需要借助指针来体现元素间的逻辑关系，存储密度小于 1</td></tr><tr><td></td><td>存取元素</td><td>随机存取，按位置访问元素的时间复杂度为 O(1)</td><td>顺序存取，按位置访问元素时间复杂度为 O(n)</td></tr><tr><td>时间</td><td>插入、删除</td><td>平均移动约表中一半元素，时间复杂度为 O(n)</td><td>不需要移动元素，确定插入、删除位置后，时间复杂度为 O(1)</td></tr><tr><td></td><td>适用情况</td><td>1) 表长变化不大，且能事先确定变化的范围2) 很少进行插入或删除操作，经常按元素位置序号访问数据元素</td><td>1) 长度变化较大2) 频繁进行插入或删除操作</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构3：链表的运用和循环链表</title>
    <link href="/posts/Data_structure_3/"/>
    <url>/posts/Data_structure_3/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构3：链表的运用"><a href="#数据结构3：链表的运用" class="headerlink" title="数据结构3：链表的运用"></a>数据结构3：链表的运用</h1><h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h3><p>链表是数据结构中很重要的一个，为此，我会单开一个章节来记录链表的使用，请不要好高骛远。</p><h2 id="例题一：倒数定位"><a href="#例题一：倒数定位" class="headerlink" title="例题一：倒数定位"></a>例题一：倒数定位</h2><blockquote><p>假设该链表只给出了头指针S。在不改变链表的前提下，请设计一个尽可能高效<br>的算法，查找链表中倒数第k个位置上的结点（k为正整数)。若查找成功，算法输出<br>该节点的data域的值，并返回1；否则，只返回0。</p></blockquote><p>值得注意的是，如果我们一直遍历到链表的末尾，再掉头，无疑会导致极高的时间复杂度。所以</p><p>，我们会使用<strong>快慢指针</strong>的速度差来表示k。比如，k == 3，那么，我们设定两个指针Fast和slow，让Fast先走三步，slow再开始走，那么，当Fast走到最后（Fast指针指向空指针）时，slow的位置就是Fast<strong>往前三步</strong>的节点。</p><p><img src="https://s2.loli.net/2025/04/04/IB8pkV7UKvNeMRd.png" alt="image-20250404165404424"></p><p>所以，具体的代码实现是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">findNodeFS</span><span class="hljs-params">(Node *L, <span class="hljs-type">int</span> k)</span><br>{<br>    Node *fast = L-&gt;next;<br>    Node *slow = L-&gt;next;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    {<br>        fast = fast-&gt;next;<br>    }<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)<br>    {<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"倒数第%d个节点值为：%d\n"</span>, k, slow-&gt;data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 查找成功返回1</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="例题二：共同后缀"><a href="#例题二：共同后缀" class="headerlink" title="例题二：共同后缀"></a>例题二：共同后缀</h2><blockquote><p>假定采用带头节点的单链表保存单词，当两个单问有相同的后缀时，则可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示。</p></blockquote><blockquote><p><img src="https://s2.loli.net/2025/04/04/wy8Aav4o7S2sFiI.png" alt="image-20250404200046663"></p></blockquote><blockquote><p>设str1和str2分别指向两个单词所在单链表的头节点，请没计一个时间上尽可能高效的算法，找出由Sr1和str2所指向两个链表共同后缀的起<br>始位置（如图字符i所在结点的位置p)。</p></blockquote><p><strong>这里用哈希表可能更好，但是我还没学到。</strong></p><p>所以，每个链表都有一个相同的后缀，后缀的长度是一定的，所以，我们获取两个链表的长度，他们之差就是后缀的长度，再用<strong>快慢指针</strong>就可以定位到共同后缀的第一个字母了。</p><p><img src="https://s2.loli.net/2025/04/04/en914zBtDJxEaFw.png" alt="image-20250404220225054"></p><h2 id="例题三：绝对值替换"><a href="#例题三：绝对值替换" class="headerlink" title="例题三：绝对值替换"></a>例题三：绝对值替换</h2><blockquote><p>用单链表保存 n 个整数，现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的结点。</p></blockquote><p>我们可以设置一个长度大于<code>n+1</code>（n个整数加上一个数据域为空的头节点就是n+1）的数组a，并将其初始化为0。然后，遍历整个链表，设置条件判断（这里说的date都是实际链表中的数据域的绝对值）：<strong>如果a[date]==0,将其设置为1，如果a[date] == 1，说明该date已经出现过了，就删除该节点</strong>，这就实现了ACM中类似的<strong>打表操作</strong>。遍历到末尾时，执行完毕。</p><p><img src="https://s2.loli.net/2025/04/04/M2tnBNsVv8ZODGx.png" alt="image-20250404220211050"></p><h2 id="例题四：反转链表"><a href="#例题四：反转链表" class="headerlink" title="例题四：反转链表"></a>例题四：反转链表</h2><blockquote><p>给你一个单链表，要求你反转链表方向。</p></blockquote><p>首先，我们需要三个指针，指针first指向NULL，指针Second指向头节点，指针Three指向<strong>头节点之后的一个节点</strong>，然后，只要Second的指针域不为空指针，将Second的指针域指向first，<strong>然后将first指向second，将second指向three</strong>，黑体操作就实现了操作器的移动。直到末尾，我们的反转工作就完成了。</p><p><img src="https://s2.loli.net/2025/04/04/iOBSArZU3DezfL6.png" alt="image-20250404220627277"></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表<br>中最后一个节点的指针域指向头节点，整个链表形成一个环。</p><p>循环链表的判别条件是：<code>P-&gt; != HEAD</code></p><p>但是实际使用中往往不是纯的环，可以是这样的结构：</p><p><img src="https://s21.ax1x.com/2025/04/04/pE626V1.png" alt="image-20250404224200811"></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构2：顺序表与链表</title>
    <link href="/posts/Data_Structure_linked_list/"/>
    <url>/posts/Data_Structure_linked_list/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构2"><a href="#数据结构2" class="headerlink" title="数据结构2"></a>数据结构2</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由<code>n(n&gt;=0)</code>个数据特性相同的元素构成的有限序列，称为线性表。</p><p><code>n == 0</code>时，称为空表。</p><p>对于头一个元素，我们称为“<strong>头节点</strong>”，对于最后一个数据元素“<strong>尾节点</strong>”。</p><p>除了头节点之外，每个元素的前一个元素，叫做“<strong>前驱</strong>”。</p><p>除了尾节点，每个元素的后一个元素叫做“<strong>后驱</strong>”。</p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用一组连续的内存单元依次存储线性表的各个元素，也就是说，逻辑上相邻的元素，实际的物理存储空间也是连续的。</p><p>接下来，我们会构建一个顺序表并且逐步实现“<strong>增删改查</strong>”。</p><p>我们构建一个顺序表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span></span><br><span class="hljs-class">{</span><br>    <span class="hljs-type">int</span> *date;<br>    <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><br>};<br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> date)</span><br>{<br>    l-&gt;date[l-&gt;length] = date;   <span class="hljs-comment">//使用下标来像使用数组一样使用指针是被允许的</span><br>    l-&gt;length++;<br>}<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> {<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">l</span>;</span><br>    add(&amp;l, <span class="hljs-number">20210101</span>);<br>    add(&amp;l, <span class="hljs-number">20210102</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>该代码实现了一个简易的<strong>顺序表</strong>，且配置了<strong>尾部增加</strong>的功能，但是我们往往只需要在中间插入某个元素，可以这么做：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insertElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> date)</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l-&gt;length - <span class="hljs-number">1</span>; i &gt;= index; i--) <br>    {<br>        l-&gt;date[i + <span class="hljs-number">1</span>] = l-&gt;date[i];  <span class="hljs-comment">//这会把待插入元素之后的元素全部往后挪动一个单位。</span><br>    }<br>    l-&gt;date[index] = date;     <span class="hljs-comment">//把输入元素插入到表中</span><br>    l-&gt;length++;               <span class="hljs-comment">//长度更新</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果是在末尾插入，无疑其时间复杂度是最低的，在头节点插入是最大的。</p><p>类似地，我们能够写一个函数实现<strong>删</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> index)</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; l-&gt;length - <span class="hljs-number">1</span>; i++)<br>    {<br>        l-&gt;date[i] = l-&gt;date[i + <span class="hljs-number">1</span>];<br>    }<br>    l-&gt;length--;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在删的基础上修改，就得到了<strong>改</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">changeElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> date)</span><br>{<br>    l-&gt;date[index] = date;<br>}<br></code></pre></td></tr></tbody></table></figure><p>从date[0]开始查找，到length结束，就是<strong>查</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">seekElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> date)</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l-&gt;length; i++)<br>    {<br>        <span class="hljs-keyword">if</span> (l-&gt;date[i] == date)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Element found at index %d\n"</span>, i);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Element not found\n"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>顺序表有很多不方便使用的地方，说白了<strong>，他就是一个套壳的数组。</strong>所以，我们使用了一种链式结构-链表。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>线性表链式存储结构的特点是：<strong>用一组任意的存储单元存储线性表的数据元素</strong>（这组存储单元可以是连续的，也可以是不连续的)。<br>为了表示每个数据元素a与其直接后继数据元素a[i+1]之间的逻辑关系，对数据元素a[i]来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置)。这两部分信息组成数据元素a的存储映像，称为<strong>节点(node)<strong>。<br>结点包括两个域：其中存储数据元素信息的称为</strong>数据域</strong>；存储直接后继存储位置有域称为<strong>指针域</strong>。指针域中存储的信息称作指针或链。</p><p><img src="https://s2.loli.net/2025/04/03/3C7TGKVYlEwgsMO.png" alt="061b5ffce79596f4445207f850c0db6e"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span>{</span>  <span class="hljs-comment">//定义节点</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>}Node;<br><br><br>Node *<span class="hljs-title function_">init</span><span class="hljs-params">()</span>{<br>    Node *head = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    head-&gt;data = <span class="hljs-number">0</span>;    <span class="hljs-comment">//数据域为0</span><br>    head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域为空指针</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    Node *<span class="hljs-built_in">list</span> = init();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链表的延长"><a href="#链表的延长" class="headerlink" title="链表的延长"></a>链表的延长</h2><p>原理：前一个节点的指针指向新插入的节点，使新节点的指针指向<strong>前一个节点原来指向的节点。</strong></p><p><img src="https://s2.loli.net/2025/04/03/X9MRmfDorgd6N1Q.png" alt="image-20250403214812079"></p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>头插法指的是每次都在头节点后面一个位置插入新的数据节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data; <span class="hljs-comment">//引入传入参数</span><br>    new_node-&gt;next = head-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原链表的头节点的指针域</span><br>    head-&gt;next = new_node;  <span class="hljs-comment">//原链表的头节点的指针域指向新节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这会使得每个插入的结构体都处于<strong>头节点的背后</strong>，从而免去了<strong>数组和顺序表</strong>的<strong>元素移动</strong>这一步骤，执行效率快很多。</p><h3 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">list_print</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;   <br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//只要不是空指针，就一直循环</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>        p = p-&gt;next;   <span class="hljs-comment">//指针指向下一个节点</span><br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>尾插法总是在链表的尾部插入新节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_tail</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Node *p = head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//该循环用于找到最后一个节点</span><br>        p = p-&gt;next;<br>    }<br>    p-&gt;next = new_node;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h3><p>我们在特殊情况需要在某两个节点中插入一个新节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//初始化为空指针，防止出错</span><br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到插入位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    new_node-&gt;next = p-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原节点的指针域</span><br>    p-&gt;next = new_node;  <span class="hljs-comment">//原节点的指针域指向新节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>原理是让被删除节点的前一个节点直接指向被删除节点的后一个节点，<strong>链</strong>就是自动排除被删除元素。</p><p><img src="https://s2.loli.net/2025/04/03/CPkFQUfRYxI7D5v.png" alt="image-20250403215033701"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos)</span>{<br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到删除位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    Node *del_node = p-&gt;next;  <span class="hljs-comment">//找到要删除的节点</span><br>    p-&gt;next = del_node-&gt;next;  <span class="hljs-comment">//原节点的指针域指向要删除节点的下一个节点</span><br>    <span class="hljs-built_in">free</span>(del_node);  <span class="hljs-comment">//释放要删除的节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="释放所有节点"><a href="#释放所有节点" class="headerlink" title="释放所有节点"></a>释放所有节点</h3><p>释放，指的是free，指的是将节点占用的堆内存解放出来。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">free_list</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//如果不是尾节点，就一直free下去。</span><br>        Node *temp = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>    }<br>    <span class="hljs-built_in">free</span>(head);  <span class="hljs-comment">//释放头节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span>{</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>}Node;<br><br><br>Node *<span class="hljs-title function_">init</span><span class="hljs-params">()</span>{<br>    Node *head = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    head-&gt;data = <span class="hljs-number">0</span>;    <span class="hljs-comment">//数据域为0</span><br>    head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域为空指针</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data; <span class="hljs-comment">//引入传入参数</span><br>    new_node-&gt;next = head-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原链表的头节点的指针域</span><br>    head-&gt;next = new_node;  <span class="hljs-comment">//原链表的头节点的指针域指向新节点</span><br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">list_print</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;   <br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//只要不是空指针，就一直循环</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>        p = p-&gt;next;   <span class="hljs-comment">//指针指向下一个节点</span><br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//新节点的指针域为空指针</span><br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到插入位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    new_node-&gt;next = p-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原节点的指针域</span><br>    p-&gt;next = new_node;  <span class="hljs-comment">//原节点的指针域指向新节点</span><br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_list</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//循环释放所有节点</span><br>        Node *temp = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>    }<br>    <span class="hljs-built_in">free</span>(head);  <span class="hljs-comment">//释放头节点</span><br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos)</span>{<br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到删除位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    Node *del_node = p-&gt;next;  <span class="hljs-comment">//找到要删除的节点</span><br>    p-&gt;next = del_node-&gt;next;  <span class="hljs-comment">//原节点的指针域指向要删除节点的下一个节点</span><br>    <span class="hljs-built_in">free</span>(del_node);  <span class="hljs-comment">//释放要删除的节点</span><br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert_tail</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Node *p = head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//该循环用于找到最后一个节点</span><br>        p = p-&gt;next;<br>    }<br>    p-&gt;next = new_node;<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    Node *<span class="hljs-built_in">list</span> = init();<br>    insert(<span class="hljs-built_in">list</span>, <span class="hljs-number">2</span>);<br>    list_print(<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：算法时间复杂度</title>
    <link href="/posts/Data_Structure_Algorithm_Time_Complexity/"/>
    <url>/posts/Data_Structure_Algorithm_Time_Complexity/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://s2.loli.net/2025/03/30/c1tjGiXahSgAHD7.png" alt="image-20250330164232582"></p><p><img src="https://s2.loli.net/2025/03/30/VaYd7XsElw6R1om.png" alt="image-20250330164410787"></p><h2 id="虚拟内存地址"><a href="#虚拟内存地址" class="headerlink" title="虚拟内存地址"></a>虚拟内存地址</h2><p>内存条、显卡、各种适配卡都有其各自的存储地址空间。<br>操作系统将这些设备的存储地址空间抽象成一个巨大的一维数组空间。<br>对于内存的每一个字节会分配一个32位或64位的编号，这个编号称为内存地址。</p><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>C程序编译后，会以三种形式使用内存：</p><h4 id="静态全局内存"><a href="#静态全局内存" class="headerlink" title="静态全局内存"></a>静态全局内存</h4><p>静态声明的变量和全局变量使用这部分内存，这些变量在程序开始运行时<br>分配，直到程序终才消失。</p><h4 id="自动内存（栈内存"><a href="#自动内存（栈内存" class="headerlink" title="自动内存（栈内存)"></a>自动内存（栈内存)</h4><p>函数内部声明的变量使用这部分内存，在函数被调用时才创建。</p><h4 id="动态内存（堆内存"><a href="#动态内存（堆内存" class="headerlink" title="动态内存（堆内存)"></a>动态内存（堆内存)</h4><p>根据需求编写代码动态分配内存，可以编写代码释放，内存中的内容直到<br>释放才消失。</p><p>在C语言中，我们需要使用<code>malloc函数</code>实现动态分配内存，他会从堆内存中选取一片空间，并返回这片空间的指针。该函数传入的参数是需要的空间体积。</p><p>完了需要使用free来释放内存</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> {<br>    <span class="hljs-type">char</span> *s;<br>    s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)); <br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">"Hello"</span>); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);  <br>    <span class="hljs-built_in">free</span>(s);         <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为了避免计算错误，我们通常使用<code>sizeof</code>操作符来确保分配的内存大小正确。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>也称渐近时间复杂度，T(n)=O(f(n))<br>随着问题规模n的增大，算法执行时间和增长率和f(n)增长率成正比。</p><p>程序运行的总时间主要与两点有关，执行每条语句的耗时和每条语句的执行效率</p><p>由于语句的执行要由源程序翻译成目标代码，目标代码经装配再执行，因此语句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等)密切相关的。所以，所谓的算法分析并非实际执行所需时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息。</p><h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>时间频度并不是单纯指循环执行次数或条件判断次数，而是指算法中某个基本操作的总执行次数。具体来说：</p><ul><li>如果基本操作是循环体内的计算，时间频度就是循环体的执行次数。</li><li>如果基本操作是条件判断，时间频度就是条件判断的执行次数。</li><li>如果基本操作是某种组合操作（如循环和判断的组合），时间频度就是这些操作的总执行次数。</li></ul><p><img src="https://s2.loli.net/2025/04/01/hFr1XApiw6Gntou.png" alt="image-20250331141248103"></p><p>计算频度指的是代码执行的次数，最外层循环需要在执行<code>n</code>次之后在做一次 (i ==  n)的判断，所以执行频度为n+1，但是外层循环在最后一次判断不会通过，所以内层第一循环不会执行，所以内层循环为<code>n</code>次。</p><p><img src="https://s2.loli.net/2025/04/01/ZMrfsKa6ABmj2Py.png" alt="1.png"></p><p>所以，F(n) = 各层循环的计算频度的和。取得n的最高次幂为M</p><p><img src="https://s2.loli.net/2025/04/01/42JVcyXQWFZOn6q.png" alt="image-20250331143101268"></p><p>上述代码中如果<code>n == 0</code>，那么只会进行一次判断，所以 F(n) = 1，T(n) = O(1)</p><p>如果n很大很大，时间复杂度为1。</p><p><strong>最好时间复杂度</strong>：算法在最好情况下的时间复杂度。<br><strong>最坏时间复杂度</strong>：算法在最坏情况下的时间复杂度。<br><strong>平均时间复杂度</strong>：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计<br>量的加权平均值。<br>对算法时间复杂度的度量，通常只讨论算法在最坏情况下的时间复杂度，<br>即分析在最坏情况下，算法执行时间的上界。</p><h3 id="对数的时间复杂度"><a href="#对数的时间复杂度" class="headerlink" title="对数的时间复杂度"></a>对数的时间复杂度</h3><p><img src="https://s2.loli.net/2025/03/31/iNaXrYRkWyGB3bl.png" alt="image-20250331144619221"></p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度主要用来描述某个算法对应的程序想在计算机上执行，除了用来存储代码和输入数据的内存空间外，还需要额外的空间。</p><h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型 ADT"></a>抽象数据类型 ADT</h2><p>ADT是一种编程概念，用于定义数据的类型及其操作，而不涉及具体实现细节。它提供了一种将数据的逻辑表示与物理实现分离的方法，从而使程序更具可维护性和可扩展性。<br>在C语言中，ADT通常通过结构体和函数的结合来实现。结构体用于定义数据的类型，而函数用于操作这些数据。通过这种方式，程序员可以隐藏数据的内部结构，仅暴露出操作数据的接口。</p><p><strong>说白了，就是java当中的抽象类，是C++ 中的自定义类。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次去医院的思考</title>
    <link href="/posts/think_to_hospital/"/>
    <url>/posts/think_to_hospital/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次去医院的思考"><a href="#记一次去医院的思考" class="headerlink" title="记一次去医院的思考"></a>记一次去医院的思考</h1><p>周三，一个没课的下午，我前往医院看望W，在医院漫长的等待的过程中，我无时无刻忍受着令人作呕的药水味，还有前台电话不绝的响声和护士长的对话声。来来往往的人大多年纪很大，岁月的风在他们脸上吹过，留下阵阵涟漪，他们带着泛黄的电饭锅，刚买的方便面，老旧的热水瓶，推着自己的挚爱亲朋走向病房。<br>我和W的朋友一路奔走，从2号楼到5号楼，期间经过了4次电梯，在医院宽大的特制电梯时，我们往往和一些坐在轮椅上的病人，甚至是躺在转运床上的病人处于同一班电梯，有一个白发苍苍的老人，他无力地咳嗽，有气无力地呼吸。他们依靠挂在一旁的氧气瓶，延续着仅存的生命。</p><blockquote><p>我们每个人都会有这么一天的。</p><p>真正严肃的哲学问题只有一个,那就是自杀。</p></blockquote><p>死亡不是生命的BUG，他是生命的预置程序。磨损的物理结构，老化的胶原蛋白，就已经表明了生命的局限。任何生命都有黄昏之时，但是我们总是在害怕死亡。</p><p>我们或许无法选择死亡的时间与方式，但可以选择如何填充有限的生命。当一位HIV患者从绝望中学会接纳疾病、重新定义生活时，他领悟到生命的珍贵不在于长度，而在于为每个瞬间赋予意义。这让人想起余华在《活着》中的洞见：活着本身就是目的，无需附加宏大的意义。那些在医院走廊里虔诚祈祷的人们，那些在手术室外紧握的双手，都在用最朴素的方式诠释着存在的本质——即便躯体衰败，对爱与希望的渴望永不熄灭。</p><p><img src="https://s2.loli.net/2025/03/19/9AIQJ3Hi8k1T2Zd.jpg"></p><blockquote><p>医院的墙壁比教堂聆听过更多虔诚的祈祷，机场比婚礼殿堂见证了更多真挚的亲吻。</p></blockquote><p>这些祈祷从不关于永生，而是关于如何让存在的每一刻都迸发出尊严的火花，关于如何让至爱之人留在身边的每一面都在记忆中留下最深刻的烙印，关于如何在时间的洪流中留下自己所爱的一切。或许就是生命最深刻的悖论：承认死亡的必然，反而让我们更炽热地拥抱当下。</p><p>写到这里，也许我们走向人生的终点，能够多一份从容和无悔。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《战争之王》：必须存在的恶魔</title>
    <link href="/posts/Lord_of_War/"/>
    <url>/posts/Lord_of_War/</url>
    
    <content type="html"><![CDATA[<h2 id="矛盾与荒谬并行的世界"><a href="#矛盾与荒谬并行的世界" class="headerlink" title="矛盾与荒谬并行的世界"></a>矛盾与荒谬并行的世界</h2><blockquote><p> “可能对你来说我是一个恶魔，但不幸的是，我是一个必须存在的恶魔。”              ——尤里</p></blockquote><p>​       尤里的发迹史堪称全球化时代的资本寓言。从基辅餐馆的潦倒移民到掌控全球地下军火贸易的”战争之王”，他的成功轨迹完美契合新自由主义经济法则。几十本护照和假身份帮助他在边境畅通无阻；把武装直升机的武器和本体分开运输，就成了<strong>“人道主义”</strong>救援直升机；面对到来的国际刑警，自己的船名可以随时随地变换；赶上了冷战结束的黄金时代，他立马将那些没有敌人的优良武器收入囊中，从简易的AK47到厚重的装甲车，他是这些穷途末路的将军最好的生意伙伴，也是非洲军阀最好的供应商。</p><p>​       很显然，尤里背后的大权加冕的大人物不想放弃这位<strong>干净利索</strong>的棋子，这就是为什么最后的尤里在铁证如山的情况下仍不会在军事法庭待上一秒。而这些大人物，可能上一秒还在联合国会议上慷慨激昂地控诉着战争俘虏受到了非人道的虐待，发誓要为非洲的战乱和贫穷负责，下一秒就默许自己的手下继续这场黑暗且宏伟的地下军火交易。因为他们需要战争，而目的可以是五花八门的。</p><blockquote><p>我们需要战争，而不需要敌人。</p></blockquote><p>​     战争可以被用来解决国内供大于求的问题，可以将人民的矛头不再对准统治阶级，也可以使得小国愿意为军火拿出自己几十年来积累的财富，而这些财富大多流入了<strong>”政治家“</strong>及其背后资本的腰包。这就是这个世界的矛盾所在，每个掌权者都想让世界更好，但在那之前，更重要的是不计手段地来进行财产转移，让自己的国家更富有，强大，最后是霸权。所以像尤里这样的恶魔必不可少，一旦他良心发现，<strong>就会有下一个更彻底的恶魔替代他。</strong></p><h2 id="满腔热血无法抵抗时代的洪流"><a href="#满腔热血无法抵抗时代的洪流" class="headerlink" title="满腔热血无法抵抗时代的洪流"></a>满腔热血无法抵抗时代的洪流</h2><p>​     影片中，国际刑警杰克没有尤里说的<strong>”价码“</strong>，他秉持自己的正义，坚持合法地惩罚尤里。可就是这么一个尽职尽责的好警察，最后在强权之下也没有任何办法。他的顶头上司，美国总统一直是这种交易的常客，他需要尤里这样的人才武装非洲的军阀，从暗中操作的战争中赚得盆满钵满。</p><blockquote><p>要是没有我，他们根本无法打一场像样的战争。                                        ——尤里</p></blockquote><p>​    杰克最后可能会愤怒，会感叹于世间的不公，甚至威胁辞职，但这些都不重要了，因为<strong>个体善恶在系统惯性面前微不足道。</strong>尤里和他的博弈，赌注从来都不是下半生的自由，而是仅存的<strong>良心</strong>。在政客的眼中，杰克的职责就在于努力去解这个顶头上司留下的谜题，而揭开谜底的过程，能够让世界看到包括<strong>联合国五常</strong>在内的联合国对<strong>维护世界和平的决心</strong>，<strong>至少看起来是这样。</strong></p><blockquote><p><strong>在系统性暴力中，个体的“生存智慧”恰恰是对战争机器的被动妥协</strong>。</p></blockquote><p>​      影片真正的恐怖不在于展现多少战争残酷，而在于揭示我们早已深陷其中却不自知的生存真相——在资本全球化的精密系统里，相比于成为战争的牺牲品，我们每个人都倾向于成为某种意义上的**”战争之王”**。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
      <tag>世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024这一年</title>
    <link href="/posts/2024/"/>
    <url>/posts/2024/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我的2024，被高考泾渭分明地划分为了两半。</p><h2 id="1-6月"><a href="#1-6月" class="headerlink" title="1-6月"></a>1-6月</h2><p>我有个特点，一些令我感到痛苦的经历不会在我的记忆中存在太久。</p><p>1月到6月，我已经记得不大清的，我直接的那段时间太阳很大，血红的标语贴的到处都是，我们披坚执锐，在数不清的模拟中挣扎，在无数次西西弗斯一般的努力中等待时间流逝，在那段时间，有因为一句无聊的笑话引发的快乐，有模拟考试名次渐进的喜悦，有深夜备战的痛苦，我只记得那时，全家人的期望都在我身上，我只记得我必须全力以赴。</p><p>那个时期的自己有极度可怖的自律，献祭自己的心理和生理健康来夺取那几分，脑子里只知道<strong>卷</strong>，卷得天昏地暗，卷的不知疲倦，用尽了今天，又把希望寄托于明天。</p><blockquote><p>语文应该是一门很浪漫的学科，如果不是为了赶路，为了稳定的得分，也许我的文笔看起来就不会这么奇怪，可是，现在我记得的只有并列式和层进式的可悲的议论结构了。</p></blockquote><p>在自信与努力并存的等待中，我们迎来了最后的高考，不幸的是，这是我的死地。</p><p>我记不大清查分时的情景，我只记得我看到屏幕上的“675”（赋分制，对应大陆分数大概630左右），那时候脑子里只剩下震惊和麻木，随即就是懊悔。</p><p>后来，父母没对我多说什么，只是一个劲地安慰说没事，但我知道自己已经失败了，彻彻底底的失败。</p><blockquote><p>我们失败了。失败的意义就在于我们让所有人都感到失望，包括我们自己。    ——《超脱》</p></blockquote><p>后来，我在爸爸的手机里发现了他发给妈妈的语音，内容我记得不大清了，好像是说我三模考的一次比一次好，结果把最差的一次留给了高考。我麻木的思维在那是已经没有知觉了，只有我的心知道某个地方悄悄地碎掉了。</p><blockquote><p>我不大想写下去了，原谅我。</p></blockquote><p>抱着这般粉饰太平的冷静与坦然，这一切过的还算舒心。</p><h2 id="身后事"><a href="#身后事" class="headerlink" title="身后事"></a>身后事</h2><p>六月十八号，我们在家里给母亲庆祝生日，也许父母不是不喜欢吃蛋糕，他们喜欢的是过生日时的氛围和被给予的孩童时期的片刻的自由，至少那一个晚上，是属于我的母亲的。</p><p>那个蛋糕价格不低，可是父亲为了让她过上自打养小孩以来的第一次生日，倒也顾不上价格，那个晚上，天上的星旋转着，我们在家中欢庆，快乐且温暖。</p><p>七月二十九日，“接受”现实的我收到了杭电的通知书，那时我们全家都很高兴，可是只有我知道我的心有一处是空缺的，是破碎不堪的。</p><p>八月二日，我随母亲回广西。</p><p>？月？日，我记不清。</p><p>我把自己锁在这异国他乡的房间里，声嘶力竭地对着墙大吼，把所有的呼唤置之门外，把手机关机，让这个空间中只有一个手足无措的孩子的挣扎。当时占据头脑的不是愤怒，而是恐惧，是惶惶不可终日的痛苦，像是被宣判了死刑的囚徒，背着十字架在无人的荒漠中濒临绝望。</p><p>我记不清原因。</p><p>后来，这一切都结束了，时间按部就班地来到了开学的日子，任凭我如何懊悔。</p><p>我独自一人搭上了前往杭州的飞机，心里全是惊喜，不知道未来的生活是怎样的。</p><p>到了学校，我看见了高耸的楼宇，我看见了大城市的车水马龙，我看见了一个新的开始。</p><p><a href="https://imgse.com/i/pAxainS"><img src="https://s21.ax1x.com/2024/12/29/pAxainS.jpg" alt="pAxainS.jpg"></a></p><blockquote><p>拍摄于某个平静的下午</p></blockquote><p>………..</p><p>又过了几个月，我已记不清是什么时候。</p><p>我发现，大学的生活远远不如我所期待，“考上大学就轻松了”是一个彻头彻尾的谎言，所以，如果我看见有人旷课熬夜打游戏，我反倒认为这是正确的，他只不过是在实践自己在无数个地狱中赖以生存的信念罢了。高数和线代，两座大山，再加上教师难以接受的教学风格，作为大一新生的我实在很难跟上，我只记得学的懵懵懂懂，又带着这点一知半解参加了期中考，以68和77的成绩草草收场。</p><p>我在网上看了很多信息，知道了当前就业形势很不好，经济腾飞的副作用在这个时期显现出来。考研吗？现在学历贬值的厉害，统考人数不断下滑，机关对考研生不再感冒，考研之后到底是深造还是在啃老呢？卷竞赛吗？面对一群自从高中就有信息奥基础的人来说，我有任何优势吗？就这么扎扎实实地学习然后本科就业？学校教的过时的知识让我没了说话的底气。</p><blockquote><p>抱着这种迷茫，我一路写到了这里。</p></blockquote><ul><li>我试图让我的大学生活变得和高三一样，我试图复制应试背景下的成功。</li><li>我试图让我表面上的勤奋掩饰我迟于改变的懒惰。</li><li>我试图让曾经的机器取代现在的自己。</li></ul><p>翻找我的日记本，记忆如潮水般涌来。</p><p>我看见了曾经那个拥有无限可能的自己，他想参加OI而不带功利，不计后果，他想为心爱之人吹奏一支曲子而不在乎那人是否已经离去，他想……我看见在被高考招安之前的自己，像是一个燃烧的勇士，即使公主已经死去，他仍要把利剑刺入恶龙的咽喉。他是那么的意气风发，无所顾忌。</p><blockquote><p>我看见特工正处在明媚的阳光下和同事野餐，我看见他为了队里的新队员吹奏新曲，可我只发现我身处一片阴影之中，我与他样貌相似但没有色彩，我只是他的影子。</p></blockquote><p>高考已然成为历史，我也应该放过我自己，放过那个在缺氧环境下窒息的苦行僧。</p><p>我要重新学会畅快地呼吸，重新认识世界上的一切，重新和自己相识。</p><p>我要找回那个意气风发，从容不迫的自己。</p><blockquote><p>祝我好运</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫雷开发笔记</title>
    <link href="/posts/minesweeper/"/>
    <url>/posts/minesweeper/</url>
    
    <content type="html"><![CDATA[<h1 id="扫雷开发笔记"><a href="#扫雷开发笔记" class="headerlink" title="扫雷开发笔记"></a>扫雷开发笔记</h1><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://s2.loli.net/2024/12/12/I9y8N2B4luAZMUC.png" alt="扫雷游戏开发(1)"></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://s2.loli.net/2024/12/13/bCRM3mutWTE7QV1.png" alt=".png"></p><h2 id="难度设置"><a href="#难度设置" class="headerlink" title="难度设置"></a>难度设置</h2><p>简单：9*9 10雷</p><p>中级： 16*16 40雷</p><p>困难 ： 20*20  70雷</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>见<a href="https://github.com/Dr-WillMos/Minesweeper">Github仓库</a>，如果喜欢可以点个Star。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们使用了二位数组来实现扫雷，因Easyx库使用了C++的库且C++已适配绝大部分C语言的语法，所以我们提交的是.cpp文件，并封装了exe文件，可以直接双击运行。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>使用IDE：VS 2022</p><p>项目属性：使用多字节字符集</p><p>C语言标准：C89</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;easyx.h&gt;</span>  <span class="hljs-comment">// EasyX图形库，安装方式请见官网文档</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span>       <span class="hljs-comment">//计时库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span> <span class="hljs-comment">//windows的库，用于获取时间戳</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ROW 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_COL 20       <span class="hljs-comment">//以最大雷区作为常量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMG_SIZE 40     <span class="hljs-comment">// 这个数字用于实现从二维数组到游戏窗口的坐标转化</span></span><br><br>IMAGE img[<span class="hljs-number">13</span>];           <span class="hljs-comment">// 以数组的方式引入图片</span><br><span class="hljs-type">int</span> mine[MAX_ROW + <span class="hljs-number">2</span>][MAX_COL + <span class="hljs-number">2</span>];  <span class="hljs-comment">//+2是为了解决边缘问题</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mx;<br><span class="hljs-type">int</span> my;<br><span class="hljs-type">int</span> ROW = <span class="hljs-number">16</span>, COL = <span class="hljs-number">16</span>, MINE_NUM = <span class="hljs-number">40</span>;<br><br><span class="hljs-comment">//定义时间常量</span><br><span class="hljs-type">time_t</span> start_time;<br><span class="hljs-type">time_t</span> current_time;<br><span class="hljs-type">int</span> elapsed_time;<br></code></pre></td></tr></tbody></table></figure><p><strong>时间戳：</strong>时间戳是使用<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550?fromModule=lemma_inlink">数字签名</a>技术产生的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370?fromModule=lemma_inlink">数据</a>，因为程序的运行时间不同，时间戳也会不断变化，我们使用它作为生成随机数的种子。</p><h2 id="游戏初始化模块（gameInit"><a href="#游戏初始化模块（gameInit" class="headerlink" title="游戏初始化模块（gameInit)"></a>游戏初始化模块（gameInit)</h2><h3 id="开始界面停留"><a href="#开始界面停留" class="headerlink" title="开始界面停留"></a>开始界面停留</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C">initgraph(IMG_SIZE * ROW + <span class="hljs-number">240</span>, IMG_SIZE * COL);  <span class="hljs-comment">//创建游戏窗口</span><br><span class="hljs-type">int</span> mid1 = (IMG_SIZE * ROW + <span class="hljs-number">240</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> mid2 = (IMG_SIZE * COL) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y_length = IMG_SIZE * COL;<br><span class="hljs-type">int</span> x_length = IMG_SIZE * ROW + <span class="hljs-number">240</span>;<br><br>settextstyle(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">"宋体"</span>));         <span class="hljs-comment">//这里是以字符的左上角作为坐标基准</span><br>settextcolor(WHITE);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* text = <span class="hljs-string">"开始"</span>;<br><br><span class="hljs-comment">// 获取字符串的宽度和高度</span><br><span class="hljs-type">int</span> textWidth = textwidth(text);<br><span class="hljs-type">int</span> textHeight = textheight(text);<br><br><span class="hljs-comment">// 计算字符串的中央位置</span><br><span class="hljs-type">int</span> centerX = x_length / <span class="hljs-number">2</span> - textWidth / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> centerY = y_length / <span class="hljs-number">2</span> - textHeight / <span class="hljs-number">2</span>;<br><br><br>cleardevice();<br><br>outtextxy(centerX, centerY, text);<br><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>    ExMessage em;<br>    <span class="hljs-keyword">if</span> (peekmessage(&amp;em, EX_MOUSE)) {<br>        <span class="hljs-keyword">if</span> (em.message == WM_LBUTTONDOWN) {<br>            <span class="hljs-keyword">if</span> (em.x &gt;= centerX &amp;&amp; em.x &lt;= centerX + textWidth &amp;&amp;<br>                em.y &gt;= centerY &amp;&amp; em.y &lt;= centerY + textHeight) {     <span class="hljs-comment">// 点击开始（处于坐标范围内），否则用户永远卡在该循环内。</span><br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里使通过点击处是否处于字符坐标区间内来判定是否开始。</p><h3 id="初始化计时器"><a href="#初始化计时器" class="headerlink" title="初始化计时器"></a>初始化计时器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 初始化计时器</span><br>start_time = time(<span class="hljs-literal">NULL</span>);<br>current_time = start_time;<br>elapsed_time = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 设置字体和颜色</span><br>settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">"宋体"</span>));<br>settextcolor(RGB(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, _T(<span class="hljs-string">"Time: "</span>));<br></code></pre></td></tr></tbody></table></figure><p>这里没什么好说的。</p><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 加载图片</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">260</span>] = <span class="hljs-string">""</span>;      <span class="hljs-comment">//用于存储图片路径</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; ++i) {<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<span class="hljs-comment">//每次循环前，使用 memset 函数将 buf 数组清零</span><br>    sprintf_s(buf, <span class="hljs-string">"./img/%d.jpg"</span>, i);  <span class="hljs-comment">//将路径格式化</span><br>    loadimage(&amp;img[i], buf, IMG_SIZE, IMG_SIZE);<br>}<br></code></pre></td></tr></tbody></table></figure><p>memset函数能够快速填充空字符来清楚buff数组。</p><h3 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">LARGE_INTEGER frequency;<br>LARGE_INTEGER start;<br>QueryPerformanceFrequency(&amp;frequency);<br>QueryPerformanceCounter(&amp;start);<br>srand((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(start.QuadPart));<br></code></pre></td></tr></tbody></table></figure><p>以当前时间戳来作为生成随机数的种子，使得在短时间内多次启动程序生成的随机数都是不同的。</p><h3 id="生成雷区"><a href="#生成雷区" class="headerlink" title="生成雷区"></a>生成雷区</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> row, col;<br><span class="hljs-built_in">memset</span>(mine, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mine));  <span class="hljs-comment">// 清空雷区</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MINE_NUM;) {  <span class="hljs-comment">//随机生成雷</span><br>    row = rand() % ROW + <span class="hljs-number">1</span>;<br>    col = rand() % COL + <span class="hljs-number">1</span>;        <span class="hljs-comment">//rand函数，1-9之间随机生成值</span><br>    <span class="hljs-keyword">if</span> (mine[row][col] == <span class="hljs-number">0</span>) {<br>        mine[row][col] = <span class="hljs-number">9</span>;      <span class="hljs-comment">//9表示地雷</span><br>        ++i;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="更新格子数据"><a href="#更新格子数据" class="headerlink" title="更新格子数据"></a>更新格子数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 更新周围数字（九宫格内雷的数量）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span>) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = i - <span class="hljs-number">1</span>; a &lt;= i + <span class="hljs-number">1</span>; ++a) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = j - <span class="hljs-number">1</span>; b &lt;= j + <span class="hljs-number">1</span>; ++b) {<br>                    <span class="hljs-keyword">if</span> (mine[a][b] != <span class="hljs-number">9</span>) {<br>                        mine[a][b]++;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="数据偏移加密"><a href="#数据偏移加密" class="headerlink" title="数据偏移加密"></a>数据偏移加密</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 给所有格子加上偏移量，防止与被翻开格子冲突，也是加密数据的一种表现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        mine[i][j] += <span class="hljs-number">20</span>;  <span class="hljs-comment">//只有显示为29的才是雷，在20-28之间的都是非雷格子，点击翻开格子和递归翻开格子的操作就是-20</span><br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>类似于凯撒密码，但这里的偏移值为20</p><h2 id="游戏胜利判断模块-isOver"><a href="#游戏胜利判断模块-isOver" class="headerlink" title="游戏胜利判断模块(isOver)"></a>游戏胜利判断模块(isOver)</h2><h3 id="检查是否踩到雷"><a href="#检查是否踩到雷" class="headerlink" title="检查是否踩到雷"></a>检查是否踩到雷</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> isHitMine = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//布尔型变量，只有0和1两种形式（即true和flase）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span> &amp;&amp; (mine[i][j] &lt; <span class="hljs-number">20</span> || mine[i][j] &gt; <span class="hljs-number">29</span>)) {  <span class="hljs-comment">// 雷被翻开</span><br>            isHitMine = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (isHitMine) <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>布尔型变量：其只有0和1两种形式，即flase和true，常作为条件判断。</p><h3 id="重置计数器并弹出消息盒子"><a href="#重置计数器并弹出消息盒子" class="headerlink" title="重置计数器并弹出消息盒子"></a>重置计数器并弹出消息盒子</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 如果踩雷</span><br><span class="hljs-keyword">if</span> (isHitMine) {<br>    <span class="hljs-type">int</span> ok = MessageBox(GetHWnd(), <span class="hljs-string">"还要排雷吗"</span>, <span class="hljs-string">"你没了"</span>, MB_OKCANCEL);  <span class="hljs-comment">//easyx的函数，弹出消息盒子</span><br>    <span class="hljs-keyword">if</span> (ok == IDOK) {<br>        <span class="hljs-comment">// 重置雷区</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>                <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span>) {<br>                    mine[i][j] += <span class="hljs-number">20</span>;         <span class="hljs-comment">// 将雷标记为已翻开</span><br>                }<br>            }<br>        }<br>        num = <span class="hljs-number">0</span>;<br>        start_time = time(<span class="hljs-literal">NULL</span>);        <span class="hljs-comment">// 重置游戏开始时间</span><br>        elapsed_time = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 重置计时器</span><br>        gameInit();                        <span class="hljs-comment">// 重新初始化雷区和图像</span><br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 退出游戏</span><br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><code>exit(-1);</code>：终止当前进程。</p><h3 id="检查非雷格子被翻开"><a href="#检查非雷格子被翻开" class="headerlink" title="检查非雷格子被翻开"></a>检查非雷格子被翻开</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> uncoveredNonMine = <span class="hljs-number">0</span>;            <span class="hljs-comment">//翻开的非雷格子数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] &lt; <span class="hljs-number">20</span> &amp;&amp; mine[i][j] != <span class="hljs-number">9</span>) {          <span class="hljs-comment">// 非雷且已翻开</span><br>            uncoveredNonMine++;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="游戏绘制模块-gameDraw"><a href="#游戏绘制模块-gameDraw" class="headerlink" title="游戏绘制模块 (gameDraw)"></a>游戏绘制模块 (gameDraw)</h2><h3 id="对指定格子进行贴图"><a href="#对指定格子进行贴图" class="headerlink" title="对指定格子进行贴图"></a>对指定格子进行贴图</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-type">int</span> x = (j - <span class="hljs-number">1</span>) * IMG_SIZE;<br>        <span class="hljs-type">int</span> y = (i - <span class="hljs-number">1</span>) * IMG_SIZE;<br>        <span class="hljs-keyword">if</span> (mine[i][j] &gt;= <span class="hljs-number">0</span> &amp;&amp; mine[i][j] &lt;= <span class="hljs-number">9</span>) {<br>            putimage(x, y, &amp;img[mine[i][j]]);<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mine[i][j] &gt;= <span class="hljs-number">20</span> &amp;&amp; mine[i][j] &lt; <span class="hljs-number">30</span>) {<br>            putimage(x, y, &amp;img[<span class="hljs-number">10</span>]);<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mine[i][j] &gt; <span class="hljs-number">29</span>) {<br>            putimage(x, y, &amp;img[<span class="hljs-number">11</span>]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="显示计数器"><a href="#显示计数器" class="headerlink" title="显示计数器"></a>显示计数器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-comment">// 显示计时器</span><br>    <span class="hljs-type">char</span> time_str[<span class="hljs-number">20</span>];<br>    sprintf_s(time_str, <span class="hljs-string">"%d s"</span>, elapsed_time);<br>    settextcolor(RGB(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br>    outtextxy(IMG_SIZE * ROW + <span class="hljs-number">80</span>, <span class="hljs-number">20</span>, _T(<span class="hljs-string">"     "</span>));<br>    settextcolor(RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    outtextxy(IMG_SIZE * ROW + <span class="hljs-number">110</span>, <span class="hljs-number">20</span>, time_str);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="递归展开格子模块（openNUll）"><a href="#递归展开格子模块（openNUll）" class="headerlink" title="递归展开格子模块（openNUll）"></a>递归展开格子模块（openNUll）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (mine[r][c] == <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r - <span class="hljs-number">1</span>; i &lt;= r + <span class="hljs-number">1</span>; ++i) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = c - <span class="hljs-number">1</span>; j &lt;= c + <span class="hljs-number">1</span>; ++j) {<br>            <span class="hljs-keyword">if</span> ((mine[i][j] == <span class="hljs-number">20</span> || mine[i][j] != <span class="hljs-number">29</span>) &amp;&amp; mine[i][j] &gt; <span class="hljs-number">9</span>) {<br>                mine[i][j] -= <span class="hljs-number">20</span>;<br>                num++;<br>                openNUll(i, j);<br>            }<br>        }<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="开始菜单模块-showMenu"><a href="#开始菜单模块-showMenu" class="headerlink" title="开始菜单模块(showMenu)"></a>开始菜单模块(showMenu)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C">initgraph(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);  <span class="hljs-comment">// 创建菜单窗口</span><br>setbkcolor(WHITE);<br>cleardevice();<br><br>settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">"宋体"</span>));<br>settextcolor(BLACK);<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">50</span>, _T(<span class="hljs-string">"选择游戏难度："</span>));<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">100</span>, _T(<span class="hljs-string">"1. 简单"</span>));<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">140</span>, _T(<span class="hljs-string">"2. 中等"</span>));<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">180</span>, _T(<span class="hljs-string">"3. 困难"</span>));<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>    ExMessage em;<br>    <span class="hljs-keyword">if</span> (peekmessage(&amp;em, EX_MOUSE)) {<br>        <span class="hljs-keyword">if</span> (em.message == WM_LBUTTONDOWN) {<br>            <span class="hljs-keyword">if</span> (em.x &gt; <span class="hljs-number">150</span> &amp;&amp; em.x &lt; <span class="hljs-number">250</span> &amp;&amp; em.y &gt; <span class="hljs-number">100</span> &amp;&amp; em.y &lt; <span class="hljs-number">120</span>) {     <span class="hljs-comment">// 点击简单（处于坐标范围内）</span><br>                ROW = <span class="hljs-number">9</span>;<br>                COL = <span class="hljs-number">9</span>;<br>                MINE_NUM = <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (em.x &gt; <span class="hljs-number">150</span> &amp;&amp; em.x &lt; <span class="hljs-number">250</span> &amp;&amp; em.y &gt; <span class="hljs-number">140</span> &amp;&amp; em.y &lt; <span class="hljs-number">160</span>) {   <span class="hljs-comment">// 点击中等</span><br>                ROW = <span class="hljs-number">16</span>;<br>                COL = <span class="hljs-number">16</span>;<br>                MINE_NUM = <span class="hljs-number">40</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (em.x &gt; <span class="hljs-number">150</span> &amp;&amp; em.x &lt; <span class="hljs-number">250</span> &amp;&amp; em.y &gt; <span class="hljs-number">180</span> &amp;&amp; em.y &lt; <span class="hljs-number">200</span>) {    <span class="hljs-comment">// 点击困难</span><br>                ROW = <span class="hljs-number">20</span>;<br>                COL = <span class="hljs-number">20</span>;<br>                MINE_NUM = <span class="hljs-number">70</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br>}<br>closegraph();  <span class="hljs-comment">// 关闭菜单窗口</span><br></code></pre></td></tr></tbody></table></figure><h2 id="侧边栏提示模块-tips"><a href="#侧边栏提示模块-tips" class="headerlink" title="侧边栏提示模块(tips)"></a>侧边栏提示模块(tips)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">current_time = time(<span class="hljs-literal">NULL</span>);<br>elapsed_time = (<span class="hljs-type">int</span>)(current_time - start_time);<br><br><span class="hljs-type">char</span> time_str[<span class="hljs-number">20</span>];<br>sprintf_s(time_str, <span class="hljs-string">"%d s"</span>, elapsed_time);<br><br>settextcolor(RGB(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));         <span class="hljs-comment">//设置时间字体颜色。</span><br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">85</span>, <span class="hljs-number">20</span>, time_str);                 <span class="hljs-comment">//easyx的输出</span><br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">50</span>, _T(<span class="hljs-string">"鼠标左键：翻开格子"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">80</span>, _T(<span class="hljs-string">"鼠标右键：标记地雷"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">110</span>, _T(<span class="hljs-string">"所有的非雷格子都被打开"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">140</span>, _T(<span class="hljs-string">"才算游戏胜利"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">170</span>, _T(<span class="hljs-string">"祝你游戏愉快"</span>));<br><br></code></pre></td></tr></tbody></table></figure><h2 id="鼠标消息处理模块-mouseClick"><a href="#鼠标消息处理模块-mouseClick" class="headerlink" title="鼠标消息处理模块(mouseClick)"></a>鼠标消息处理模块(mouseClick)</h2><h3 id="左键点击并保护雷区"><a href="#左键点击并保护雷区" class="headerlink" title="左键点击并保护雷区"></a>左键点击并保护雷区</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> firstClick = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 用一个变量标记是否为第一次点击</span><br>ExMessage em;                                 <span class="hljs-comment">//Easyx函数存储消息</span><br><span class="hljs-keyword">if</span> (peekmessage(&amp;em, EX_MOUSE)) {<br>    mx = em.y / IMG_SIZE + <span class="hljs-number">1</span>;<br>    my = em.x / IMG_SIZE + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (em.lbutton) {          <span class="hljs-comment">// 鼠标左键点击</span><br>        <span class="hljs-keyword">if</span> (firstClick) {<br>            firstClick = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记第一次点击已完成，准备随机布雷。</span><br><br>            <span class="hljs-comment">// 生成雷区并保护第一次点击及其周围，不能在周围生成雷</span><br>            <span class="hljs-type">int</span> protectedRow = mx;<br>            <span class="hljs-type">int</span> protectedCol = my;           <span class="hljs-comment">//获取鼠标点击位置。</span><br><br>            <span class="hljs-comment">// 随机生成雷区</span><br>            <span class="hljs-type">int</span> row, col;<br>            <span class="hljs-built_in">memset</span>(mine, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mine));  <span class="hljs-comment">// 清空雷区，清除gameinit函数的第一次结果</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MINE_NUM;) {<br>                row = rand() % ROW + <span class="hljs-number">1</span>;<br>                col = rand() % COL + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 跳过第一次点击区域及其周围九宫格</span><br>                <span class="hljs-keyword">if</span> (row &gt;= protectedRow - <span class="hljs-number">1</span> &amp;&amp; row &lt;= protectedRow + <span class="hljs-number">1</span> &amp;&amp;<br>                    col &gt;= protectedCol - <span class="hljs-number">1</span> &amp;&amp; col &lt;= protectedCol + <span class="hljs-number">1</span>) {<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br><br>                <span class="hljs-keyword">if</span> (mine[row][col] == <span class="hljs-number">0</span>) {<br>                    mine[row][col] = <span class="hljs-number">9</span>;  <span class="hljs-comment">// 9 表示地雷</span><br>                    ++i;<br>                }<br>            }<br></code></pre></td></tr></tbody></table></figure><h3 id="更新周围数据"><a href="#更新周围数据" class="headerlink" title="更新周围数据"></a>更新周围数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 更新周围数字</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span>) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = i - <span class="hljs-number">1</span>; a &lt;= i + <span class="hljs-number">1</span>; ++a) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = j - <span class="hljs-number">1</span>; b &lt;= j + <span class="hljs-number">1</span>; ++b) {<br>                    <span class="hljs-keyword">if</span> (mine[a][b] != <span class="hljs-number">9</span>) {<br>                        mine[a][b]++;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        mine[i][j] += <span class="hljs-number">20</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="翻开格子"><a href="#翻开格子" class="headerlink" title="翻开格子"></a>翻开格子</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-keyword">if</span> (mine[mx][my] &gt; <span class="hljs-number">9</span>) {<br>        mine[mx][my] -= <span class="hljs-number">20</span>;<br>        openNUll(mx, my);<br>        num++;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="右键标记功能"><a href="#右键标记功能" class="headerlink" title="右键标记功能"></a>右键标记功能</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (em.rbutton) {  <span class="hljs-comment">// 鼠标右键标记</span><br>            <span class="hljs-keyword">if</span> (mine[mx][my] &gt; <span class="hljs-number">9</span> &amp;&amp; mine[mx][my] &lt;= <span class="hljs-number">29</span>) {<br>                mine[mx][my] += <span class="hljs-number">20</span>;<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                mine[mx][my] -= <span class="hljs-number">20</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="主函数部分（main）"><a href="#主函数部分（main）" class="headerlink" title="主函数部分（main）"></a>主函数部分（main）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    showMenu();<br>    gameInit();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {          <span class="hljs-comment">//不断循环保证数据随时更新</span><br>        tips();<br>        mouseClick();<br>        gameDraw();<br>        isOver();<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="整体原理"><a href="#整体原理" class="headerlink" title="整体原理"></a>整体原理</h2><ul><li><strong>菜单的调用</strong>程序从 <code>main</code>函数开始执行，首先调用 <code>showMenu</code>函数创建一个菜单窗口，展示不同难度选项供玩家选择，玩家通过鼠标点击相应区域确定游戏难度（简单、中等、困难），对应不同的行数、列数和雷的数量设置。</li><li><strong>初始化操作</strong>选择完难度后，<code>gameInit</code>函数被调用，进行多方面的初始化操作。先是利用 <code>initgraph</code>初始化图形界面，设置好窗口大小并准备显示游戏内容。接着初始化计时器，记录游戏开始时间，用于后续统计游戏用时。同时，加载游戏中所需的各类图片资源，像代表数字、空白格、地雷等不同状态的图片。然后，生成雷区布局，通过获取合适的随机数种子，按照设定好的雷数，在排除首次点击及其周边九宫格范围的情况下，随机放置地雷，并根据地雷分布更新周围格子所对应的周边地雷数量，最后通过给每个格子数据添加偏移量的方式对雷区数据进行加密处理，便于后续判断格子状态和展开操作。</li><li><strong>界面更新与提示</strong>：在游戏运行的主循环（<code>main</code>函数中的 <code>while (true)</code>循环）里，每次循环都会调用 <code>tips</code>函数来更新游戏界面右侧的提示信息，包括显示游戏耗时以及告知玩家鼠标左右键的操作功能（左键翻开格子、右键标记地雷等），让玩家清楚游戏进展情况和操作方法。</li><li><strong>鼠标交互处理</strong>：<code>mouseClick</code>函数负责处理鼠标消息。对于鼠标左键点击，若为首次点击，会保护点击位置及其九宫格区域不布雷，随后生成雷区、更新周围雷数并加密雷区；若非首次点击，会根据点击格子的状态进行相应处理，比如翻开空白格及递归展开其周围空白格，同时统计翻开格子数量。对于鼠标右键点击，则是实现对格子进行标记地雷或取消标记的功能，通过改变对应格子存储的数据来体现标记状态的切换。</li><li><strong>界面绘制展示</strong>：<code>gameDraw</code>函数根据雷区二维数组中每个格子的数据值，确定要在对应位置绘制的图片（例如对应数字的图片、空白格图片、地雷图片等），将雷区当前的状态直观展示在游戏窗口上，同时更新显示游戏的计时器信息，实时呈现游戏的状态变化。</li><li><strong>游戏结束判断</strong>：<code>isOver</code>函数负责判断游戏是否结束，分为失败和胜利两种情况。通过遍历雷区数组，判断是否有雷被翻开以此来确定是否踩雷，若踩雷则弹出消息框询问玩家是否继续游戏，继续则重置相关状态重新开始，取消则退出游戏。同时，会统计已翻开的非雷格子数量，当该数量等于总格子数减去雷数时，判定游戏胜利，同样弹出消息框让玩家选择继续游戏或者退出，选择继续就重置状态重新初始化游戏，选择退出则直接结束程序。</li></ul><h2 id="开发过程出现的BUG和解决思路"><a href="#开发过程出现的BUG和解决思路" class="headerlink" title="开发过程出现的BUG和解决思路"></a>开发过程出现的BUG和解决思路</h2><p><strong>1.开头暴雷</strong></p><p>第一个解决思路是开头暴雷后重新排雷，结果出现了内存溢出的错误，第二个思路是先不排雷，在第一次点击的地方生成保护区，再开始排雷。笔者引入了一个bool值，解决了该问题。</p><p><strong>2.重新开始后失去开头保护</strong></p><p>一开始的解决思路是使用goto，但这会降低代码可读性，也不符合编译标准。所以，我编写了一个新的函数<code>restartgame</code>来重置游戏，这个思路被证实能够完美地解决该问题。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这可能是一个很拙劣的游戏源码，但编写他花了我和我的组员很多时间，如果喜欢，别忘了点个<a href="https://github.com/Dr-WillMos/Minesweeper">Star</a>,谢谢。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>开发</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序：基于插入算法的改进版本</title>
    <link href="/posts/shell_sort/"/>
    <url>/posts/shell_sort/</url>
    
    <content type="html"><![CDATA[<h1 id="希尔排序：基于插入算法的改进版本"><a href="#希尔排序：基于插入算法的改进版本" class="headerlink" title="希尔排序：基于插入算法的改进版本"></a>希尔排序：基于插入算法的改进版本</h1><p>平均时间复杂度：<strong>O(n log n)</strong></p><p>最好时间复杂度：<strong>O(n log^2 n)</strong></p><p>最坏时间复杂度：<strong>O(n log n)</strong></p><p>稳定性：<strong>不稳定</strong></p><p>特点：<strong>1.处理基本有序的效率较高</strong></p><p><strong>2.数据量比较小时效率较高</strong></p><p>希尔排序，又名<strong>缩小增量排序</strong>，是基于插入排序的一种<strong>改进算法</strong>，解决了插入排序一次只能移动一个元素造成的低效问题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1.设定一个<strong>增量</strong>整型gap = len / 2，向下取整，根据gap分组。</p><p>2.对每一组进行<strong>插入排序</strong>。</p><p>3.更新gap = gap / 2，继续以上操作。</p><p>4.知道gap == 1停止，对所有元素执行插入排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> {   <span class="hljs-comment">// &gt;&gt;是位运算符，相当于/2并向下取整</span><br>        <span class="hljs-type">int</span> gap, i, j;<br>        <span class="hljs-type">int</span> temp; <br>        <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)  <span class="hljs-comment">//第一层循环，保证gap的更新</span><br>                <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++) {     <span class="hljs-comment">//第二层循环，保证组别的切换</span><br>                        temp = arr[i];<br>                        <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)  <span class="hljs-comment">//第三层循环，完成组内比较。</span><br>                                arr[j + gap] = arr[j];<br>                        arr[j + gap] = temp;<br>                }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>假设有 {4, 2, 7, 0, 5, 8}这个数组，len = 6，首先，初始的 gap = len &gt;&gt; 1 也就是 6 &gt;&gt; 1 = 3（这里的 “&gt;&gt;” 是右移操作符，相当于除以 2 向下取整）。此时数组根据 gap 的值被分为了两组，分别是 {4, 0} 和 {2, 5} 以及 {7, 8}。</p><p>对于第一组 {4, 0}，进入内层的插入排序循环（也就是第三层循环），因为 4 &gt; 0，所以会将 4 往后移动（通过 arr [j + gap] = arr [j] 语句），然后把 0 放到合适的位置，即 arr [0] 的位置，这一组就排好了序。同样地，对 {2, 5} 和 {7, 8}  这两组也会进行类似的插入排序操作。</p><p>接着，<strong>更新 gap = gap &gt;&gt; 1</strong>，此时 gap 变为 1。这意味着现在要对整个数组当作一组来进行插入排序了。</p><p>从第二个元素开始遍历整个数组（第二层循环保证了这个遍历过程），比如对于元素 2，先把它存到临时变量 temp 中，然后通过第三层循环，与前面已经排好序的元素依次比较（这里是和 4 比较，因为 j = i -  gap，此时 i 是对应元素 2 的索引，gap 为 1），如果前面的元素大于它，就把前面的元素往后移（同样是通过 arr [j + gap] = arr [j] 语句），直到找到合适的位置，再把 temp（也就是  2）放到那个位置。就这样依次对数组中的每个元素进行这样的插入排序操作，直到整个数组都排好序为止。</p><h2 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h2><p>增量大时，分组多，组内元素比较少，效率较高。</p><p>随着增量逐渐减小，虽然组内元素越来越多，<strong>但整体越来越有序</strong>，所以效率越来越高。</p><h3 id="不稳定性"><a href="#不稳定性" class="headerlink" title="不稳定性"></a>不稳定性</h3><p><strong>希尔排序会改变排序前相同元素的相对位置。</strong></p><p>例如：数组 [5*, 4, 5, 2, 8, 1]，（对不同的5加星号标记）希尔排序之后会改变两个5的相对位置，排序后的星号5出现在5的后面。</p><p>所有希尔排序具有<strong>不稳定性</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/posts/insertion_sort/"/>
    <url>/posts/insertion_sort/</url>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>平均时间复杂度：<strong>O($n^2$)</strong></p><p>最好时间复杂度：<strong>O(n)</strong></p><p>最坏时间复杂度：<strong>O($n^2$)</strong></p><p>稳定性：<strong>稳定</strong></p><p>将第一个元素设置为有序区，将后面的每个数<strong>插入</strong>到前面的有序区之内，形同打扑克牌时<strong>摸牌插入到手中牌堆内。</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>{  <span class="hljs-comment">//两个重要参数</span><br>        <span class="hljs-type">int</span> i,j,key;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;len;i++){   <br>                key = arr[i];  <span class="hljs-comment">//这里的key就是中间变量，意味着待处理元素</span><br>                j=i<span class="hljs-number">-1</span>;         <span class="hljs-comment">//前移一位</span><br>                <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (arr[j]&gt;key)) {  <br>                        arr[j+<span class="hljs-number">1</span>] = arr[j];   <span class="hljs-comment">//这三行代码完成了交换</span><br>                        j--;                 <span class="hljs-comment">//j--表示比较的移动，逐渐移动到arr[0]</span><br>                }<br>                arr[j+<span class="hljs-number">1</span>] = key;    <span class="hljs-comment">//如果while不执行，这句相当于什么都不做</span><br>        }<br><br></code></pre></td></tr></tbody></table></figure><h2 id="针对有序区处理的顺序"><a href="#针对有序区处理的顺序" class="headerlink" title="针对有序区处理的顺序"></a>针对有序区处理的顺序</h2><p>使用插入将数组元素从小到大排序，在将待处理元素与有序区比较时，<strong>强烈建议</strong>从后往前<strong>（即从有序区的大数到小数的顺序来比较）</strong>排序，因为这样<strong>只需要移动比待处理元素大的元素，一旦找到位置就可以直接插入。</strong></p><p>比如{1,3,5,7}待处理元素为4，在比较5，7之后移动了2个元素，再把4插入3后面即可。</p><p>但如果是反着来，可能会对已经比较过的元素进行多次移动操作，尤其是当待插入元素较小，需要移动的元素较多时，<strong>效率相对较低。</strong></p><p>然而这也不是绝对的，<strong>但从大到小是通常情况下的最优解。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四大常用字符处理函数的实现</title>
    <link href="/posts/String/"/>
    <url>/posts/String/</url>
    
    <content type="html"><![CDATA[<h1 id="四大常用字符处理函数的实现"><a href="#四大常用字符处理函数的实现" class="headerlink" title="四大常用字符处理函数的实现"></a>四大常用字符处理函数的实现</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对于指针变量s，*s代表其指向的变量（声明变量时不代表），可能是整型变量a，也可能是字符变量c。s代表他本身，他是一个地址，比如，32ffcs。理解这一点，不然剩下的很难看懂。</p><p>函数中，需要把实际参数的地址赋给形参的指针变量，并根据“函数中的指针能够修改实际变量”的特点来实现函数功能，例子详见strcat函数。</p><h3 id="strlen函数：获取字符串长度"><a href="#strlen函数：获取字符串长度" class="headerlink" title="strlen函数：获取字符串长度"></a>strlen函数：获取字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mystrlen</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span><br>{<br>    <span class="hljs-type">char</span> *b = s;   <span class="hljs-comment">//这里就是让形参b得到了*s的地址，即s。</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">for</span> (;*b != <span class="hljs-string">'\0'</span>;b++)<br>    {<br>        length++;<br>    }<br>    <span class="hljs-keyword">return</span> length;<br>}<br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> x[<span class="hljs-number">10</span>] = <span class="hljs-string">"abcdefgh"</span>;<br>    <span class="hljs-type">int</span> a;<br>    a = mystrlen(x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a);<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="srtrcpy函数：实现字符串的复制"><a href="#srtrcpy函数：实现字符串的复制" class="headerlink" title="srtrcpy函数：实现字符串的复制"></a>srtrcpy函数：实现字符串的复制</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mystrcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">char</span> *b)</span> {<br>    <span class="hljs-type">char</span> temp;<br>    temp = *b;  <span class="hljs-comment">// 先取出b指向的当前字符</span><br>    <span class="hljs-keyword">while</span> (temp!= <span class="hljs-string">'\0'</span>) {<br>        *a = temp;<br>        a++;<br>        b++;<br>        temp = *b;  <span class="hljs-comment">// 更新temp为下一个字符</span><br>    }<br>    *a = <span class="hljs-string">'\0'</span>;  <span class="hljs-comment">// 手动添加字符串结束符到目标字符串末尾</span><br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">char</span> *x = <span class="hljs-string">"nihaozhangzhou"</span>;  <span class="hljs-comment">// 记得定义足够大的字符数组来存储目标字符串，避免数组越界。</span><br>    <span class="hljs-type">char</span> *y = <span class="hljs-string">"zhongguo"</span>;<br>    mystrcpy(x, y);<br>    <span class="hljs-built_in">puts</span>(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="strcat函数：实现字符串连接"><a href="#strcat函数：实现字符串连接" class="headerlink" title="strcat函数：实现字符串连接"></a>strcat函数：实现字符串连接</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//字符串拼接函数 mystrcat()，在这里，假设X是32ffcs（说明*x的地址是32ffcs）;那么将x的值赋给p;通过函数内指针能够修改实际参数的特点修改指定值，所以最后的return可以是p也可以是x。</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">mystrcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">char</span> *y)</span><br>{<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-type">char</span> *q;<br>    <span class="hljs-keyword">for</span> (p = x;*p != <span class="hljs-string">'\0'</span>; p++);<br>    <span class="hljs-keyword">for</span> (q = y;*q != <span class="hljs-string">'\0'</span>; q++)<br>    {<br>        *p = *q;<br>        p++;<br>    }<br>    *p = <span class="hljs-string">'\0'</span>;<br>    <span class="hljs-keyword">return</span> p;<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>     <span class="hljs-type">char</span> a[<span class="hljs-number">80</span>]=<span class="hljs-string">"Spring "</span>;<br>     <span class="hljs-type">char</span> b[]= <span class="hljs-string">"Equinox"</span>;<br>     mystrcat(a,b);<br>     <span class="hljs-built_in">puts</span>(a);<br><br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="strcmp：实现字符串的比较，包括长度和字符两方面。"><a href="#strcmp：实现字符串的比较，包括长度和字符两方面。" class="headerlink" title="strcmp：实现字符串的比较，包括长度和字符两方面。"></a>strcmp：实现字符串的比较，包括长度和字符两方面。</h3><p>只有长度相同，每个字符都相同时才相同，此时输出0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mystrcmp</span><span class="hljs-params">(<span class="hljs-type">char</span> *x,<span class="hljs-type">char</span> *y)</span><br>{<br>  <br>    <span class="hljs-type">char</span> *p = x;<br>    <span class="hljs-type">char</span> *q = y;<br>    <span class="hljs-keyword">while</span> (*p!= <span class="hljs-string">'\0'</span> &amp;&amp; *q!= <span class="hljs-string">'\0'</span>)<br>{<br>    <span class="hljs-keyword">if</span> (*p &gt; *q)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*p &lt; *q)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    p++;<br>    q++;<br>}<br><span class="hljs-keyword">if</span> (*p == <span class="hljs-string">'\0'</span> &amp;&amp; *q!= <span class="hljs-string">'\0'</span>)<br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*p!= <span class="hljs-string">'\0'</span> &amp;&amp; *q == <span class="hljs-string">'\0'</span>)<br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>}<br><span class="hljs-keyword">else</span><br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br><br>}<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">char</span> a[] = <span class="hljs-string">"China"</span>;<br>    <span class="hljs-type">char</span> *b = <span class="hljs-string">"ChinaIlove"</span>;<br>    <span class="hljs-type">int</span> v = mystrcmp(a,b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,v);<br><br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PTA补题（一）</title>
    <link href="/posts/pta1/"/>
    <url>/posts/pta1/</url>
    
    <content type="html"><![CDATA[<h1 id="PTA补题（一）"><a href="#PTA补题（一）" class="headerlink" title="PTA补题（一）"></a>PTA补题（一）</h1><p><strong>1.以下定义了一个一维数组str，该数组可以存放81个字符型数据。</strong>       T，’\0’也算一个字符</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">char</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">81</span>];<br></code></pre></td></tr></tbody></table></figure><p><strong>2.数组定义后，数组名表示该数组所分配连续内存空间中第一个单元的地址，即首地址。</strong>      T</p><p><strong>3.数组定义后，只能引用单个的数组元素，而不能一次引用整个数组。</strong>  T</p><p>数组名只代表首个元素，更多时候是通过遍历来实现对数组的引用。</p><p><strong>4.在以下描述中，（ ABE ）是正确的。</strong></p><p><strong>A.</strong></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br></code></pre></td></tr></tbody></table></figure><p><strong>定义了数组a，并对数组元素赋初值。此时，a[0]为1，a[1]为2，a[2]为3，a[3]为4，a[4]为5。</strong></p><p><strong>B.</strong></p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">int</span> b[<span class="hljs-number">10</span>];<br></code></pre></td></tr></tbody></table></figure><p><strong>定义了静态数组b，且10个数组元素的初值都为0。</strong></p><p><strong>C.</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int fib[<span class="hljs-number">45</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>定义了数组fib，且45个数组元素的值都为0。****自动变量可能为任何数字</strong></p><p><strong>D.</strong></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">static</span> int week[<span class="hljs-number">7</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<br></code></pre></td></tr></tbody></table></figure><p><strong>定义了静态数组week，并对数组 week 的前3个元素week[0]～week[2]赋初值，week[3]～week[6]值都是不确定的。****静态变量未初始化时固定为0</strong></p><p><strong>E.</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int cnt[<span class="hljs-number">10</span>] <span class="hljs-operator">=</span> {<span class="hljs-number">1</span>}<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>定义了数组cnt，并对cnt[0]赋初值1，其余元素的初值为0。</strong></p><p><strong>5.<code>"a"</code> 和 <code>'a'</code>是等价的。</strong> F，前者代表字符串，后者代表字符</p><p><strong>6.调用strcmp函数比较字符串大小时，通常较长的字符串会较大。  F</strong></p><p><strong>调用</strong><code>strcmp</code>函数比较字符串大小时，是按照字典序而不是字符串长度来判断的。</p><p><strong>7.如果函数定义出现在函数调用之前，可以不必加函数原型声明。 F</strong></p><p><strong>需要的</strong></p><p><strong>9.C语言中函数不能嵌套定义  T</strong></p><p><strong>10.静态变量的作用域是整个文件。   F</strong></p><p><strong>如果在函数中出现，只在函数中有效</strong></p><p><strong>11.当变量的存储类型定义缺省时,系统默认为变量的存储类型为auto类型,分配在静态区。</strong></p><p><strong>分配在栈区</strong></p><p><strong>12.全局变量只能定义在程序的最前面，即第一个函数的前面。</strong>   F，任何位置a</p><p><strong>13.静态局部变量如果没有赋值，其存储单元中将是随机值。</strong>  F，为0</p><p><strong>14.<a href="https://pintia.cn/problem-sets/1861991914122440704/exam/problems/type/7?problemSetProblemId=1861991914193743872">约瑟夫环</a></strong></p><blockquote><p><strong>用数组的方法的缺点是必须知道测试点在什么范围，用动态分配内存就可以解决这个问题。</strong></p></blockquote><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br><span class="hljs-keyword">int</span> josephus(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m) {<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> monkeys[<span class="hljs-number">300</span>]; &nbsp;<span class="hljs-regexp">//</span> 定义足够大的数组来存放猴子状态，假设最多<span class="hljs-number">300</span>只猴子，可根据实际情况调整大小<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;monkeys[i] = i + <span class="hljs-number">1</span>; &nbsp;<span class="hljs-regexp">//</span> 初始化猴子编号，从<span class="hljs-number">1</span>开始<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> count = n; &nbsp;<span class="hljs-regexp">//</span> 剩余猴子数量<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; &nbsp;<span class="hljs-regexp">//</span> 当前报数位置索引<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>; &nbsp;<span class="hljs-regexp">//</span> 当前报数数字<br><br> &nbsp; &nbsp;<span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">1</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (monkeys[<span class="hljs-keyword">index</span>] &gt; <span class="hljs-number">0</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (num == m) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;monkeys[<span class="hljs-keyword">index</span>] = -<span class="hljs-number">1</span>; &nbsp;<span class="hljs-regexp">//</span> 将报到m的猴子标记为已淘汰（这里用 -<span class="hljs-number">1</span> 标记）<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num = <span class="hljs-number">0</span>;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count--;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">index</span>++; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-regexp">//</span>轮到下一个猴子报数。<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == n) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-regexp">//</span>索引越界时重置为<span class="hljs-number">0</span><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (monkeys[i] &gt; <span class="hljs-number">0</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> monkeys[i]; &nbsp;<span class="hljs-regexp">//</span> 返回剩下猴子的编号，也就是猴王编号<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; &nbsp;<span class="hljs-regexp">//</span> 正常情况不会执行到这里，只是为了语法完整性<br>}<br><br><span class="hljs-keyword">int</span> main() {<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> n, m;<br> &nbsp; &nbsp;<span class="hljs-keyword">while</span> (scanf(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m)!= EOF &amp;&amp; (n!= <span class="hljs-number">0</span> || m!= <span class="hljs-number">0</span>)) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">int</span> result = josephus(n, m);<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">printf</span>(<span class="hljs-string">"%d\n"</span>, result);<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>15.<a href="https://pintia.cn/problem-sets/1861991914122440704/exam/problems/type/7?problemSetProblemId=1861991914193743876&amp;page=0">矩阵相乘</a></strong></p><blockquote><p>相乘时的元素遍历需要注意。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><br><span class="hljs-comment">// 计算矩阵乘法的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matrixMultiply</span><span class="hljs-params">(<span class="hljs-type">int</span> matrixA[][MAX_SIZE], <span class="hljs-type">int</span> ra, <span class="hljs-type">int</span> ca, <span class="hljs-type">int</span> matrixB[][MAX_SIZE], <span class="hljs-type">int</span> rb, <span class="hljs-type">int</span> cb)</span> </span>{<br> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (ca!= rb) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: %d!= %d\n"</span>, ca, rb);<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span>;<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-type">int</span> result[MAX_SIZE][MAX_SIZE];<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ra; i++) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//左矩阵的行数遍历</span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cb; j++) { &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//右矩阵列数遍历</span><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i][j] = <span class="hljs-number">0</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; ca; k++) { &nbsp; &nbsp;<span class="hljs-comment">//双矩阵元素乘法的元素遍历</span><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i][j] += matrixA[i][k] * matrixB[k][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-comment">// 输出结果矩阵</span><br> &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ra, cb);<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ra; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cb; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, result[i][j]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (j &lt; cb - <span class="hljs-number">1</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br> &nbsp;  }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br> &nbsp; &nbsp;<span class="hljs-type">int</span> ra, ca;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;ra, &amp;ca);<br> &nbsp; &nbsp;<span class="hljs-type">int</span> matrixA[MAX_SIZE][MAX_SIZE];<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ra; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ca; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;matrixA[i][j]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-type">int</span> rb, cb;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;rb, &amp;cb);<br> &nbsp; &nbsp;<span class="hljs-type">int</span> matrixB[MAX_SIZE][MAX_SIZE];<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rb; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cb; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;matrixB[i][j]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-built_in">matrixMultiply</span>(matrixA, ra, ca, matrixB, rb, cb);<br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>16.<a href="https://pintia.cn/problem-sets/1861991914122440704/exam/problems/type/7?problemSetProblemId=1861991914193743878&amp;page=0">卷积</a></strong></p><blockquote><p><strong>就是成倍数输出数组，我当时想太多了。</strong></p></blockquote><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 10</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br> &nbsp; &nbsp;<span class="hljs-type">int</span> n, k;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;k);<br> &nbsp; &nbsp;<span class="hljs-type">int</span> image[MAX_SIZE][MAX_SIZE]; &nbsp;<span class="hljs-comment">// 存储原始图像像素信息的二维数组</span><br><br> &nbsp; &nbsp;<span class="hljs-comment">// 读取原始图像像素信息</span><br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;image[i][j]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-comment">// 按照倍数放大图像并输出</span><br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; n * k; row++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n * k; col++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-type">int</span> originRow = row / k;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-type">int</span> originCol = col / k;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, image[originRow][originCol]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔一文速通</title>
    <link href="/posts/hanoi/"/>
    <url>/posts/hanoi/</url>
    
    <content type="html"><![CDATA[<h1 id="汉诺塔一文速通"><a href="#汉诺塔一文速通" class="headerlink" title="汉诺塔一文速通"></a>汉诺塔一文速通</h1><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><blockquote><ul><li><strong>有三根柱子，通常标记为 A（起始杆）、B（中转杆）、C（目标杆）。</strong></li><li><strong>开始时，所有的圆盘都按照从大到小的顺序堆叠在一根柱子（假设为 A 柱）上。</strong></li><li><strong>目标是将所有圆盘从起始柱子（A 柱）移动到目标柱子（比如 C 柱）。</strong></li><li><strong>移动过程中有两个重要的规则：每次只能移动一个圆盘；在移动过程中，大圆盘不能放在小圆盘上面。</strong></li></ul></blockquote><p><img src="https://s2.loli.net/2024/12/01/om67z1f3rwFtUqn.png" alt="image-20241201102242192"></p><h3 id="本质分析"><a href="#本质分析" class="headerlink" title="本质分析"></a>本质分析</h3><blockquote><p><strong>实际上，以三个汉诺塔为例，我们需要把最上面两个盘借助C转移到B上，（此时C是中转杆，B是目标杆），再直接将最大的底盘移动到C（目标杆），最后借助A，将B上的n-1个盘转移到C上（此时B是起始杆，A为中转杆，C为目标杆）。</strong></p><p><strong>当汉诺塔的盘数增加，其底层逻辑都不变，依旧是：</strong></p><ul><li><strong>将除底盘外的n-1个底盘移动借助目标杆到中转杆上</strong></li><li><strong>直接将最大底盘移动到目标杆上</strong></li><li><strong>将中转杆上的n-1个盘借助起始杆移动到目标杆上。</strong></li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">char</span> x,<span class="hljs-type">char</span> y)</span> &nbsp; &nbsp;<span class="hljs-comment">//移动函数，负责输出移动步骤</span></span><br><span class="hljs-function"></span>{<br> &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c -&gt; %c\n"</span>,x,y);<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> start,<span class="hljs-type">char</span> temp,<span class="hljs-type">char</span> end)</span><span class="hljs-comment">//第一位是起始，第二位中转，第三位目标</span></span><br><span class="hljs-function"></span>{<br> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//如果只有一个盘，可以直接移动</span><br> &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">print</span>(start,end); &nbsp;<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">else</span> {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>,start,end,temp); &nbsp;<span class="hljs-comment">//将非底盘（n-1）个从起始柱借助目标柱移动到中转柱</span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">print</span>(start,end); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">//将底盘从起始站柱子移动到目标柱</span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>,temp,start,end); &nbsp;<span class="hljs-comment">//将非底盘（n-1）从中转柱子借助起始柱移动到目标柱子</span><br> &nbsp;  }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br> &nbsp; &nbsp;<span class="hljs-type">int</span> n;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br> &nbsp; &nbsp;<span class="hljs-built_in">hanoi</span>(n,<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>); &nbsp; <span class="hljs-comment">//这里默认设定A为起始柱，B为中转柱，C为目标柱。</span><br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈优绩主义</title>
    <link href="/posts/meritocracy/"/>
    <url>/posts/meritocracy/</url>
    
    <content type="html"><![CDATA[<h1 id="优绩主义"><a href="#优绩主义" class="headerlink" title="优绩主义"></a>优绩主义</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>也不知道从什么时候开始，我们发现“全员保研”的文章铺天盖地。</strong></p><p><img src="https://s2.loli.net/2024/11/24/rEQ9bZe64qa5IA1.jpg" alt="nimg.ws.126"></p><p><strong>说实话，看到这种信息，我内心不是对优胜者的敬佩和崇拜，而是焦虑，漫无目的地想着我自己的未来，我会保研吗？他们的存在会对我的就业产生威胁吗？</strong></p><p>这就得引出我们今天的主题：<strong>优绩主义</strong>。</p><h1 id="优绩主义-1"><a href="#优绩主义-1" class="headerlink" title="优绩主义"></a>优绩主义</h1><p><strong>先来看看百度百科的定义：社会与经济的奖赏应当依据才能、努力和成就这些“优绩”来决定。人们在机会平等的条件下公平竞争，成绩优异者获胜。因此，最好的大学应当录取成绩最出色的学生，收入最高的职位应当留给最有能力的人才。</strong></p><p>这样的思想催生了一系列的制度，包括我们的高考，我们赏罚分明，唯分数论的方针。我们从小就被打上了思想钢印“<strong>每个人的一天都是24小时，我们努力的机会是均等的，努力的越多，回报就越多，这个世界是公平的。</strong>”</p><p>可是一个又一个天赋哥和富二代的现实提醒我们，这是错的。作为没有天赋的平庸的人，我们常常幻想自己只要通过不断地努力就能超越天赋哥，但现实是为了某一个唯分数论的体制，无数的天赋哥正在以苦行僧的方式和干劲，将自己的时间透支到学习当中，以高于常人数倍的产出效率狠狠地撕碎我们的白日梦。</p><p><em>讲一个作为一个中等生的无聊故事：</em></p><p><strong>很久之前，他曾经取得优异的成绩，在老师的眼中发光发热。可是到了一个新的阶段，他发现自己很普通，他无法在得心应手地处理自己曾经擅长的学科，他身边的好友的学习比他好得多，并且正在逐渐爬向巅峰，而他正在以肉眼可见速度越陷越深，他清楚地知道自己的情况，但他无能为力，他只能眼睁睁看着自己堕落，离曾经的自己越来越远。这时他才明白，抖音评论区的一句话：“</strong>中等生+曾经发过光+偏科+朋友学习好+清醒的堕落=绝杀**”是真的。</p><p>自卑和质疑如同潮水一般涌起，天才精英的傲慢嘲讽和老师一句“<strong>我记得你以前学习挺好的呀</strong>”一并袭来，将他打散，才知道这一切都是，化作了一抹泡影。</p><p>这个世界，不是公平的，天赋就是不公平的最大因素，还有家境背景也是。天赋哥可以自己应对学习，家里有背景的可以让教育资源向自己倾斜，<strong>而只有无能为力的中等生在孤立无援地进行着那辛酸血泪的争斗。</strong>只可惜，无论是天才还是常人，在“唯分数论”的教条下都不会怀疑自己的选择，精英可以凭借高层权力的倾斜张牙舞爪，而常人只能把不堪的现状归根于不够努力的自己，然后又一头扎进毫无进展的生活中去。</p><p>这就是优绩主义带来的副作用，它造就了天才的傲慢和失败者的自卑。这种看似公平的成功观造成精英的傲慢和底层民众的怨恨，使成功者深信其<strong>成功是自身努力的结果</strong>，忘记帮助他们的时机和运气，<strong>轻视着</strong>比自己不幸和缺乏资格的人，<strong>剥削着</strong>，<strong>操控着</strong>不被时运和上帝眷顾的无辜的人们，这便是<strong>优绩的暴政</strong>。</p><p>但也就是在这般束缚下，我们以收入将人分为三六九等，我们以地位将人异化得光怪陆离，<strong>我们也是优绩主义的帮凶。</strong></p><h1 id="对大学生活的思考"><a href="#对大学生活的思考" class="headerlink" title="对大学生活的思考"></a>对大学生活的思考</h1><p><strong>言归正传，再回到我们提到的保研问题上来。我们常常将保研视为大学生活中的一座高峰，似乎只有攀登上去才能证明自己的价值。然而，在优绩主义的影响下，保研竞争变得异常激烈，每个人都在拼命追逐那有限的名额。</strong></p><p>但是我们要注意的是，这是彻彻底底的<strong>零和博弈</strong>，保研名额注定是有限的，他保研就意味着你不能保研，一方的获利必定造成另一方的损失。</p><p>在这种零和博弈的困局中，许多人陷入了无尽的内卷漩涡。他们为了那几个保研指标，日夜苦读，放弃了社交、兴趣爱好甚至是健康。原本充满活力与探索精神的大学生活，被各种考试、竞赛和论文填满，变得单调而压抑。</p><p>大学本应是知识探索与人格塑造的殿堂，而非仅仅是保研竞争的战场。我们应该在大学找到真正的自我，<strong>而不是被世俗定义的成功绑架，不是被优绩主义异化为非人。</strong></p><p><strong>所以，如果你失败了，不是因为你不够努力，束缚你的是世俗强行加给你的价值观。如果你失败了，迎接你的不是死亡与堕落，而是很多的选择和不一样的人生，是无限的可能和不一样的风景。</strong></p><p><strong>所以，</strong></p><p><strong>别再为高考活着。</strong></p><p><strong>别再为绩点活着。</strong></p><p><strong>别再为虚荣活着。</strong></p><p><strong>请为你自己活着。</strong></p><p><img src="https://s2.loli.net/2024/11/26/lGtb6Qgm5LqyYU7.png" alt="930ead712b5e426d82c1ab2e701ebb4f.png"></p>]]></content>
    
    
    <categories>
      
      <category>拾遗阁</category>
      
      <category>随笔</category>
      
      <category>哲学思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>思考</tag>
      
      <tag>社会</tag>
      
      <tag>和解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《超脱》：自我与现实的斗争</title>
    <link href="/posts/Detachment/"/>
    <url>/posts/Detachment/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>剧情方面在此不再赘述，笔者建议看看原片，不建议看解说。</strong></p><blockquote><p>During the whole of a dull,dark soundless day 　　 在那年秋季枯燥，灰暗而瞑寂的某个长日里</p><p>　　In the autumn of that year, when the clouds hung oppressively low in heaven 　　沉重的云层低悬于天穹之上</p><p>　　I had been passing alone on the horse’s back 　　我独自一人策马前行</p><p>　　Through the Singularly,dreary tract in the country 　　穿过这片阴沉的，异域般的乡间土地</p></blockquote><blockquote><p>　　and at length found myself, as the shades of the evening drew on 　　最终，当夜幕缓缓降临的时候</p></blockquote><blockquote><p>　　Within the view of melancholy House of Usher 　　厄舍府清冷的景色展现在我眼前</p></blockquote><blockquote><p>　　I know not how it was 　　我未曾目睹它过往的模样</p></blockquote><blockquote><p>　　But with the first glimpse of the building, a sense of insufferable gloom pervaded my spirit 　　但仅凭方才的一瞥，某种难以忍受的阴郁便浸透了我的内心</p><p>　　I looked upon the scene before me the simple landscape features of the domain 　　我望着宅邸周围稀疏的景物</p><p>　　Upon the bleak walls,upon the white trunks of decayed trees 　　围墙荒芜，衰败的树遍体透着白色</p><p>　　With the utter depression souls 　　我的灵魂失语了</p><p>　There was an iciness 　　我的心在冷却</p><p>　　A sinking. 　　下沉</p><p>　　A sickening of the heart 　　显出疲软的病态<br><img src="https://s2.loli.net/2024/11/09/P4pY1JEKksUq8fn.jpg" alt="_1731166957270.jpg"></p></blockquote><h2 id="局外人的无力感"><a href="#局外人的无力感" class="headerlink" title="局外人的无力感"></a>局外人的无力感</h2><p>影片的开始，日记上赫然写着一句话：“我的灵魂与我之间的距离如此遥远，而我的存在却如此真实。”</p><blockquote><p><strong>Some of us believe that we can make a difference. And then sometimes when we wake up and we realize we failed.</strong></p><p><strong>有些人觉得我们能改变世界，但有时，我们醒来后发现，我们并没有做到。</strong></p></blockquote><p><strong>亨利</strong>和其他老师一样，都是教育工作者，处于职业操守，他们希望学生们变好。但对于一群流里流气的迷茫青年来说，这一点无非天方夜谭。面对这自甘堕落的学生们，我们的老师无能为力，他们无法融入学生的世界里，成为了局外人，也成为了可怜人。有的老师如查理·西博德特教授装疯卖傻地维持着这份毫无意义的工作，有的如刘玉玲老师歇斯底里地表达这自己的愤怒和无奈，有的如亨利无谓地放空内心等待任期结束。包括被资本绑架的女校长，所有的教育者只能眼睁睁地看着自己的学生坠入深不见底的底层。</p><p>如果把镜头集中亨利一人，这一点体现的更加淋漓尽致。亨利看见了破旧公交车上卖春反被打的少女，看她被欺凌，看她忍饥挨饿，最多只不过是将她带回了自己的家里提供食宿，甚至无法再提供其他任何的帮助。这一切，都因为亨利一人所承受的痛苦已经是泰山一座，关系不清的祖父在养老院苟延残喘，手下的学生目中无人，梅瑞狄斯正在遭受心魔，亨利的心已经被痛苦占据，没有多余的空间留给其他人了。亨利不是耶稣，他不能永久地承载别人的痛苦，最后也迫不得已将少女送入了管教机构，只能看着祖父挣扎着离开这个世界，只能对梅瑞狄斯的尸体做没有意义的人工呼吸。</p><p>等到影片的后半段，看着狂风吹乱书籍，亨利颓废地坐在讲台中央，一股不可避免的抽离感已从他内心升起，即使他的肉体切切实实存在着，但他似乎感到自己的灵魂已经不再属于这个世界，已经发生了”Detachment”。<br><img src="https://s2.loli.net/2024/11/09/pYoZLCqB3AvJPw1.png" alt="_1731166944959.png"></p><h2 id="畸零人的自我救赎"><a href="#畸零人的自我救赎" class="headerlink" title="畸零人的自我救赎"></a>畸零人的自我救赎</h2><p>我们常说，一部只有悲情而不能给人力量的电影是很难流传的，那么《超脱》的力量就来自于存在主义。</p><p>自我与荒诞的世界紧密相连，不可分割。每当我们渴望拯救自我、寻求救赎时，却常常深感无力。我们品尝着失败的苦涩，在有限的世界里奋力追逐无限的美好，却只能望而兴叹。也许，世间万物不过是一场自我慰藉的幻梦。若我们将自己全然交予自我，抑或彻底委身于现实，最终恐怕都难逃无尽的虚无、失败与荒谬。</p><p>我们曾对世界抱有无限的期望，但如果意外比明天先到，理想坠入万劫不复的深渊，最爱的人与我们阴阳两隔，我们还笑得出来吗？**</p><p>在这样一个世界中，你我都只是以一副躯壳游荡于世间，至于我们的灵魂在哪，没人说得清楚。</p><p>然而，在影片的后半段，亨利与少女在夕阳之下紧紧相拥，似乎给出了面对这荒诞世界的答案。<br><img src="https://s2.loli.net/2024/11/09/jz4ye71kXYQvZf9.png" alt="QQ20241109234409.png"></p><p>在那夕阳的余晖中，亨利与少女的紧紧相拥，仿佛是黑暗世界中的一抹曙光。这一拥抱，不仅仅是两个孤独灵魂的交汇，更是对生活的一种无声抗争，是在荒诞世界中寻找温暖与希望的勇敢尝试。</p><p>他们的拥抱，是对畸零人生的一种超脱。在这个荒诞的世界里，他们不再是孤独的个体，而是彼此的依靠。他们用这一拥抱告诉世人，即使生活充满了痛苦和无奈，我们仍然可以找到属于自己的温暖和希望，即使都是社会的可怜人也可以相互治愈。</p><p>刘玉玲老师在崩溃中大喊：“要无心太容易，但在乎才需要勇气。”如果人对一切都无所谓，无心看待这一切，那就成了真正意义上的躯壳，但我们要做的是拿出勇气和信心，勇于面对过去的离别和不堪，继续自己拥有无限可能的余生，去感知每一次心跳，<strong>才是对生命的尊重，才是对荒诞世界的反抗。</strong></p>]]></content>
    
    
    <categories>
      
      <category>拾遗阁</category>
      
      <category>随笔</category>
      
      <category>哲学思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言的18个经典实例</title>
    <link href="/posts/exampleofc/"/>
    <url>/posts/exampleofc/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>sizeof是一种关键字，是一个单目运算发，不是函数，但使用方法类似于函数，输出的数据类型为%ld，用法是<code>sizeof(变量名)</code>，返回的是内存大小(字节数)。</p><h3 id="1-判断奇偶数"><a href="#1-判断奇偶数" class="headerlink" title="1.判断奇偶数"></a>1.判断奇偶数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br><span class="hljs-type">int</span> number;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;number);<br><span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"偶数"</span>);<br>}<br><span class="hljs-keyword">else</span> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"奇数"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="2-表达式值的运用"><a href="#2-表达式值的运用" class="headerlink" title="2.表达式值的运用"></a>2.表达式值的运用</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> isLowercaseVowel, isUppercaseVowel;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个字母: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;c);<br>   <br>    <span class="hljs-comment">// 小写字母元音</span><br>    isLowercaseVowel = (c == <span class="hljs-string">'a'</span> || c == <span class="hljs-string">'e'</span> || c == <span class="hljs-string">'i'</span> || c == <span class="hljs-string">'o'</span> || c == <span class="hljs-string">'u'</span>);<br>   <br>    <span class="hljs-comment">// 大写字母元音</span><br>    isUppercaseVowel = (c == <span class="hljs-string">'A'</span> || c == <span class="hljs-string">'E'</span> || c == <span class="hljs-string">'I'</span> || c == <span class="hljs-string">'O'</span> || c == <span class="hljs-string">'U'</span>);<br>   <br>    <span class="hljs-comment">// if 语句判断</span><br>    <span class="hljs-keyword">if</span> (isLowercaseVowel || isUppercaseVowel)   <span class="hljs-comment">//这里使用了表达式值</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c  是元音"</span>, c);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c 是辅音"</span>, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="3-内外双层循环"><a href="#3-内外双层循环" class="headerlink" title="3.内外双层循环"></a>3.内外双层循环</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{  <br>    <span class="hljs-comment">//外层循环变量,控制行  </span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">//内层循环变量,控制列   </span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++){  <br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i;j++){  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%dx%d=%d\t"</span>,j,i,i*j);  <br>        }  <br>        <span class="hljs-comment">//每行输出完后换行   </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);   <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-GCD的另一种算法"><a href="#4-GCD的另一种算法" class="headerlink" title="4.GCD的另一种算法"></a>4.GCD的另一种算法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b);<br>    <span class="hljs-keyword">while</span> (b !=<span class="hljs-number">0</span> ){<br>        t = a%b;<br>        a = b;<br>        b = t;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d b=%d t=%d\n"</span>,a , b, t);<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大公约数是%d\n"</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-阶乘"><a href="#4-阶乘" class="headerlink" title="4.阶乘"></a>4.阶乘</h3><h4 id="正序循环："><a href="#正序循环：" class="headerlink" title="正序循环："></a>正序循环：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> factorial = <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br> <br>    <span class="hljs-comment">// 如果输入是负数，显示错误</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error! 负数没有阶乘jiechen"</span>);<br> <br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br>        {<br>            factorial *= i;              <span class="hljs-comment">// factorial = factorial*i;</span><br>        }<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d! = %llu"</span>, n, factorial);<br>    }<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}   <span class="hljs-comment">//顺序法，从1乘到n</span><br></code></pre></td></tr></tbody></table></figure><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiplyNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d! = %ld"</span>, n, multiplyNumbers(n));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiplyNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>    <span class="hljs-comment">//此处的函数在不满足if时会触发递归循环</span><br>{<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> n*multiplyNumbers(n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="5-数位判断"><a href="#5-数位判断" class="headerlink" title="5.数位判断"></a>5.数位判断</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>, &amp;n);<br> <br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)<br>    {<br>        n /= <span class="hljs-number">10</span>;   <span class="hljs-comment">//注意这里不是%10</span><br>        ++count;<br>    }<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"数字是 %d 位数。"</span>, count);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="6-斐波那契"><a href="#6-斐波那契" class="headerlink" title="6.斐波那契"></a>6.斐波那契</h3><h4 id="指定个数"><a href="#指定个数" class="headerlink" title="指定个数"></a>指定个数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> i, n, t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">1</span>, nextTerm;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输出几项: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"斐波那契数列: "</span>);<br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d, "</span>, t1);<br>        nextTerm = t1 + t2;<br>        t1 = t2;<br>        t2 = nextTerm;      <span class="hljs-comment">//这三步使得计算往后挪动1个单位</span><br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="7-整型数字翻转"><a href="#7-整型数字翻转" class="headerlink" title="7.整型数字翻转"></a>7.整型数字翻转</h3><h4 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n, reversedInteger = <span class="hljs-number">0</span>, remainder, originalInteger;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br> <br>    originalInteger = n;<br> <br>    <span class="hljs-comment">// 翻转</span><br>    <span class="hljs-keyword">while</span>( n!=<span class="hljs-number">0</span> )<br>    {<br>        remainder = n%<span class="hljs-number">10</span>;<br>        reversedInteger = reversedInteger*<span class="hljs-number">10</span> + remainder; <span class="hljs-comment">//这里无需设置数位变量</span><br>        n /= <span class="hljs-number">10</span>;<br>    }<br> <br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (originalInteger == reversedInteger)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d 是回文数。"</span>, originalInteger);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d 不是回文数。"</span>, originalInteger);<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="使用字符串："><a href="#使用字符串：" class="headerlink" title="使用字符串："></a>使用字符串：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span>  <span class="hljs-comment">//处理字符串和内存块的库</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">12021</span>;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">10</span>]={<span class="hljs-string">'\0'</span>},s1[<span class="hljs-number">10</span>]={<span class="hljs-string">'\0'</span>};<br>    <span class="hljs-built_in">sprintf</span>(s,<span class="hljs-string">"%d"</span>,a); <span class="hljs-comment">// 将整数转换为字符串</span><br>    <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(s);   <span class="hljs-comment">//字符串长度，这一步可以用循环实现，用"/0";</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    {<br>        s1[j++]=s[i];<br>    }<br>    <span class="hljs-comment">//s[j]='\0';</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %s\n"</span>,s,s1);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(s,s1))<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"整数%d是回文串"</span>,a);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"整数%d不是回文串"</span>,a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="8-表格形式输出数据"><a href="#8-表格形式输出数据" class="headerlink" title="8.表格形式输出数据"></a>8.表格形式输出数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>   <span class="hljs-type">int</span> i, j, count;<br> <br>   <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) {<br>      <span class="hljs-keyword">for</span>(j = i; j &lt;=<span class="hljs-number">100</span>; j += <span class="hljs-number">10</span> ) <span class="hljs-comment">//标准双层循环</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %3d"</span>, j);   <span class="hljs-comment">//限制列宽</span><br> <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>   }<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="9-数组拷贝"><a href="#9-数组拷贝" class="headerlink" title="9.数组拷贝"></a>9.数组拷贝</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>   <span class="hljs-type">int</span> original[<span class="hljs-number">10</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>};<br>   <span class="hljs-type">int</span> copied[<span class="hljs-number">10</span>];<br>   <span class="hljs-type">int</span> loop;<br>   <br>   <span class="hljs-keyword">for</span>(loop = <span class="hljs-number">0</span>; loop &lt; <span class="hljs-number">10</span>; loop++) {    <span class="hljs-comment">//单循环遍历整个数组</span><br>      copied[loop] = original[loop];<br>   }<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"元素数组 -&gt; 拷贝后的数组 \n"</span>);<br>   <br>   <span class="hljs-keyword">for</span>(loop = <span class="hljs-number">0</span>; loop &lt; <span class="hljs-number">10</span>; loop++) {<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"   %2d        %2d\n"</span>, original[loop], copied[loop]);<br>   }<br> <br>   <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>约瑟夫环</p><h3 id="10-分解某数作为两个素数的和"><a href="#10-分解某数作为两个素数的和" class="headerlink" title="10.分解某数作为两个素数的和"></a>10.分解某数作为两个素数的和</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">checkPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n, i, flag = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入正整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n/<span class="hljs-number">2</span>; ++i)<br>    {<br>        <span class="hljs-comment">// 检测判断</span><br>        <span class="hljs-keyword">if</span> (checkPrime(i) == <span class="hljs-number">1</span>)<br>        {<br>            <span class="hljs-keyword">if</span> (checkPrime(n-i) == <span class="hljs-number">1</span>)         <span class="hljs-comment">//n-i减少了变量设置</span><br>            {<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d = %d + %d\n"</span>, n, i, n - i);<br>                flag = <span class="hljs-number">1</span>;<br>            }<br> <br>        }<br>    }<br> <br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d 不能分解为两个素数。"</span>, n);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br> <br><span class="hljs-comment">// 判断素数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>{<br>    <span class="hljs-type">int</span> i, isPrime = <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n/<span class="hljs-number">2</span>; ++i)<br>    {<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>        {<br>            isPrime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }  <br>    }<br> <br>    <span class="hljs-keyword">return</span> isPrime;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="11-字符串翻转"><a href="#11-字符串翻转" class="headerlink" title="11.字符串翻转"></a>11.字符串翻转</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">reverseSentence</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个字符串: "</span>);<br>    reverseSentence();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">reverseSentence</span><span class="hljs-params">()</span>     <span class="hljs-comment">//递归写法，不读到回车不会停止</span><br>{<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;c);<br> <br>    <span class="hljs-keyword">if</span>( c != <span class="hljs-string">'\n'</span>)<br>    {<br>        reverseSentence();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,c);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="12-冒泡法排序"><a href="#12-冒泡法排序" class="headerlink" title="12. 冒泡法排序"></a>12. 冒泡法排序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 交换两个整数的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> {<br>    <span class="hljs-type">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>}<br><br><span class="hljs-comment">// 冒泡排序函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) {<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {<br>                swap(&amp;arr[j], &amp;arr[j + <span class="hljs-number">1</span>]);<br>            }<br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 打印数组元素的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, arr[i]);<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>};<br>    <span class="hljs-type">int</span> n = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"排序前的数组: "</span>);<br>    printArray(arr, n);<br><br>    bubbleSort(arr, n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"排序后的数组: "</span>);<br>    printArray(arr, n);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="13-矩阵相加"><a href="#13-矩阵相加" class="headerlink" title="13.矩阵相加"></a>13.矩阵相加</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">int</span> r, c, a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>], b[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>], sum[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>], i, j;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入行数 ( 1 ~ 100): "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;r);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入列数 ( 1 ~ 100): "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;c);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n输入第一维数组的元素:\n"</span>);<br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入元素 a%d%d: "</span>,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);<br>        }<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入第二维数组的元素:\n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入元素 a%d%d: "</span>,i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;b[i][j]);<br>        }<br> <br>    <span class="hljs-comment">// 相加</span><br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r;++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;c;++j)<br>        {<br>            sum[i][j]=a[i][j]+b[i][j];<br>        }<br> <br>    <span class="hljs-comment">// 显示结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n二维数组相加结果: \n\n"</span>);<br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r;++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;c;++j)<br>        {<br> <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d   "</span>,sum[i][j]);<br> <br>            <span class="hljs-keyword">if</span>(j==c<span class="hljs-number">-1</span>)<br>            {<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);<br>            }<br>        }<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="14-矩阵转置"><a href="#14-矩阵转置" class="headerlink" title="14.矩阵转置"></a>14.矩阵转置</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>], transpose[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>], r, c, i, j;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入矩阵的行与列: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;r, &amp;c);<br> <br>    <span class="hljs-comment">// 存储矩阵的元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n输入矩阵元素:\n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入元素 a%d%d: "</span>,i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i][j]);<br>        }<br> <br>    <span class="hljs-comment">// 显示矩阵 a[][] */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n输入矩阵: \n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d  "</span>, a[i][j]);<br>            <span class="hljs-keyword">if</span> (j == c<span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);<br>        }<br> <br>    <span class="hljs-comment">// 转换</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            transpose[j][i] = a[i][j];<br>        }<br> <br>    <span class="hljs-comment">// 显示转换后的矩阵 a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n转换后矩阵:\n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;c; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;r; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d  "</span>,transpose[i][j]);<br>            <span class="hljs-keyword">if</span>(j==r<span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);<br>        }<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="15-连接字符串"><a href="#15-连接字符串" class="headerlink" title="15.连接字符串"></a>15.连接字符串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> s1[<span class="hljs-number">100</span>], s2[<span class="hljs-number">100</span>], i, j;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入第一个字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s1);          <span class="hljs-comment">//如果是%c，读入一个就停止</span><br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入第二个字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s2);<br> <br>    <span class="hljs-comment">// 计算字符串 s1 长度</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; s1[i] != <span class="hljs-string">'\0'</span>; ++i);<br> <br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; s2[j] != <span class="hljs-string">'\0'</span>; ++j, ++i)<br>    {<br>        s1[i] = s2[j];<br>    }<br> <br>    s1[i] = <span class="hljs-string">'\0'</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"连接后: %s"</span>, s1);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="16-获取字符串长度"><a href="#16-获取字符串长度" class="headerlink" title="16.获取字符串长度"></a>16.获取字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br>    <span class="hljs-type">int</span> len;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);<br>    len = <span class="hljs-built_in">strlen</span>(s);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"字符串长度: %d"</span>, len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>], i;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);<br> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">'\0'</span>; ++i);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"字符串长度: %d"</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="17-字符类型的统计"><a href="#17-字符类型的统计" class="headerlink" title="17.字符类型的统计"></a>17.字符类型的统计</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">150</span>];<br>    <span class="hljs-type">int</span> i, vowels, consonants, digits, spaces;<br> <br>    vowels =  consonants = digits = spaces = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%[^\n]"</span>, line);      <span class="hljs-comment">//这会使scanf遇到回车才停止，但这不是一种标准用法。</span><br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; line[i]!=<span class="hljs-string">'\0'</span>; ++i)<br>    {<br>        <span class="hljs-keyword">if</span>(line[i]==<span class="hljs-string">'a'</span> || line[i]==<span class="hljs-string">'e'</span> || line[i]==<span class="hljs-string">'i'</span> ||<br>           line[i]==<span class="hljs-string">'o'</span> || line[i]==<span class="hljs-string">'u'</span> || line[i]==<span class="hljs-string">'A'</span> ||<br>           line[i]==<span class="hljs-string">'E'</span> || line[i]==<span class="hljs-string">'I'</span> || line[i]==<span class="hljs-string">'O'</span> ||<br>           line[i]==<span class="hljs-string">'U'</span>)<br>        {<br>            ++vowels;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((line[i]&gt;=<span class="hljs-string">'a'</span>&amp;&amp; line[i]&lt;=<span class="hljs-string">'z'</span>) || (line[i]&gt;=<span class="hljs-string">'A'</span>&amp;&amp; line[i]&lt;=<span class="hljs-string">'Z'</span>))<br>        {<br>            ++consonants;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(line[i]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; line[i]&lt;=<span class="hljs-string">'9'</span>)<br>        {<br>            ++digits;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line[i]==<span class="hljs-string">' '</span>)<br>        {<br>            ++spaces;<br>        }<br>    }<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"元音: %d"</span>,vowels);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n辅音: %d"</span>,consonants);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n数字: %d"</span>,digits);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n空白符: %d"</span>, spaces);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="18-约瑟夫环问题"><a href="#18-约瑟夫环问题" class="headerlink" title="18.约瑟夫环问题"></a>18.约瑟夫环问题</h3><blockquote><p>约瑟夫环（Josephus Problem）是一个经典的数学和计算机科学问题。问题是这样的：有 n个人围成一圈，从某个人开始顺序编号为1,2,3,4,····n 。从编号为 1的人开始报数，报到 m的人出列，然后下一个人重新从 1开始报数，报到 m的人又出列，如此循环，直到所有的人都出列为止。求出列的顺序。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">josephus</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> {<br>    <span class="hljs-type">int</span> people[n];<br>    <span class="hljs-comment">// 初始化数组，0表示未出列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        people[i] = <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录已经出列的人数</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 报数的索引</span><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 报数的数字</span><br>    <span class="hljs-keyword">while</span> (count &lt; n) {<br>        <span class="hljs-keyword">if</span> (people[index] == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">if</span> (num == m) {<br>                people[index] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, index + <span class="hljs-number">1</span>);<br>                count++;<br>                num = <span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                num++;<br>            }<br>        }<br>        index = (index + <span class="hljs-number">1</span>) % n;<br>    }<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">7</span>;  <span class="hljs-comment">// 总人数</span><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 报数到m的人出列</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出列顺序为: "</span>);<br>    josephus(n, m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灯塔</title>
    <link href="/posts/lighthouse/"/>
    <url>/posts/lighthouse/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这应该早就开始写了，现在就把存在脑海里几个月的思绪写下来。</p></blockquote><p>在HDU的一个月，我看见了形形色色的人和事，军训场上的歌者和舞者，舞台上的演员，他们仿佛在展示着青春不同的样子。这对一个来自小城镇的KID来说有点受宠若惊。但同时，见过花园之后就是迷茫，别人的青春如此，我呢？</p><h2 id="你要为你的未来做什么呢？"><a href="#你要为你的未来做什么呢？" class="headerlink" title="你要为你的未来做什么呢？"></a>你要为你的未来做什么呢？</h2><p>我们来讲一个故事，孙悟空跟着菩提老祖跟了7年，学到的本身，打穿天庭，一路降妖除魔，修得正果“斗战胜佛”。为什么这泼猴只学了7年，成就就已经超过了老祖的大半徒弟，我觉得是因为泼猴只盯着“长生”二字，不得长生二字不学，因此习得实用的技能，成了圣佛。这就对上了他说的那两句“<strong>求仙问卜不如自己做主，念佛诵经不如本事在身。”</strong><br>​      说句实话，现在的失业率暂停发布，就业形势并不大好。父母用一袋子钱为我们换来了一袋子书，但是我们有这个把握能用这一袋子书重新换来一袋子钱吗？这是个问题。<br>​      一个善于学习的人能提供的价值，比很多平庸的人在学校里虚度十六年光阴以后能拿出来的东西实用得多。学习和工作是未来人生的主线任务，是未来几十年你赖以生存的基础。一切其他事情，都是伴随工作左右的。毕业大家都拿到同一份工资，不代表毕业五年后大家依然拿同一份工资。<br>因此，变得优秀，不让以后的自己感到悔恨，是大学的主线任务。</p><h2 id="我想成为一个什么样的人"><a href="#我想成为一个什么样的人" class="headerlink" title="我想成为一个什么样的人"></a>我想成为一个什么样的人</h2><p><strong>1.加入ACM集训队</strong><br>这是一个很困难的目标，电专的竞赛强度有目共睹，我只能抱着试一试的心态去尝试。杭电有十七个分队，即使我不能加入其中，也能用所学参加Codeforce等个人赛，技多不压身。<br><strong>2.放弃社恐，收放自如</strong><br>内向不代表扭扭捏捏，我们需要的是能够将自己的想法简明地告知别人的交际能力。这种能力可以不用，但不能没有。<br>不要怕做的不好，很多过去的事情不需要原谅，<strong>因为没人记得。</strong><br><strong>3.控制自己的欲望。</strong><br><strong>欲望的背后绝非自由，而是更深重的桎梏。</strong><br>从欲望的绑架中脱离，我们才知道我们真正想做的是什么。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>人生的路本可以很轻松，只是笔者和读者选择变得更加优秀，既然如此，就将选择的路一直走下去，也许这样<br><strong>直到晚年</strong></p><p><strong>我们才能称自己为爱人</strong></p><p><strong>和感到</strong></p><p><strong>被这个世界爱过。</strong></p><p><img src="https://s2.loli.net/2024/10/16/z2XOuBPsi9vVK3y.jpg" alt="https://s2.loli.net/2024/10/16/z2XOuBPsi9vVK3y.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>随感</tag>
      
      <tag>未来</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的月光</title>
    <link href="/posts/newmoonlight/"/>
    <url>/posts/newmoonlight/</url>
    
    <content type="html"><![CDATA[<h2 id="新的月光"><a href="#新的月光" class="headerlink" title="新的月光"></a>新的月光</h2><p>WillMo博士颓废地坐在鱼冢里，在O5的注视中沉默地迎接晨曦的到来。</p><p>O5回到了他们的圆桌上，MTF收起了枪，随着打卡机的响起，所有的Site又开始了新的呼吸。</p><p>WillMo博士大概确实是与过去诀别了，他将所有关于研究员Lucy的物件都锁在了他办公室无人知晓的角落里。</p><blockquote><p><strong>您有一封新的邮件，请查收。</strong></p><p><strong>-打开</strong></p><p><strong>信息分析部门主管WillMo博士：</strong></p><p>我们的特工突袭了Are We Cool Yet?的一处地点，并缴获了一系列异常项目，相关资料已在附件中给出。其中的一项是一个布满花纹的USB存储设备，我们需要你和你的部门分析其存储原理并尽可能分析其异常性质的来源。如果可以，请在10.4日前将检测报告发送给<br>Ruby博士。</p><p>——艺术异常部副主管Lucy</p></blockquote><p>博士看着这熟悉的署名，感到一股陌生和茫然，但鱼冢里的墓碑很快就把他拉回了现实。</p><p>“同名的“他抱着这样的念头，打开了那台布满灰尘的终端。<br>…….</p><blockquote><p><strong>您的邮件已发送。</strong></p></blockquote><p>最终执念还是战胜了理性，他迫不及待打开基金会的职员数据库，查询了”Lucy”这个字段，然后焦急地等待回应。</p><blockquote><p><strong>员工编号：[权限不足]</strong></p><p><strong>姓名：Lucy ▆▆▆▆</strong></p><p><strong>性别：女</strong></p><p><strong>出生日期：[权限不足]</strong></p><p><strong>国籍：[权限不足]</strong></p><p><strong>所属站点：Site-69</strong></p><p><strong>职位：4级部门副主管</strong></p><p><strong>入职日期：[权限不足]</strong></p><p><strong>安全许可等级：4级</strong></p><p><strong>专长：对研究艺术类异常项目有敏锐感知力，已被指派追踪GOI”Are We Cool yet”。</strong></p></blockquote><p>WillMo博士盯着这几行有限的信息，记起了同级权限人员的信息只能有限查阅。<br>“这是O5的阴谋，还是说只是一个同名者呢？”WillMo博士这样想着，直到夜色吞没了他的思绪。<br> ………<br>大梦一场过后，年轻的博士觉得这位同事的身份已经无关紧要，真正有价值的是那个熟悉的名字。曾经他很弱小，躲在沉默后面对Lucy投以注视，一幕又一幕的背影，在他的自卑下似乎套上了一层神的光辉，就此，成为里无数个月夜中辗转反侧的白月光。但是等他足够强大，带着鲜花和底气来见她时，迎接他的只是一座孤零零的坟墓。而现在，这个名字的出现好像是上帝给的另一次机会，让他能够在余生中将自己从遗憾中拯救回来，去保护那个曾经未能保护的人。</p><p><strong>灯光从窗户透过，WillMo博士正在进行他自己的救赎。</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码，反码，补码一文速通</title>
    <link href="/posts/d6c660ac/"/>
    <url>/posts/d6c660ac/</url>
    
    <content type="html"><![CDATA[<h2 id="机器数：万物之基"><a href="#机器数：万物之基" class="headerlink" title="机器数：万物之基"></a>机器数：万物之基</h2><p><strong>就是二进制数，这些而二进制数能够被机器理解并执行。</strong></p><p><strong>机器数带有符号，计算机字长为8位，所以最高位代表符号，</strong>正数是0<strong>，</strong>负数是1<strong>，例如0000 0011就表示+3，1000 0011就代表-3。</strong> <strong>以上的0000 0011就是机器数。</strong></p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><p>带符号位的机器数对应的十进制数就是<strong>机器数的真值</strong>。例如: 0000 0011=+000 0011=+3</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>即最基本的使用二进制代表十进制，<strong>是人脑最容易理解的表示方式</strong>。</p><p><strong>[+1]原=0000 0001</strong></p><p><strong>第一位不表示值，只表示正负。</strong></p><p><strong>[1111 1111]代表-127</strong></p><p><strong>注：原码的0有两种表示形式：0000 0000和1000 0000</strong></p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p><strong>正数的反码是其本身；</strong></p><p><strong>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</strong></p><p><strong>[+1] = [0000 0001]原= [0000 0001]反</strong></p><p><strong>[-1] = [1000 0001]原= [1111 1110]反</strong></p><p><strong>如果一个反码表示的是负数，人脑****无法直观的看出来</strong>它的数值。通常要将其转换成原码再计算。</p><p><strong>注：0的反码也有两种：0000 0000和1111 1111</strong></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><strong>正数的补码还是其本身；</strong></p><p><strong>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)</strong></p><p><strong>[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补</strong></p><p><strong>[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补</strong></p><p><em>原码，反码，补码是表示同一个数字的三种不同形式。</em></p><h2 id="为什么要有补码和反码？"><a href="#为什么要有补码和反码？" class="headerlink" title="为什么要有补码和反码？"></a>为什么要有补码和反码？</h2><p><strong>计算十进制的表达式： 1 - 1 = 0</strong></p><p><strong>1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [1000 0010]原= -2</strong></p><p><strong>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</strong></p><p><strong>为了解决原码做减法的问题， 出现了反码：</strong></p><p><strong>计算十进制的表达式：1 - 1 = 0</strong></p><p><strong>1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [0000 0001]反+ [1111 1110]反= [1111 1111]反= [1000 0000]原= -0</strong></p><p><strong>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上，虽然人们理解上</strong><strong>+0和-0</strong>是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。</p><p><strong>于是补码的出现，解决了0的符号问题以及0的两个编码问题：</strong></p><p><strong>1-1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [0000 0001]补+ [1111 1111]补= [1 0000 0000]补=[0000 0000]补=[0000 0000]原注意：进位1不在计算机字长里。</strong></p><p><strong>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128：-128的由来如下：</strong></p><p><strong>(-1) + (-127) = [1000 0001]原+ [1111 1111]原= [1111 1111]补+ [1000 0001]补= [1000 0000]补</strong></p><p><strong>-1-127的结果应该是-128，在用补码运算的结果中，[1000  0000]补就是-128，但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。(对-128的补码表示[1000 0000]补，算出来的原码是[0000 0000]原，这是不正确的)</strong></p><p><strong>使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。</strong></p><p><strong>因为机器使用补码，所以对于编程中常用到的有符号的32位int类型，可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WillMo的人事档案</title>
    <link href="/posts/e6ed99b1/"/>
    <url>/posts/e6ed99b1/</url>
    
    <content type="html"><![CDATA[<h2 id="SCP-人事档案"><a href="#SCP-人事档案" class="headerlink" title="SCP 人事档案"></a>SCP 人事档案</h2><p><strong>员工编号：21-1944</strong></p><p><strong>姓名：WillMo ▆▆▆▆</strong></p><p><strong>性别：女</strong></p><p><strong>出生日期：05/11/9</strong></p><p><strong>最高教育经历:杭州▆▆▆▆大学 研究生</strong></p><p><strong>国籍：中国</strong></p><p><strong>所属站点：Site-CN-21</strong></p><p><strong>职位：特遣特工，3级网络工程师</strong></p><p><strong>入职日期：26/09/25</strong></p><p><strong>安全许可等级：3级</strong></p><h2 id="个人简介："><a href="#个人简介：" class="headerlink" title="个人简介："></a>个人简介：</h2><p>WillMo在网络运维方面拥有卓越的专业知识和丰富的经验。2024/06/12，WillMo曾“意外”骇入基金会内部网络而被派遣的MTF逮捕。鉴于其良好合作态度和过硬的技术，WillMo被允许在基金会工作并享受相关福利。</p><p><strong>专业技能：</strong></p><ul><li>应急处理基金会内网入侵情况，维护基金会网络资产的安全。</li><li>在程序架构和智能控制方面具有出色的能力，能够协助相关部门进行开发工作。</li><li>熟练掌握多种语言，包括英语和汉语，便于与不同背景的人员进行沟通和合作。</li><li>精通级特殊载具驾驶(特种车辆、牵引运载车辆、歼击机、空天战斗机，电子对抗飞机等)，以便执行任务时尽快到达指定地点或执行基金会任务。</li><li>基本级使用标准枪械（手枪，突击步枪，狙击步枪等），以便保护站点和任务期间攻击敌对GOI成员甚至异常个体。</li><li>专家级使用重型异常武器（单兵恶魔学防御系统，奇术步枪等），即使该技能已被道德伦理委员会证明为非法获取，但仍能够允许其在高危战况下保护基金会资产甚至摧毁大型异常实体和其他GOI大型载具。</li></ul><p><strong>工作记录：</strong></p><ul><li><strong>协同工程部门共同开发了基金会太空武器-“灵弩”。</strong><br><img src="https://s2.loli.net/2024/09/07/ygkp6EIjtHLefQY.jpg" alt="freecompress-768024303850541199_3_.jpg"></li></ul><blockquote><p>WillMo博士对接“灵弩”时的记录</p></blockquote><ul><li><p>注意到与其年龄和入职时间不符合的技能掌握程度，道德伦理委员会对WillMo博士展开调查并证实其使用了多重非法手段（包括但不限于违规使用异常项目▆▆▆▆等手段）迅速获取了一系列技能，并对其提出弹劾，后被O5议会将提案降级为警告处罚。</p><ul><li>被O5议会配发特别行动令牌，以便收容失效时打开4级权限以下的防爆门。<br><img src="https://s2.loli.net/2024/09/08/SLFyBYnsAM7VKwI.jpg" alt="_W_VWV__TYXR_XWV__S_MVF.jpg"></li></ul></li></ul><blockquote><p>特别行动令牌</p></blockquote><p><strong>心理评估：</strong></p><p><strong>显示出中度的心理稳定性和适应能力，但在面对高压力和特殊异常情况时较难保持冷静和理智。</strong></p><p><strong><del>对欠薪的情况十分抗拒甚至抱有敌意</del>工作情绪稳定，但薪资需要按时发放。</strong></p><p><strong>禁止任何非心理部门的员工在WillMo博士面前提起王▆▆特工，违者将被行政处罚。</strong></p><p><strong>异常效应</strong></p><blockquote><p>现已确认WillMo博士收到AE-231的严重影响</p></blockquote><p><strong>AE-231表现为一种周期性异常现象，周期为7天。在此周期内，AE-231将引发一种与受影响个体高度相似的实体（以下简称AE-231-1）在指定空间内形成，并立即对受影响个体发起攻击。AE-231-1展现出与受影响个体相同的武器操作能力和战斗技巧，并能够自由操纵受影响个体在异常效应期间使用过的所有武器。</strong></p><p><strong>AE-231的影响还包括在受影响区域内生成大量黑色块状物质，这些物质对所有已知破坏手段免疫，且会阻塞该空间与外界的通道。此外，AE-231影响区域内的所有摄像设备均会受到严重干扰，无法提供有效图像。</strong></p><p><strong>在AE-231的影响下，若受影响个体死亡，黑色块状物质将自燃而不释放热量，AE-231-1将消失。若AE-231-1死亡，受影响个体的伤势将迅速自愈，黑色块状物质将逐渐消散。</strong></p><p><strong>备注</strong></p><p>“请求给他配备基金会的便携式能量武器，我们应该让特工出身的他有能力用特殊的武器保护自己，而不是看着他在肉搏中遭遇意外。”</p><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">------特工紫罗兰</span><br></code></pre></td></tr></tbody></table></figure><p>“我理解你说的，但别忘了AE-231-1的武器也会随之变化，更强大的武器只会让他的不确定因素增加。我们一方面会找到破局之法，一方面会为他提供更高强度的战斗训练，我们会尽最大努力保护为基金会做过贡献的职员。”                                                —–人事主任Dr.▆▆</p><p><strong>邮件记录</strong></p><blockquote><p>致O5-1：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">如你所见，我的情况不容乐观，但世界的情况比我要糟得多。人类是被宣判了死刑的囚徒，而我只是一个彻头彻尾的赌徒。我请求议会停止所有试图解除我异常效应的探索，把经费和人力资源移交到更重要的事业上去。我在和AE<span class="hljs-string">-231</span><span class="hljs-string">-1</span>中不止尝到了痛苦，我还知道他是过去的特工束影，他试图杀死我，取代我，变得比上一次更强，才是我活下去唯一的办法，才是人类走下去得唯一道路。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">-----Dr.WillMo</span><br></code></pre></td></tr></tbody></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scp</tag>
      
      <tag>档案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题自定义界面使用markdown</title>
    <link href="/posts/379e7120/"/>
    <url>/posts/379e7120/</url>
    
    <content type="html"><![CDATA[<p>创建自定义界面时，使用以下格式即可，可继承hexo对markdown的特定渲染。</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"markdown-body"</span>&gt;<br>正文<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未来计划</title>
    <link href="/posts/db95087c/"/>
    <url>/posts/db95087c/</url>
    
    <content type="html"><![CDATA[<h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><h2 id="1-顶级期刊"><a href="#1-顶级期刊" class="headerlink" title="1.顶级期刊"></a>1.顶级期刊</h2><p>**可以找老师要，上面论文要多看看，目前已知(待验证)**<strong>Computer Networks</strong></p><p><strong>Journal of Network and Computer Applications</strong></p><p><strong>International Journal of Communication Systems</strong></p><p><strong>Wireless Networks</strong></p><p><strong>Computer Communications</strong></p><h2 id="2-行业现实很重要"><a href="#2-行业现实很重要" class="headerlink" title="2.行业现实很重要"></a>2.行业现实很重要</h2><p><strong>（无论科研还是就业，①参考取景框看世界的专业和行业深度解读视频②各类机构针对该行业的最新行业报告注意是行业不是专业。)</strong></p><h2 id="3-AI大模型"><a href="#3-AI大模型" class="headerlink" title="3.AI大模型"></a>3.AI大模型</h2><p><strong>（Al工具：文心一言，讯飞星火，豆包，kimi等下集更详细）</strong></p><h2 id="4-多媒体技能"><a href="#4-多媒体技能" class="headerlink" title="4.多媒体技能"></a>4.多媒体技能</h2><p><strong>（首推：图片和视频处理。比较推荐做自媒体，只是推荐没说必须，自行选择哟。电脑上：Adobe全家桶中的PS和PR）</strong></p><h2 id="5-办公自动化技能"><a href="#5-办公自动化技能" class="headerlink" title="5.办公自动化技能"></a>5.办公自动化技能</h2><p><strong>（技能建议大家采用需求导向学习：先看入门的基础教程or教材，然后打住，具体运用中碰到实际问题再针对学习进阶的技巧和操作）</strong></p><h2 id="6-理工农科"><a href="#6-理工农科" class="headerlink" title="6.理工农科"></a>6.理工农科</h2><p><strong>（熟练掌握学科要求的软件还有编程]专业英语要打磨好哟，因为学校要求一般是SCI的英文期刊。）</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>可以关注其他专业和自己专业的结合点针对展开其他领域的技能学习)</strong></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><strong>当我写下这份文档，过去的一切已与我彻底诀别，不顾过去，循此苦旅，直抵群星。       ——Dr.WillMo</strong></p><p>2024年8月31日</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>计划</tag>
      
      <tag>坚持</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>孤独之旅</title>
    <link href="/posts/4553e66c/"/>
    <url>/posts/4553e66c/</url>
    
    <content type="html"><![CDATA[<h1 id="孤独之旅"><a href="#孤独之旅" class="headerlink" title="孤独之旅"></a>孤独之旅</h1><p>PS:好友写的文，走向成熟与独立是我们每个人的必经之路，特此纪念。              ——WillMo</p><p>开学报告的那一天，公寓楼里楼外都挤满了许多的新生和他们的家长。家长们含辛茹苦地帮孩子打理了几乎所有的东西。</p><p>然而，这个来自遥远的南方的男孩却显得格格不入:蓬头垢面，孤零零一人拖着一堆的行李。在如山高的人海中，他是那么的矮小。</p><p>他独自笨拙地整理着床铺，独自为缺少的物资而发愁、奔波。他不善长打交道，面对一群“外地人”的追问，他只能木讷地笑笑。</p><p>他曾想要当一名好军训学员，可他今天却晕晕地发烧病倒了。</p><p>他曾以为“只要能吃就行”，可他吃下麻婆豆腐后嗓子被辣哑了。</p><p>他曾想为家里省下买书钱而一人劳碌了半天，可他的努力被“买书只能买一整套”的公告给撕碎了。</p><p>椰子树的身影不再，迎面而来的是挺拔的松、杉、柏木；南方的口音不再，四周充满着升调的北方口音；熟悉的朋友们不再，只能一个人慢慢地摸爬滚打……</p><p>“等待我的是什么呢？”他心想，“是将来有可能挂科的数学，内卷的焦虑，还是就业升学的彷徨?亦或者是各种生活上的烦恼……”</p><p>酸痛麻木的四肢和眩晕的大脑不允许他继续想下去了。梦里，他和曾经朝夕相伴的基友们一起，躺在小叶榄仁下，痴痴地望着天上的白云，看它们懒洋洋地<strong>聚拢、舒展，和飘散……</strong><br><a href="https://imgse.com/i/pAEFRbD"><img src="https://s21.ax1x.com/2024/08/30/pAEFRbD.jpg" alt="pAEFRbD.jpg"></a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二周目无伤游行大师</title>
    <link href="/posts/5fcdfef9/"/>
    <url>/posts/5fcdfef9/</url>
    
    <content type="html"><![CDATA[<p><strong>二周目无伤游行大师，也算是了结了类魂从未过无伤的遗憾。</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"> <iframe src="https://player.bilibili.com/player.html?isOutside=true&amp;aid=113001042546265&amp;bvid=BV1atWMeFENn&amp;cid=500001657555076&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lies of p</tag>
      
      <tag>游戏时刻</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于存在主义的一点思考</title>
    <link href="/posts/Infinity/"/>
    <url>/posts/Infinity/</url>
    
    <content type="html"><![CDATA[<h2 id="人生的意义是什么？"><a href="#人生的意义是什么？" class="headerlink" title="人生的意义是什么？"></a>人生的意义是什么？</h2><h3 id="·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母…-而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。"><a href="#·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母…-而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。" class="headerlink" title="·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母….而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。"></a>·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母….而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。</h3><h3 id="·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”"><a href="#·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”" class="headerlink" title="·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”"></a>·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”</h3><h3 id="·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。"><a href="#·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。" class="headerlink" title="·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。"></a>·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。</h3><h3 id="·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。"><a href="#·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。" class="headerlink" title="·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。"></a>·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。</h3><h3 id="·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。"><a href="#·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。" class="headerlink" title="·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。"></a>·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。</h3><h2 id="How-do-you-believe-How-do-you-live"><a href="#How-do-you-believe-How-do-you-live" class="headerlink" title="How do you believe How do you live."></a>How do you believe How do you live.</h2><h2 id="你怎样信仰-你就怎样生活"><a href="#你怎样信仰-你就怎样生活" class="headerlink" title="你怎样信仰 你就怎样生活"></a>你怎样信仰 你就怎样生活</h2>]]></content>
    
    
    <categories>
      
      <category>哲学思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实战演练】：绕过Cloudflare获取网站真实IP</title>
    <link href="/posts/e39bfa4e/"/>
    <url>/posts/e39bfa4e/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>笔者暑假内卷累了，网上冲浪的时候发现了需求：</p><p><a href="https://imgse.com/i/pC7Bix1"><img src="https://s1.ax1x.com/2023/07/19/pC7Bix1.png" alt="pC7Bix1.png"></a>看起来还有一定的悬赏，所以试一试。<br>我已获得站长授权，属于合法测试。</p><h3 id="理论思路"><a href="#理论思路" class="headerlink" title="理论思路"></a>理论思路</h3><p>一个网站注定留下蛛丝马迹，具体思路可以是挖洞，搜索引擎（google hacking等），或者RSS邮箱泄密，我们试着第二种。<br>而对于三件套，这是用来查找在线服务的工具，就好比说shodan，与谷歌不同的，Shodan不是在网上搜索网址，而是直接进入互联网的背后通道。Shodan可以说是一款“黑暗”谷歌，一刻不停的在寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。每个月Shodan都会在大约5亿个服务器上日夜不停地搜集信息。<br>信息收集————<a href="https://search.censys.io/">Censys</a>查DNS解析记录————网监三件套（<a href="https://www.shodan.io/">Shodan</a>，<a href="https://www.zoomeye.org/">钟馗之眼</a>，<a href="https://fofa.info/">Fofa</a>）————Nmap扫描端口————逐个排查————访问检验。</p><h3 id="实践开始"><a href="#实践开始" class="headerlink" title="实践开始"></a>实践开始</h3><p>测试目标：<a href="https://develxxxxx.com/%EF%BC%88%E4%BF%9D%E6%8A%A4%EF%BC%8C%E5%85%8D%E5%BE%97%E9%97%B2%E4%BA%BADDos%E6%90%9E%E4%BA%8B%EF%BC%89">https://develxxxxx.com/（保护，免得闲人DDos搞事）</a><br>笔者打开Censys，查了一波。<a href="https://imgse.com/i/pCTaDdH"><img src="https://s1.ax1x.com/2023/07/18/pCTaDdH.png" alt="pCTaDdH.png"></a>什么都没有<br>那就开三件套看看，我们首选Fofa，用起来方便些。先访问一下网站，出现了网站标题：<a href="https://imgse.com/i/pCTawLD"><img src="https://s1.ax1x.com/2023/07/18/pCTawLD.png" alt="pCTawLD.png"></a><br>看起来是一个Hexo的博客，那就以标题为切入点，在Fofa输入<code>title="Hexo" &amp;&amp; country="KR" &amp;&amp; region="Seoul"</code>弹出以下结果：<a href="https://imgse.com/i/pCTayFA"><img src="https://s1.ax1x.com/2023/07/18/pCTayFA.png" alt="pCTayFA.png"></a><br>很好，但一个个排查太浪费时间了，我们做一下<a href="https://port.hwcha.com/">端口扫描</a>，发现了一些开放端口，这会成为判断依据<a href="https://imgse.com/i/pCTaTFs"><img src="https://s1.ax1x.com/2023/07/18/pCTaTFs.png" alt="pCTaTFs.png"></a><br>将扫出来的端口键入搜索语句，有<code>title="Hexo" &amp;&amp; country="KR" &amp;&amp; region="Seoul" &amp;&amp; port="80"</code>这里调用80端口是因为其很常见，一般网站都会以此作为门户，得到了结果<a href="https://imgse.com/i/pCTarod"><img src="https://s1.ax1x.com/2023/07/18/pCTarod.png" alt="pCTarod.png"></a>发现158开头的很明显摆在了第二位，单机终端图标看看网站正文，发现了网站中相应的字样“主题，博主等”<a href="https://imgse.com/i/pCTdpk9"><img src="https://s1.ax1x.com/2023/07/18/pCTdpk9.png" alt="pCTdpk9.png"></a>，猜测得到验证，由此我们就得到了真实IP地址。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本站被暗黑引擎抓到了数据包，可能存在被绕过Cdn而Ddos攻击的风险。<br>感谢阅读！</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hacking</tag>
      
      <tag>网安</tag>
      
      <tag>Cloudflare</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Fluid中添加一言</title>
    <link href="/posts/7938d7d6/"/>
    <url>/posts/7938d7d6/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="一言-隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。"><a href="#一言-隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。" class="headerlink" title="一言,隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。"></a><a href="http://hitokoto.cn/">一言</a>,隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。</h3><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="一言可以增加博客的随机性和文学性，有利于丰富网站内容。"><a href="#一言可以增加博客的随机性和文学性，有利于丰富网站内容。" class="headerlink" title="一言可以增加博客的随机性和文学性，有利于丰富网站内容。"></a>一言可以增加博客的随机性和文学性，有利于丰富网站内容。</h3><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="在Fluid的主题配置”（指的是-theme-x2F-fluid-x2F-config-yml-或者-config-fluid-yml，这取决于你安装Fluid的方式）中找到（ctrl-F）Slogan打字机相关配置，将其改为如下配置"><a href="#在Fluid的主题配置”（指的是-theme-x2F-fluid-x2F-config-yml-或者-config-fluid-yml，这取决于你安装Fluid的方式）中找到（ctrl-F）Slogan打字机相关配置，将其改为如下配置" class="headerlink" title="在Fluid的主题配置”（指的是 theme/fluid/_config.yml 或者 _config.fluid.yml，这取决于你安装Fluid的方式）中找到（ctrl+F）Slogan打字机相关配置，将其改为如下配置;"></a>在Fluid的主题配置”（指的是 theme/fluid/_config.yml 或者 _config.fluid.yml，这取决于你安装Fluid的方式）中找到（<strong>ctrl+F</strong>）Slogan打字机相关配置，将其改为如下配置;</h3><figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs autoit">slogan:<br>  enable: <span class="hljs-literal">true</span>       <span class="hljs-meta"># 改为true</span><br><br>  <span class="hljs-meta"># 为空则按 hexo config.subtitle 显示</span><br>  <span class="hljs-meta"># If empty, text based on `subtitle` in hexo config</span><br>  text: <span class="hljs-string">"明眸如初，又见苍岚"</span>           <span class="hljs-meta">#写不写都可以</span><br><br>  <span class="hljs-meta"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span><br>  <span class="hljs-meta"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span><br>  api:<br>    enable: <span class="hljs-literal">true</span><br><br>    <span class="hljs-meta"># 请求地址</span><br>    <span class="hljs-meta"># Request url</span><br>    url: <span class="hljs-string">"https://v1.hitokoto.cn/"</span>            <span class="hljs-meta">#添加一言接口</span><br><br>    <span class="hljs-meta"># 请求方法</span><br>    <span class="hljs-meta"># Request method</span><br>    <span class="hljs-meta"># Available: GET | POST | PUT</span><br>    method: <span class="hljs-string">"GET"</span>                       <br><br>    <span class="hljs-meta"># 请求头</span><br>    <span class="hljs-meta"># Request headers</span><br>    headers: {}   <br><br>    <span class="hljs-meta"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 {<span class="hljs-string">"data"</span>: {<span class="hljs-string">"author"</span>: <span class="hljs-string">"fluid"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"An elegant theme"</span>}}, 则取值字段为 [<span class="hljs-string">'data'</span>, <span class="hljs-string">'content'</span>]；如果返回是列表则自动选择第一项</span><br>    <span class="hljs-meta"># The value field of the string obtained from the response. For example, the response content is {<span class="hljs-string">"data"</span>: {<span class="hljs-string">"author"</span>: <span class="hljs-string">"fluid"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"An elegant theme"</span>}}, the expected `keys: [<span class="hljs-string">'data'</span>,<span class="hljs-string">'content'</span>]`<span class="hljs-comment">; if the return is a list, the first item is automatically selected</span></span><br>    keys: [<span class="hljs-string">'hitokoto'</span>]                    <span class="hljs-meta">#填写Keys</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="保存，键入hexo-clean-hexo-g-hexo-s-即可预览效果。"><a href="#保存，键入hexo-clean-hexo-g-hexo-s-即可预览效果。" class="headerlink" title="保存，键入hexo clean  hexo g hexo s 即可预览效果。"></a>保存，键入<code>hexo clean</code>  <code>hexo g</code> <code>hexo s </code>即可预览效果。</h3>]]></content>
    
    
    <categories>
      
      <category>博客折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《百年孤独》：拉美的呻吟</title>
    <link href="/posts/986a860d/"/>
    <url>/posts/986a860d/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面：本文将从魔幻现实主义的巅峰，拉美的历史，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》"><a href="#写在前面：本文将从魔幻现实主义的巅峰，拉美的历史，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》" class="headerlink" title="写在前面：本文将从魔幻现实主义的巅峰，拉美的历史，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》"></a>写在前面：本文将从魔幻现实主义的巅峰，<strong>拉美的历史</strong>，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》</h1><h2 id="金句摘抄"><a href="#金句摘抄" class="headerlink" title="金句摘抄"></a>金句摘抄</h2><p><font face="华文新魏" color="black" size="6">        1.生命中曾经有过的所有灿烂，原来终究，都需要用寂寞来偿还。</font></p><font face="华文新魏" color="black" size="6"><p>2.无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路。</p><p>3.生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>4.买下一张永久车票，登上一列永无终点的火车。</p><p>5.只是觉得人的内心苦楚无法言说，人的很多举措无可奈何，百年一参透，百年一孤寂。</p><p>6.平庸将你的心灵烘干到没有一丝水分，然后荣光才会拨动你心灵最深处的弦。</p><p>7.预感总是悠然来临，灵光一现，好像一种确凿无疑的信念在瞬间萌生却无从捕捉。</p><p>8.往日的推心置腹已经一去不返，同谋和交流变成敌意与缄默。</p><p>9.过去都是假的，回忆没有归路，春天总是一去不返，最疯狂执着的爱情也终究是过眼云烟。</p><p>10.很多人选择了向虚拟现实的魅力屈服，寄情于自我幻想，这纵然不切实际却更能与人安慰。</p><p>11.我们趋行在人生这个更古的旅途，在坎坷中奔跑，在挫折里涅盘忧愁缠满全身，痛苦飘洒一地我们累，却无从止歇；我们苦，却无法回避。</p><p>12.战争已经被扔进了存放悲惨记忆的高阁它仅仅在开启香槟酒的砰砰爆气里被偶尔提到。</p><p>13.此时微风初起；风中充盈着过往的群声喊喳，日日天竺葵的呢喃，无法排遣的怀念来临前的失望叹息。</p><p>14.一个幸福晚年的秘诀不是别的，而是与孤寂签订一个体面的协定。</p><p>15.一分钟的和好抵得过一辈子的友谊。</p><p>16.寂寞是造化对群居者的诅咒，孤独才是寂寞唯一出口。</p><p>17.多年以后，面对行刑队</p><p>奥雷里亚诺·布恩迪亚上校将会回想起父亲带他</p><p>去见识冰块的那个遥远的下午。</p><p>18.原来时间也会失误和出现意外，并因此迸裂，在某个房间留下永恒的片段。</p><p>19.死神一直追随他的脚步。嗅闻他的行踪，但尚未下定决心，给他最后一击。</p><p>20.“奥雷里亚诺”，他悲伤地敲下发报键，“马孔多在下雨。”</p><p>21.生命从来不曾离开过孤独而独立存在。无论是我们出生、我们成长、</p><p>22.我们相爱还是我们成功失败</p><p>直到最后的最后</p><p>孤独犹如影子一样存在于生命一隅。</p><p>羊皮卷上所载一切</p><p>自永远至永远不会在重复，</p><p>因为注定经受百年孤独的家族</p><p>不会有第二次机会在大地上出现。</p></font><p><font face="华文新魏" color="black" size="6">不到一百年，就不该有人知道其中的含义。<br></font></p><h2 id="魔幻现实主义的巅峰"><a href="#魔幻现实主义的巅峰" class="headerlink" title="魔幻现实主义的巅峰"></a>魔幻现实主义的巅峰</h2><p><font face="华文新魏" color="black" size="6"><img src="https://s1.ax1x.com/2022/08/13/vNtcFJ.jpg" alt="image"><br>《百年孤独》是哥伦比亚作家加西亚·马尔克斯创作的长篇小说，是其代表作，也是拉丁美洲魔幻现实主义文学的代表作，被誉为“再现拉丁美洲历史社会图景的鸿篇巨著””魔幻现实主义的巅峰之作“。<br>什么是魔幻现实主义？魔幻现实主义指的是20世纪的一种绘画，这种绘画用现实主义（REALISM）的精确来描绘物体，但是却悖论般地表现出一种由于对时空因素进行迥然不同的并置所致的奇异的效果，后继而成为一种文学艺术形式。魔幻现实主义来自于拉美，在黑暗的殖民统治下，这种表现手法被广泛用于揭露社会弊端，抨击社会现实，是顺应历史之流的产物。</font></p><hr><h2 id="拉美的历史"><a href="#拉美的历史" class="headerlink" title="拉美的历史"></a>拉美的历史</h2><p><font face="华文新魏" color="black" size="6">美洲坐落于世界西方，是世界上自然条件最为优越的大陆之一。它有着锯齿形的海岸线和大流量的运河。五大湖为森林提供了充足的水源，原始的自然环境为繁多的动植物提供了居所，全大陆地形较为平整，适宜居住。<br>据考察，3万年前，来自西伯利亚的人们穿过白令海来到阿拉斯加，成为了开垦美洲的先驱者。即使早期移民来自于经济不发达的地区，但经过数千年的耕耘，美洲印第安人发展了丰富多彩的种种文化，其中包括2000种截然不同的文字和不同形式的耕作制度。此外，印第安人培育了100多种植物，其中的南瓜,玉米，可可，花生在现代都是极为重要的作物。<br>美洲印第安人逐渐形成了三大文明：玛雅文明，阿兹特克文明和印加文明。<br>15世纪，哥伦布的船队发现了美洲，就此带来了枪炮，战争，掠夺，动荡和拉美的伤口。石质砍刀对上火枪和战马，倒下的只有印第安人的尸体。尸横遍野，印第安人试图用发达的宗教和文化掩盖技术上落后的事实，但西方人的炮火始终没有停止咆哮。<br>仅仅一小群冒险者就可以轻易推翻和根除三大文明，技术压制当然不是唯一因素。另外一个因素是，反抗的一方缺乏最起码的团结。被夹在两大洋之间的美洲不具备跨过大海与其他文明交流的能力，甚至各印第安文明之间也缺乏交流，因此没有相互影响.</font></p><font face="华文新魏" color="black" size="6"><blockquote><p>关于秘鲁和中美洲之间的相互关系，完全可以说，人们已经承认，在从形成期到西班牙人入侵这段漫长的时期内，所有证明这些地区之间存在着相互联系的实物或记录都是不可靠的。</p></blockquote></font><p><font face="华文新魏" color="black" size="6">硝烟过后，殖民者开始切割美洲的血管，用血腥的手去夺取血腥的财宝。欧洲列强对拉丁美洲实行了三次掠夺。<br>一是直接性掠夺：<br>1532年9月，殖民者皮萨罗对印加帝国发动战争，俘获了国王阿塔瓦尔帕，勒索了数万磅的真金白银。得到百分之二十分成的西班牙王室又加大战争拨款，给拉美的财富给予重创。手持枪炮的士兵把拉美的金银送到欧洲贵族的腰包里，用来装裱他们的城堡。<br>二是土地掠夺：在榨干拉美的金银之后，英国开始进行三角贸易，从非洲拉来的黑奴在拉美的土地上种植香蕉，烟草等让西方贵族满意的商品，再运到欧洲大肆出售。土地的过度利用和粮食作物的稀缺使拉美人民苦不堪言。<br>三是经济掠夺：长期被列强统治的拉美根本没有发展工业的机会，拉美就不可能制作自己的工艺品。而美洲人民只好依赖出口低级农产品勉强过活，但却不得不用十倍以上的价格买回欧洲的工艺品，列强的资本输出使得美洲更加贫困。<br>拉美的文明在外来侵略的浪潮中愈加贫困，丧失了出路和希望。</font></p><hr><h2 id="马孔多的百年"><a href="#马孔多的百年" class="headerlink" title="马孔多的百年"></a>马孔多的百年</h2><p><font face="华文新魏" color="black" size="6">《百年孤独》讲述了以何塞·阿尔卡蒂奥·布恩迪亚为首的乡亲在荒野之中开辟新家园“马孔多”的故事。随时代的改变，马孔多先后经历了兴盛与衰败，贫苦与富足，安定与动乱，繁华与死寂。而布恩迪亚家族的故事也在飓风的呼啸声和蚂蚁的啃咬声中走到了尽头，”一场突如其来的飓风把整个儿马孔多镇从地球上刮走，从此这个村镇就永远地消失了。</font></p><h2 id="孤独的意义"><a href="#孤独的意义" class="headerlink" title="孤独的意义"></a>孤独的意义</h2><p>  <font face="华文新魏" color="black" size="5">作者马尔克斯出生于哥伦比亚，他在见证了拉美令人哭泣和绝望的历史后写下了这部荒诞的家族史，因此，《百年孤独》很大程度上是拉美历史的缩影。从何塞·阿尔卡蒂奥·布恩迪亚的玻璃城市梦境和布恩迪亚家族的抗争史中可知，《百年孤独》的主题便是孤独与绝望，孤独在绝望中愈演愈烈，绝望在孤独中肆意生长。<br>   孤独这一主题是在书中的描写中揭示的。书中极少对家族成员之间的交流进行描写，展示在我们面前的好像是一个没有感情，没有信任，没有了解的可悲家庭。孤独是布恩迪亚家族的家徽，每位家庭成员不由自主地佩戴它，而他们在试图摆脱孤独时又被孤独束缚住了手脚，最后的结果不是在无尽的空虚中了结了自己就是再次被扔回到孤独的深海中去，家族的创始人何塞·阿尔卡蒂奥·布恩迪亚晚年因为思想守旧，在面对新事物时又被孤独击败，疯癫地成为树下的可怜虫；奥雷里亚诺上校一生经历了32场战争，遭遇14次暗杀，73次埋伏，后因战争的不明意义试图开枪自杀。<br>    绝望来自于失败，而失败源于抗争，布恩迪亚家族史可以说是一部抗争史。在故事的开始，夫妻二人就为了逃避骂声和偏见而开辟马孔多；后人又在为了某些东旭（尊严，自由，金钱）而抗争。上校起初以自由为口号发动战争，后才发觉自己是在用权力和战火掩饰自己的胆怯，仅仅是为了尊严而开枪；何塞·阿尔卡蒂奥第二引领工人运动，为工人利益而斗争······而这些英雄般的斗争，也最终迎来了结局：自由党上校的全线投降和3000名工人横七竖八的尸体···，人们在失败中绝望，在绝望中更加孤独。但有一人例外，与孤独斗争许久的乌尔苏拉被认为是家族精神的代表，她竭力反抗，想尽一切办法联合家族和马孔多，但依然没有成效和出路，最终在晚年被岁月追上，化作尘土。<br> 书中有两个值得注意的细节：一是上校的同僚马尔克斯上校与作者同名。像对马孔多一样，马尔克斯也见证了拉美的历史。却又对苟延残喘的拉美爱莫能助。二是家族中重复命名的每一代人都没有重复上一代人所做的事，但都无一例外地迎来了失败的结局。<br> 本书最大的手法就是以小见大，马孔多已不仅仅是荒野中的一个小镇，更是整个拉美文明的代表。同时拥有富饶的自然资源和广大贫苦人民的拉美是畸形的，也是可悲的。鲁迅说：“悲剧就是将有价值的东西毁灭给人看。”西方殖民者三次掠夺美洲，以枪炮掏空美洲的内脏，压迫着拉美的人民。面对外来文化，拉美人民不是没有抗争过，而是像书中的重复命名一样：尽管方式各不相同，但最终躲不开封建主义和资本主义的打击，逃不掉失败的命运。这也许就是为什么羊皮卷上写的：“家族的第一个人被绑在树上死去，最后一个人被蚂蚁吃掉。”有如此强的宿命感。黑格尔说：“人类从历史中学到的唯一教训，就是没有从历史中吸取到任何教训。”书中“失眠症”的后果就是失忆。拉美越来越多年轻人开始忘记拉美那段屈辱而血腥的历史，再加上在少数人的别有用心，拉美的历史逐渐不被人提起，成为历史的悲剧。</font><br> <font face="华文新魏" color="black" size="6">马尔克斯上校看着窗外的大雨说：“马孔多在下雨。”这场雨到现在都没有停，而真正造成在场雨的人不知道，也不在乎。</font></p>]]></content>
    
    
    <categories>
      
      <category>拾遗阁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Book</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

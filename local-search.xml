<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/posts/Mybatis/"/>
    <url>/posts/Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>框架（Framework）是一种<strong>半成品软件</strong>，它提供了一套完整的、可重用的设计、代码和库，旨在帮助开发者<strong>解决特定领域或类型的问题</strong>。框架通常规定了软件系统的整体结构、主要组件及其之间的关系，以及它们之间的交互方式。框架相对于库不仅提供了一组工具，还规定了应用的结构和流程。开发者需要在框架的约束下工作，通过实现特定的接口或继承特定的类来完成应用的功能。</p><h2 id="JDBC的问题"><a href="#JDBC的问题" class="headerlink" title="JDBC的问题"></a>JDBC的问题</h2><p>JDBC（Java Database Connectivity）是Java语言中用于执行SQL语句的应用程序接口（API），它为Java程序提供了一种与各种关系型数据库进行交互的标准方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.servlet;<br><br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCexample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">jdbcURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jdbc:mysql://localhost:3306/willmo_cms"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"root"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"root"</span>;            <br><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(jdbcURL, username, password)) {<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) {<br>                System.out.println(<span class="hljs-string">"Connected to the database!"</span>);<br>            }<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(jdbcURL, username, password);<br>             <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">"INSERT INTO test_table1 (id, Name,age) VALUES (12, 'JDBC插入测试',123)"</span>)) {<br><br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsAffected</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            <span class="hljs-keyword">if</span> (rowsAffected &gt; <span class="hljs-number">0</span>) {<br>                System.out.println(<span class="hljs-string">"A new row has been inserted."</span>);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这对我们来说有几个问题</p><ul><li>繁冗赘余</li><li>SQL和java代码紧紧耦合在一起，难以分开处理</li></ul><p><code>Mybatis</code>正是为了解决这个问题。</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>MyBatis 是一款优秀的<strong>持久层框架</strong>，它支持<strong>自定义 SQL</strong>、存储过程以及<strong>高级映射</strong>。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><table><thead><tr><th>步骤</th><th>核心任务</th><th>关键产出</th><th>简要说明</th></tr></thead><tbody><tr><td>1</td><td><strong>项目初始化</strong></td><td><code>pom.xml</code>(Maven)</td><td>在项目中引入 MyBatis 及其数据库驱动等依赖。</td></tr><tr><td>2</td><td><strong>核心配置</strong></td><td><code>mybatis-config.xml</code></td><td>配置数据源（数据库连接）、事务管理器、以及映射文件路径等。</td></tr><tr><td>3</td><td><strong>创建实体类</strong></td><td>例如 <code>User.java</code></td><td>创建与数据库表结构对应的 Java 类（POJO）。</td></tr><tr><td>4</td><td><strong>创建Mapper接口</strong></td><td>例如 <code>UserMapper.java</code></td><td>定义数据操作的方法（如 <code>selectUserById</code>）。</td></tr><tr><td>5</td><td><strong>编写SQL映射</strong></td><td>例如 <code>UserMapper.xml</code></td><td>在 XML 文件或注解中具体实现 SQL 语句，这一步是为了打开操作数据库的窗口。</td></tr><tr><td>6</td><td><strong>使用SqlSession</strong></td><td>测试代码</td><td>获取 <code>SqlSession</code>，得到 Mapper 接口实例，调用方法完成数据库操作。</td></tr></tbody></table><h3 id="引入依赖和配置"><a href="#引入依赖和配置" class="headerlink" title="引入依赖和配置"></a>引入依赖和配置</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a>Mybatis配置</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-string">"https://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/willmo_cms"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>   <br>                <span class="hljs-comment">&lt;!-- 配置数据库的地址，操作账号和密码 --&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"Mapper/UserMapper.xml"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="创建用户类"><a href="#创建用户类" class="headerlink" title="创建用户类"></a>创建用户类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.servlet;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>}   <span class="hljs-comment">//对应了数据库中存在的三个字段，姓名年龄ID</span><br></code></pre></td></tr></tbody></table></figure><h3 id="创建Mapper接口"><a href="#创建Mapper接口" class="headerlink" title="创建Mapper接口"></a>创建Mapper接口</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Mybatis_demo;<br><br><span class="hljs-keyword">import</span> org.example.servlet.User;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> {     <span class="hljs-comment">//这仅仅是一个接口，方法主体的sql语句将在另一个SQL映射文件填充</span><br> List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br> User <span class="hljs-title function_">GetById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="创建SQL映射文件"><a href="#创建SQL映射文件" class="headerlink" title="创建SQL映射文件"></a>创建SQL映射文件</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-string">"https://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"Mybatis_demo.UserMapper"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span>&gt;</span><br>        insert into test_table1(id,Name,age) values(#{id},#{name},#{age})<br>        <span class="hljs-comment">&lt;!-- #{}是引用java方法中传入的参数名 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在这里写sql语句尽量不要在末尾加分号--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.servlet.User"</span>&gt;</span><br>        select id,Name,age from test_table1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"GetById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.servlet.User"</span>&gt;</span><br>        select id,Name,age from test_table1 where id = #{id}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="使用sqlsession"><a href="#使用sqlsession" class="headerlink" title="使用sqlsession"></a>使用sqlsession</h3><blockquote><p>这是在主方法直接使用Mybatis的部分，我们需要将sqlseesion实例化才能使用Mybatis对应的方法。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Mybatis_demo;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.example.servlet.User;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">mybatisDemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 读取配置文件</span><br>        InputStream inputStream;<br><br>        {<br>            <span class="hljs-keyword">try</span> {<br>                inputStream = Resources.getResourceAsStream(<span class="hljs-string">"mybatis-config.xml"</span>);<br>            } <span class="hljs-keyword">catch</span> (IOException e) {<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            }<br>        }<br><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream); <span class="hljs-comment">//新建工厂类</span><br>        <span class="hljs-comment">// 获得会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; list = userMapper.list();<br>        <span class="hljs-comment">// 获取相关的执行器</span><br>        System.out.println(<span class="hljs-string">"总和用户数量为"</span>+list.size());<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br>        user1.setAge(<span class="hljs-number">90</span>);<br>        user1.setId(<span class="hljs-number">10</span>);<br>        user1.setName(<span class="hljs-string">"插入测试"</span>);<br>        userMapper.insert(user1);<br>        sqlSession.commit();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;= list.size()+<span class="hljs-number">1</span>;i++) {<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.GetById(i);<br>            System.out.println(user);<br>        }<br>    sqlSession.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="Mybatis的核心配置"><a href="#Mybatis的核心配置" class="headerlink" title="Mybatis的核心配置"></a>Mybatis的核心配置</h1><p>可以上滑查看Mybatis配置，这就是我们连接数据库的配置，它解释了连接哪个数据库，操作的账号密码，操作模式等等。为了后续的开发更轻松，我们有必要学习一些配置的技巧</p><blockquote><p><strong>配置是有顺序的</strong>，请保证顺序正确，否则会报错</p></blockquote><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p><p>例如方法实现</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>"list" resultType<span class="hljs-operator">=</span>"org.example.servlet.User"<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>其中的 <code>org.example.servlet.User</code>是一个全限定类名，写起来可能有些繁琐，如果我们限定类名</p><p><code>&lt;typeAliases&gt; &lt;typeAlias alias="User" type="org.example.servlet.User"/&gt; &lt;/typeAliases&gt;</code></p><p>就能够直接使用 <code>User</code>来确认返回值。</p><blockquote><p>尊重xml语法，定义别名需要包含在typeAliases标签里。</p></blockquote><h2 id="SQL标签"><a href="#SQL标签" class="headerlink" title="SQL标签"></a>SQL标签</h2><table><thead><tr><th>resultType</th><th>期望从这条语句中返回结果的类全限定名或别名。                注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。</th></tr></thead><tbody><tr><td>resultMap</td><td>对外部 resultMap 的命名引用。结果映射是 MyBatis                最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。</td></tr></tbody></table><p>这两个指定返回值类型只能使用一个，他们都能够将数据库返回类型转换成java数据类型，但是resultMap更加灵活，可以指定字段的映射规则。</p><p>java方法传入参数名和数据库字段相同时，就能够自动映射完成sql语句的执行。但是有时候，java方法传入参数的字段，和数据库里的字段对不上，那就会造成错误，而resultmap能够给我们创建一个映射来解决这个问题。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Getuser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.servlet.User"</span>&gt;</span><br>        select id,Name,age from test_table1 ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>但是你的用户类定义是</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.servlet;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">public</span> String User_name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里的User_name和数据库字段Name对不上，我们就可以创建映射来使二者关联起来</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"userMap"</span> <span class="hljs-attr">type</span> = <span class="hljs-string">"org.example.Servlet.User"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span> = <span class="hljs-string">"Name"</span> <span class="hljs-attr">property</span> = <span class="hljs-string">"User_name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>由此，我们的数据库字段和java中的User类就可以遵循各自的命名规范。</p><h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><p>动态 SQL 可以在 XML 层根据方法传入的参数动态拼装 SQL，避免手写大量不同情况的 SQL 字符串。常用标签：<code>&lt;if&gt;</code>、<code>&lt;where&gt;</code>、<code>&lt;trim&gt;</code>、<code>&lt;foreach&gt;</code>。</p><p>在模糊查找的时候可用。</p><h3 id="1-lt-if-gt-—-条件片段"><a href="#1-lt-if-gt-—-条件片段" class="headerlink" title="1. <if> — 条件片段"></a>1. <code>&lt;if&gt;</code> — 条件片段</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"searchUsers"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"map"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.domain.User"</span>&gt;</span><br>  SELECT id, Name, age<br>  FROM test_table1<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null and name != ''"</span>&gt;</span><br>      AND Name = #{name}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"minAge != null"</span>&gt;</span><br>      AND age &gt;= #{minAge}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"maxAge != null"</span>&gt;</span><br>      AND age &lt;= #{maxAge}<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>&lt;if&gt;</code> 根据参数决定是否插入 SQL 片段。</li><li>结合 <code>&lt;where&gt;</code> 自动处理开头的 <code>AND/OR</code>（见下）。</li></ul><h3 id="2-lt-where-gt-—-自动处理前导逻辑运算符"><a href="#2-lt-where-gt-—-自动处理前导逻辑运算符" class="headerlink" title="2. <where> — 自动处理前导逻辑运算符"></a>2. <code>&lt;where&gt;</code> — 自动处理前导逻辑运算符</h3><p><code>&lt;where&gt;</code> 会在包含的 SQL 片段前自动加 <code>WHERE</code>，并去除多余的前导 <code>AND/OR</code>。<br>（上例演示 <code>&lt;where&gt;</code> 的常见用法）</p><h3 id="3-lt-trim-gt-—-更灵活的前后缀裁剪"><a href="#3-lt-trim-gt-—-更灵活的前后缀裁剪" class="headerlink" title="3. <trim> — 更灵活的前后缀裁剪"></a>3. <code>&lt;trim&gt;</code> — 更灵活的前后缀裁剪</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.example.domain.User"</span>&gt;</span><br>  UPDATE test_table1<br>  <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span>&gt;</span> Name = #{name}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"age != null"</span>&gt;</span> age = #{age}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>  WHERE id = #{id}<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>或使用 <code>&lt;trim&gt;</code>：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"SET"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name != null"</span>&gt;</span> Name = #{name}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"age != null"</span>&gt;</span> age = #{age}, <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>&lt;set&gt;</code> 是 <code>&lt;trim prefix="SET" suffixOverrides=",""&gt;</code> 的语法糖，适用于 <code>UPDATE</code> 的字段拼接。</li></ul><h3 id="4-lt-foreach-gt-—-列表（IN）与批量插入"><a href="#4-lt-foreach-gt-—-列表（IN）与批量插入" class="headerlink" title="4. <foreach> — 列表（IN）与批量插入"></a>4. <code>&lt;foreach&gt;</code> — 列表（IN）与批量插入</h3><ul><li>用于 <code>IN</code> 子句：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getByIds"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.domain.User"</span>&gt;</span><br>  SELECT id, Name, age FROM test_table1<br>  WHERE id IN<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span>&gt;</span><br>    #{id}<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>用于批量插入（配合事务）：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"batchInsert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"list"</span>&gt;</span><br>  INSERT INTO test_table1 (Name, age)<br>  VALUES<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span>&gt;</span><br>    (#{user.name}, #{user.age})<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>使用批量插入时，注意数据库与驱动的批量性能，必要时启用 JDBC 批处理或分批提交以避免内存过大。</li></ul><hr><h1 id="性能-x2F-安全"><a href="#性能-x2F-安全" class="headerlink" title="性能 / 安全"></a>性能 / 安全</h1><h3 id="1-使用-避免-SQL-注入（不要用-）"><a href="#1-使用-避免-SQL-注入（不要用-）" class="headerlink" title="1. 使用 #{} 避免 SQL 注入（不要用 ${}）"></a>1. 使用 <code>#{}</code> 避免 SQL 注入（不要用 <code>${}</code>）</h3><ul><li><p><code>#{}</code>：使用预编译参数，自动进行类型处理与转义，它会将用户输入的数据以字符串的形式而不是sql命令输入控制台，能有效防止 SQL 注入。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">WHERE Name = #{name}<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>${}</code>：直接字符串替换（危险），仅在必须动态拼接 SQL 片段（如表名、列名）且确保来源受控时使用。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 不要这样处理用户输入 --&gt;</span><br>WHERE Name = '${name}'<br></code></pre></td></tr></tbody></table></figure></li><li><p>总结：对用户输入的值一律用 <code>#{}</code>；只有在拼接 SQL 语法（表名、排序字段等）且已校验白名单时再考虑 <code>${}</code>。</p></li></ul><h3 id="2-批量插入与性能"><a href="#2-批量插入与性能" class="headerlink" title="2. 批量插入与性能"></a>2. 批量插入与性能</h3><ul><li>对大量数据的插入，使用 <code>&lt;foreach&gt;</code> 批量插入比逐条插入更高效；也可以结合 JDBC 批处理（<code>ExecutorType.BATCH</code>）或分批次提交（例如每 500 条 commit 一次）。</li><li>注意：一次性插入过多记录可能导致单条 SQL 较大或内存问题，建议分批。</li></ul><h3 id="3-索引与-SQL-优化（建议）"><a href="#3-索引与-SQL-优化（建议）" class="headerlink" title="3. 索引与 SQL 优化（建议）"></a>3. 索引与 SQL 优化（建议）</h3><ul><li>为常用的 <code>WHERE</code>/<code>ORDER BY</code> 字段建立索引；对慢查询使用 <code>EXPLAIN</code> 分析。</li><li>避免 SELECT *（按需列出），减少传输与解析开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/posts/Lombok/"/>
    <url>/posts/Lombok/</url>
    
    <content type="html"><![CDATA[<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>Lombok是一个Java库，旨在通过注解的方式在编译期间自动生成getter、setter、equals、hashCode、toString等方法。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 替换为下载的Lombok版本 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Maven项目直接引入依赖即可。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>Java体现的是一切皆为对象的思想，好比说我们定义了一个用户类，这个类有名字，密码，年龄，性别等信息，那么如果我们需要操作这个类的实例化对象，因为他不是最基本的数据类型，也不是JAVA自己已经定义的数据结构，所以我们就必须重写他的getter(获取)、setter(设置)、equals(判断等同)、hashCode(判断逻辑等同)、toString(字符串形式表述)等方法，才能方便地使用它，但是随着工程量上升，这一部分往往是枯燥且麻烦的工作，所以Lombok被设计出来能够帮我们完成这个任务。</p><p>Lombok不会直接修改项目的源代码，他会在 <strong>Java 编译过程中</strong> 默默工作的“代码助手”。它并非在运行时通过反射等机制动态生成代码，而是直接在源代码编译为字节码的阶段，通过修改编译器的 <strong>抽象语法树（AST）</strong> 来“添加”代码，最终生成的 <code>.class</code>文件就已经包含了所有完整的方法。</p><h2 id="Lombok常见注解方法"><a href="#Lombok常见注解方法" class="headerlink" title="Lombok常见注解方法"></a>Lombok常见注解方法</h2><ol><li>@Getter 和 @Setter：<br>自动生成属性的getter和setter方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Getter;<br><span class="hljs-keyword">import</span> lombok.Setter;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Setter</span> <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Setter</span> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>@NoArgsConstructor：<br>自动生成无参构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br> <br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>@AllArgsConstructor：<br>自动生成全参构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br> <br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>@RequiredArgsConstructor：<br>自动生成包含final属性和@NonNull属性的构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.NonNull;<br> <br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>@ToString：<br>自动生成toString方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.ToString;<br> <br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="6"><li>@EqualsAndHashCode：<br>自动生成equals和hashCode方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;<br> <br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="7"><li>@Data：<br>组合了@Getter、@Setter、@ToString、@EqualsAndHashCode和@RequiredArgsConstructor的功能。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br> <br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="8"><li>@Slf4j：<br>自动生成名为log的日志记录器字段。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br> <br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> {<br>        log.info(<span class="hljs-string">"Logging something..."</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/posts/Mysql/"/>
    <url>/posts/Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>在网络开发中，大量的用户数据必须存储在<code>网页后端</code>，为此，数据库为我们提供了支持。数据库类似于Excel表格，允许我们以高度结构化的形式存储用户数据并能够与程序产生交互。</p><p>数据库分为<strong>关系型数据库</strong>和<strong>非关系型数据库</strong>，关系型数据库是基于关系模型来存储和管理数据的数据库系统。关系就是基于表格的数据模型，它使用行和列来表示数据，并通过主键和外键来定义表之间的关系。而非关系型数据库则不强制要求使用关系模型来存储数据，这一点是倒是更灵活。</p><p>目前主流的关系型数据库有：<code>Mysql</code>，<code>Sql Server</code>，<code>Oracle</code>，<code>DB2</code>，<code>DM达梦</code>。</p><p>我们以最广泛的开源数据库<code>Mysql</code>展开讨论。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>安装过程中需要设置用户，建议设置一个管理员用户和一个普通用户，我个人习惯是管理员用户名和密码都是root，期间安装程序会提醒你输入原有已经输入的密码，安装过程才能继续。</p><p>完成后，我们就能够通过命令行来使用数据库，但这很麻烦，毕竟在计算机性能发达的今天，图形化才是趋势。</p><h2 id="DBeaver"><a href="#DBeaver" class="headerlink" title="DBeaver"></a>DBeaver</h2><p>下载地址：<a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a></p><p>安装过程略过</p><p>安装完成后创建连接：</p><p><img src="https://s2.loli.net/2025/10/22/L59GUItEfFzHSOm.webp" alt="image"></p><p>然后你就能在DBeaver中操作数据库的表了。</p><p>但是，这一类可视化图形工具起到的作用只是简化操作，帮我们输入并执行SQL语句而已，作为开发人员我们需要具备使用命令行实现增删改查的能力。</p><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>SQL语句不是像java一样的命令式编程语言，而是<strong>声明式编程语言</strong>，就和开源项目的命令行使用方法类似。</p><p>这一部分不会比我们之前学习的java难，放松。</p><p>SQL语句适用于大多数关系型数据库，是统一操作语言，但某些关系型数据库在语法解析上可能有细微差别，你可以理解成编译器不同导致的输出不同。SQL语句和根据数据库不同特征化的语句可以理解为是普通话和方言一样。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><ul><li>数据库 (Database)</li></ul><p>一个存储数据的仓库，可以包含多个表，用于组织和管理大量结构化数据。</p><ul><li>表 (Table)</li></ul><p>数据库中的一种数据结构，由行和列组成，用于存储特定类型的数据（如用户表、订单表）。</p><ul><li>列名 (Column Name)</li></ul><p>表中的每一列都有一个名称，用于标识该列存储的数据（如 username、age）。</p><ul><li>数据类型 (Data Type)</li></ul><p>定义列中数据的类型，如整数 (INT)、字符串 (VARCHAR)、日期 (DATE) 等。</p><ul><li>自增 (Auto Increment)</li></ul><p>一种属性，通常用于主键列，每次插入新数据时自动递增（如 1, 2, 3…）。</p><ul><li>非空 (NOT NULL)</li></ul><p>一种约束，确保列中不能存储空值（必须填写数据）。</p><ul><li>唯一 (UNIQUE)</li></ul><p>一种约束，确保列中的值不能重复（但允许空值）。</p><ul><li>主键 (Primary Key)</li></ul><p>一种唯一且非空的列（或列组合），用于唯一标识表中的每一行。</p><ul><li>外键 (Foreign Key)</li></ul><p>一种列，用于关联另一张表的主键，确保数据的一致性和完整性。</p><ul><li>默认值 (Default Value)</li></ul><p>如果插入数据时未指定值，列将自动填充的预设值（如 DEFAULT 0）。</p><ul><li>注释 (Comment)</li></ul><p>对表、列或索引的说明，用于帮助理解其用途（如 COMMENT ‘用户姓名’）。</p><ul><li>索引 (Index)</li></ul><p>一种数据结构，用于加快数据检索速度（类似于书的目录），但会增加写入数据的开销。</p><p><strong>总结一下，数据库包含表，表又包含列和行，其中列起到锚定作用，自增，唯一，主键，外键，都是列的属性或者类型，行起到保存数据作用，行和列围成的格子中存放的原子数据又包含了不同的数据类型。</strong></p><h3 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a><strong>SQL的分类</strong></h3><ol><li><strong>DDL（Data Definition Language，数据定义语言）</strong>：用于创建、修改和删除数据库中的各种对象，如表、索引、视图、触发器等。常见的DDL命令包括CREATE（创建）、ALTER（修改）和DROP（删除）。例如，CREATE TABLE用于创建新的数据库表，ALTER TABLE用于修改表的结构，DROP TABLE则用于删除表。</li><li><strong>DML（Data Manipulation Language，数据操纵语言）</strong>：允许用户对数据库中的数据进行基本操作，如插入、更新、删除和查询数据记录。常见的DML命令有INSERT（插入）、UPDATE（更新）、DELETE（删除）和SELECT（查询）。其中，SELECT是SQL语言的基础，用于从数据库中检索数据。</li><li><strong>DQL（Data Query Language，数据查询语言）</strong>：主要用于从数据库中检索数据，其核心指令是SELECT。DQL是DML的一个子集，专注于数据查询操作。</li><li><strong>DCL（Data Control Language，数据控制语言）</strong>：用于控制数据库用户访问权限和安全性的语言。DCL包括授予和撤销用户权限的命令，以及管理数据库对象的权限。常见的DCL命令有GRANT（授予）和REVOKE（撤销）。通过DCL，数据库管理员可以设定哪些用户有权访问哪些数据库对象，以及他们可以进行哪些操作。</li><li><strong>TCL（Transaction Control Language，事务控制语言）</strong>：用于管理事务的语言，包括开始事务、提交事务、回滚事务等命令。常见的TCL命令有BEGIN（开始事务）、COMMIT（提交事务）和ROLLBACK（回滚事务）。TCL在快速原型开发、脚本编程、GUI和测试等方面非常有用，它允许将一系列操作组合为一个逻辑事务，从而确保数据的完整性和一致性。</li></ol><h1 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h1><h3 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> DateBase [数据库名]；<br></code></pre></td></tr></tbody></table></figure><p>例如：创建名为<code>willmo</code>的数据库</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> datebase willmo;<br></code></pre></td></tr></tbody></table></figure><p>SQL语句对关键字大小写不敏感，但是对名称等标识敏感。</p><p>其他的参考java的编程语言书写规范就可以了。</p><p>你可以在图形化软件操作后查看操作对应的sql语句,例如在创建表的同时新建列，并列出列的属性：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (<br>    列名<span class="hljs-number">1</span> 数据类型 [约束条件],<br>    列名<span class="hljs-number">2</span> 数据类型 [约束条件],<br>    ...<br>    [表级约束]<br>);<br></code></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> willmo.test (           <span class="hljs-comment">--这里是全限定表名，提及了数据库名willmo，如果选中了数据库就不用提及数据库名，这和绝对路径和相对路径是一个道理。</span><br>  id <span class="hljs-type">INT</span> auto_increment <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'id'</span>,  <span class="hljs-comment">--列名为id,属性是自增非空，数据类型是INT整型</span><br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'姓名'</span>,<span class="hljs-comment">--列名为name,属性是非空，别名为“姓名”，数据类型字符串</span><br>  <span class="hljs-keyword">CONSTRAINT</span> test_pk <span class="hljs-keyword">PRIMARY</span> KEY (id     <span class="hljs-comment">--设置id为主键，也就是起唯一标识作用的列</span><br>)<br>ENGINE<span class="hljs-operator">=</span>InnoDB                            <span class="hljs-comment">--指定引擎</span><br><span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;                 <span class="hljs-comment">--指定字符集，utf8mb4相较于utf8他能够存储表情</span><br></code></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在MySQL中，为列选择合适的数据类型至关重要，因为它直接影响到数据的存储效率、查询性能以及数据的完整性。以下是根据数据类型和用途给出的一些推荐：</p><h6 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h6><ol><li><strong>整数类型</strong></li></ol><ul><li><strong>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</strong>：根据数值的范围选择合适的大小。例如，如果确定数值不会超过255，那么使用TINYINT可以节省存储空间。</li><li><strong>UNSIGNED</strong>：如果数值不需要负数，使用UNSIGNED属性可以将正数的范围扩大一倍。</li><li><strong>AUTO_INCREMENT</strong>：如果需要自动生成唯一的标识符，可以在主键列上使用AUTO_INCREMENT属性。</li></ul><ol><li><strong>浮点数类型</strong></li></ol><ul><li><strong>FLOAT、DOUBLE</strong>：用于存储近似数值。FLOAT占用4个字节，DOUBLE占用8个字节。如果需要更高的精度，可以选择DOUBLE。</li><li><strong>DECIMAL</strong>：用于存储精确数值，如金融计算。DECIMAL类型可以指定小数点前后的位数，如DECIMAL(10,2)表示总共10位数字，其中小数点后有2位。</li></ul><h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6><ol><li><strong>CHAR</strong></li></ol><ul><li>用于存储固定长度的字符串。如果字符串长度几乎相同，或者长度很短且变更不频繁，CHAR是更好的选择。</li><li>CHAR类型会删除字符串末尾的空格，并根据需要填充空格以方便比较。</li></ul><ol><li><strong>VARCHAR</strong></li></ol><ul><li>用于存储可变长度的字符串。VARCHAR类型仅使用必要的空间，因此比CHAR更节省空间。</li><li>当字符串列的最大长度远大于平均长度时，或者字符串经常更新时，VARCHAR是更好的选择。</li></ul><ol><li><strong>TEXT类型</strong></li></ol><ul><li>用于存储大文本数据。TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT分别可以存储不同大小的数据。</li><li>如果需要存储非常大的文本数据，可以选择LONGTEXT。</li></ul><h6 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h6><ol><li><strong>DATE</strong>：用于存储日期值，格式为YYYY-MM-DD。</li><li><strong>TIME</strong>：用于存储时间值，格式为HH:MM:SS。</li><li><strong>DATETIME</strong>：用于存储日期和时间值，格式为YYYY-MM-DD HH:MM:SS。</li><li><strong>TIMESTAMP</strong>：用于存储UNIX时间戳，表示从1970年1月1日以来的秒数。TIMESTAMP值依赖于时区设置。</li></ol><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询我们使用这个格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,... <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></tbody></table></figure><p>当然你也可以使用通配符<code>*</code>，虽然这么做可能引发性能问题。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></tbody></table></figure><p>使用<code>select</code>能够找出相应列，但是我们需要使用<code>where</code>来实现条件查询</p><p>比如：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">5000</span>;     <span class="hljs-comment">--找出5000块工资以上的职员</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> category <span class="hljs-operator">=</span> <span class="hljs-string">'Electronics'</span>    <span class="hljs-comment">--找出电子类和1000块以下的产品</span><br><span class="hljs-keyword">AND</span> price <span class="hljs-operator">&lt;</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></tbody></table></figure><p>查询条件：</p><ul><li><code>=</code>, <code>&lt;&gt;</code>/<code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li><li>BETWEEN … AND …<ul><li>意思是查找区间范围的数据，如找12-19的数据可以是<code>select number from  num Between 12 and 19</code></li></ul></li><li>LIKE（配合%和_使用）<ul><li>LIKE是模糊查询，如果你想找张某某，你可以查询<code>select name from user LIKE "张%";</code></li></ul></li><li>IN (值列表)，比如<code>IN 12,13,15,16</code>;</li></ul><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 按工资降序排列</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 获取前10条记录（不同数据库语法可能不同）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br>LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></tbody></table></figure><p><code>asc</code>是顺序排序，<code>desc</code>是逆向排序。</p><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total_employees,   <span class="hljs-comment">--输出全体职员的数量</span><br>      <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-keyword">AS</span> sum_salary,   <span class="hljs-comment">--求薪水之和</span><br>    <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> average_salary, <span class="hljs-comment">--使用关键字计算平均薪水</span><br>    <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> max_salary,<br>    <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">AS</span> min_salary<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></tbody></table></figure><p>你可以使用<code>having</code>语句和<code>group by </code>语句来实现对某一群体进行聚合查询和计算</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">6000</span>;   <span class="hljs-comment">--计算所以6000薪资以上的职员的平均工资</span><br></code></pre></td></tr></tbody></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>你一定能够注意到，查询的结果返回的也是一个表，那么我们就能够对返回表再做一次查询。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> price <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(price) <span class="hljs-keyword">FROM</span> products);    <span class="hljs-comment">--查询出高于产品平均价的那一批产品</span><br></code></pre></td></tr></tbody></table></figure><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p>使用<code>INSERT</code>关键字来实现</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ..., 字段N)<br><span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ..., 值N);<br></code></pre></td></tr></tbody></table></figure><p>如果你向插入一行完整的数据，就可以省略字段</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ..., 值N);   <span class="hljs-comment">--确保只有N列</span><br></code></pre></td></tr></tbody></table></figure><p>你也可以批量新增</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ..., 字段N)<br><span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>_1, 值<span class="hljs-number">1</span>_2, ..., 值<span class="hljs-number">1</span>_N),<br>    (值<span class="hljs-number">2</span>_1, 值<span class="hljs-number">2</span>_2, ..., 值<span class="hljs-number">2</span>_N),<br>    ...,<br>    (值M_1, 值M_2, ..., 值M_N);<br></code></pre></td></tr></tbody></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名<br><span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 新值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 新值<span class="hljs-number">2</span>, ...<br><span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></tbody></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：where条件查询关键字的缺失不会引发编译错误，但是增加删除修改等破坏性操作如果没有where关键字那操作对象就是整个表格，很可能会对全表格造成增删改的不可逆破坏。</strong></p><h3 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h3><h5 id="第一范式（1NF-First-Normal-Form）"><a href="#第一范式（1NF-First-Normal-Form）" class="headerlink" title="第一范式（1NF, First Normal Form）"></a>第一范式（1NF, First Normal Form）</h5><p><strong>简单来说</strong>： 每个字段只存储一项信息，每一列都是原子的，不可再分。</p><p><strong>例子</strong>： 假设有一个记录学生信息的表格，如果有一个字段叫做“个人信息”，里面包含了姓名、年龄和性别等多个信息，这就违反了第一范式。正确的做法是将“个人信息”这个字段拆分成姓名、年龄、性别等多个字段，每个字段只存储一项信息。</p><h5 id="第二范式（2NF-Second-Normal-Form）"><a href="#第二范式（2NF-Second-Normal-Form）" class="headerlink" title="第二范式（2NF, Second Normal Form）"></a>第二范式（2NF, Second Normal Form）</h5><p><strong>简单来说</strong>： 在满足第一范式的基础上，要求表格中的每一非主键字段都完全依赖于主键字段，而不能依赖于主键的一部分或是其他非主键字段。</p><h6 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h6><table><thead><tr><th><strong>学生ID</strong></th><th><strong>课程ID</strong></th><th><strong>课程名称</strong></th><th><strong>授课教师</strong></th><th><strong>学分</strong></th></tr></thead><tbody><tr><td>S001</td><td>C01</td><td>数学</td><td>王老师</td><td>3</td></tr><tr><td>S001</td><td>C02</td><td>英语</td><td>李老师</td><td>2</td></tr><tr><td>S002</td><td>C01</td><td>数学</td><td>王老师</td><td>3</td></tr></tbody></table><ul><li><strong>主键</strong>：<code>(学生ID, 课程ID)</code>（复合主键）</li><li><strong>问题</strong>：</li><li><code>课程名称</code> 和 <code>授课教师</code> 仅依赖于 <code>课程ID</code>（主键的一部分），而非完整主键。</li><li><code>学分</code> 也仅依赖于 <code>课程ID</code>。</li><li><strong>结论</strong>：存在非主属性对主键的<strong>部分依赖</strong>，满足1NF（所有列原子），但不满足2NF。</li></ul><h5 id="第三范式（3NF-Third-Normal-Form）"><a href="#第三范式（3NF-Third-Normal-Form）" class="headerlink" title="第三范式（3NF, Third Normal Form）"></a>第三范式（3NF, Third Normal Form）</h5><p><strong>简单来说</strong>： 在满足第二范式的基础上，要求表格中的每一非主键字段都直接依赖于主键字段，而不能通过其他非主键字段间接依赖于主键字段。换句话说，非主键字段之间不能有传递依赖关系。</p><p><strong>例子</strong>：</p><table><thead><tr><th><strong>学生ID</strong></th><th><strong>姓名</strong></th><th><strong>年龄</strong></th><th><strong>所在学院</strong></th><th><strong>学院电话</strong></th></tr></thead><tbody><tr><td>S001</td><td>张三</td><td>20</td><td>计算机学院</td><td>021-1234</td></tr><tr><td>S002</td><td>李四</td><td>21</td><td>经济管理学院</td><td>021-5678</td></tr></tbody></table><ul><li><strong>主键</strong>：<code>学生ID</code></li><li><strong>问题</strong>：</li><li><code>学院电话</code> 依赖于 <code>所在学院</code>，而 <code>所在学院</code> 又依赖于 <code>学生ID</code>。</li><li>存在非主属性 <code>学院电话</code> 对主键的<strong>传递依赖</strong>。</li><li><strong>结论</strong>：满足2NF（无部分依赖），但不满足3NF（存在传递依赖）。</li></ul><h5 id="反范式化（Denormalization）"><a href="#反范式化（Denormalization）" class="headerlink" title="反范式化（Denormalization）"></a><strong>反范式化（Denormalization）</strong></h5><p>话虽如此，但是在实际业务中，尤其是对查询性能要求很高的场景（如大数据分析、报表系统），<strong>有时会故意违反更高的范式，允许一定的数据冗余，这就是反范式化</strong>。这是因为范化（规范化）在减少冗余的同时，也增加了表的数量，复杂的查询可能需要关联多张表，从而<strong>降低查询速度</strong>。因此，数据库设计往往是在<strong>数据冗余</strong>和<strong>查询性能</strong>之间做出权衡。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>外键起到链接两个表的作用，简单来说，就是一个数据库表中的字段，它指向另一个表的主键。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 子表名 (<br>    子表字段<span class="hljs-number">1</span> 数据类型 约束条件,<br>    子表字段<span class="hljs-number">2</span> 数据类型 约束条件,<br>    ...<br>    外键字段 数据类型,<br>    ...<br>    <span class="hljs-keyword">CONSTRAINT</span> 外键约束名 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表主键字段)<br>    [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>]<br>    [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>]<br>);<br></code></pre></td></tr></tbody></table></figure><p>如果表已经存在</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 子表名<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键约束名 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表主键字段)<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span>];<br></code></pre></td></tr></tbody></table></figure><h4 id="关于外键的补充"><a href="#关于外键的补充" class="headerlink" title="关于外键的补充"></a>关于外键的补充</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>数据完整性：</li></ol><ul><li>外键约束确保了子表中的外键值必须存在于父表对应的主键或唯一键中，从而避免了孤立记录的出现，维护了数据的引用完整性。</li></ul><ol start="2"><li>级联操作：</li></ol><ul><li>外键可以配置为自动处理相关表中的数据更新或删除操作，如级联更新和级联删除。这有助于保持数据的一致性，并减少了手动维护数据关系的复杂性。</li></ul><ol start="3"><li>减少应用程序代码复杂度：</li></ol><ul><li>通过数据库层面的约束来管理数据关系，可以减轻应用程序开发人员在业务逻辑中实现这些规则的负担，使代码更加简洁和易于维护。</li></ul><ol start="4"><li>提高数据质量：</li></ol><ul><li>自动化的检查和维护有助于保持数据的准确性和一致性，减少了人为错误的可能性。</li></ul><ol start="5"><li>索引支持：</li></ol><ul><li>通常情况下，外键会被自动创建索引，这不仅加速了对关联数据的查找，也提高了连接查询（JOIN）的效率。</li></ul><ol start="6"><li>查询优化器辅助：</li></ol><ul><li>外键信息可以帮助数据库查询优化器更好地理解表间的关系，从而生成更高效的执行计划。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>性能开销：</li></ol><ul><li>外键约束会增加数据库的维护成本。每次插入、更新或删除涉及外键的记录时，数据库都需要检查外键约束是否得到满足，这可能会导致额外的性能开销。在高并发或大数据量的系统中，这种性能开销可能更加明显。</li></ul><ol start="2"><li>级联操作风险：</li></ol><ul><li>虽然级联操作有助于保持数据的一致性，但在某些情况下，它可能不是期望的行为。例如，删除一个记录可能会意外地删除与之相关的多个记录，导致数据丢失。</li></ul><ol start="3"><li>增加数据库复杂性：</li></ol><ul><li>使用外键会增加数据库的复杂性，使得数据库结构更难理解和维护。特别是在大型系统中，多个表之间的复杂关系可能导致混淆和错误。</li></ul><ol start="4"><li>依赖性问题：</li></ol><ul><li>外键创建了一种依赖性，即一个表中的数据依赖于另一个表中的数据。这种依赖性可能导致数据迁移或重构时的困难。</li></ul><ol start="5"><li>死锁风险：</li></ol><ul><li>在高并发环境中，外键可能导致死锁问题。当多个事务试图同时更新涉及外键的数据时，可能会出现死锁，导致系统性能下降。</li></ul><ol start="6"><li>灵活性限制：</li></ol><ul><li>使用外键可能会限制数据库结构的灵活性。例如，在分区或分表操作时，外键可能会成为一种约束，限制数据库设计的变化。</li></ul><h2 id="多表查询-x2F-连接查询"><a href="#多表查询-x2F-连接查询" class="headerlink" title="多表查询/连接查询"></a>多表查询/连接查询</h2><p>多表查询允许你一次在多张表中查询</p><h4 id="常见的连接"><a href="#常见的连接" class="headerlink" title="常见的连接"></a>常见的连接</h4><table><thead><tr><th>连接类型</th><th>关键词</th><th>数据保留方向</th><th>未匹配数据处理</th><th>SQL示例</th></tr></thead><tbody><tr><td>内连接</td><td>INNER JOIN</td><td>仅保留两个表中匹配的行</td><td>丢弃不匹配的行</td><td><code>SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;</code></td></tr><tr><td>左外连接</td><td>LEFT JOIN</td><td>保留左表所有行及与右表匹配的行</td><td>右表未匹配部分填充NULL</td><td><code>SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;</code></td></tr><tr><td>右外连接</td><td>RIGHT JOIN</td><td>保留右表所有行及与左表匹配的行</td><td>左表未匹配部分填充NULL</td><td><code>SELECT * FROM table1 RIGHT JOIN table2 ON table1.id = table2.id;</code></td></tr><tr><td>全外连接</td><td>FULL JOIN</td><td>保留左表和右表中的所有行</td><td>未匹配部分在相应侧填充NULL</td><td><code>SELECT * FROM table1 FULL JOIN table2 ON table1.id = table2.id;</code>（注意：不是所有数据库都支持FULL JOIN，有些数据库使用UNION ALL结合LEFT JOIN和RIGHT JOIN来实现类似功能）</td></tr><tr><td>交叉连接（笛卡尔积）</td><td>CROSS JOIN</td><td>生成两个表中所有行的组合（笛卡尔积）</td><td>无特殊处理（所有组合均保留）</td><td><code>SELECT * FROM table1 CROSS JOIN table2;</code> 或简单地 <code>SELECT * FROM table1, table2;</code></td></tr></tbody></table><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>SQL是操作语言，而操作必须是原子化的，事务的作用就是保证原子化。事务是一系列数据库操作的集合，这些操作被视为一个单一的工作单元。事务中的操作要么全部执行成功，要么在遇到错误时全部撤销。</p><p>事务具有四个关键特性，通常称为ACID特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。事务在执行过程中发生错误，则会回滚到事务开始前的状态。</li><li><strong>一致性（Consistency）</strong>：事务执行前后，数据库都必须处于一致性状态。这意味着事务执行的结果必须是有效的，符合所有定义的规则、约束和触发器。</li><li><strong>隔离性（Isolation）</strong>：并发执行的事务之间不会互相干扰。一个事务内部的操作对其他并发事务是不可见的，直到该事务提交。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，它对数据库的影响是永久的，即使系统崩溃也不会丢失。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat</title>
    <link href="/posts/Tomcat/"/>
    <url>/posts/Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><blockquote><p>Tomcat 是一个 Java Servlet 容器（应用服务器），用于运行 Java web 应用（Servlet / JSP / WAR）。<br>Nginx 不是 Servlet 容器——它不能直接运行 Java servlet，但常用于静态文件、反向代理、负载均衡和 TLS 终端，通常会把请求转发到 Tomcat 或其他应用服务器。</p></blockquote><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><ul><li>官方下载地址：<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></li><li>解压（或安装）后进入 Tomcat 根目录。Windows 下启动脚本位于 <code>bin\startup.bat</code>（或 <code>catalina.bat</code>），Linux/macOS 下为 <code>bin/startup.sh</code>（或 <code>catalina.sh</code>）。生产环境通常使用 systemd 服务或进程管理器来启动和守护 Tomcat（不要直接在生产机上双击脚本）。</li><li><strong>环境变量</strong>：确保系统已安装合适版本的 Java 并设置 <code>JAVA_HOME</code>（以及可选的 <code>CATALINA_HOME</code> / <code>CATALINA_BASE</code>）。在选择 Tomcat 版本前，请先确认该 Tomcat 对应的 JDK/Java 要求（参见 Tomcat 官方的<a href="https://tomcat.apache.org/whichversion.html">“Which version”</a> 页面）。</li></ul><h2 id="本地截图"><a href="#本地截图" class="headerlink" title="本地截图"></a>本地截图</h2><p><img src="https://s2.loli.net/2025/10/20/jYHJGyDdqS2VOWC.png" alt="image-20251020115944381"></p><p><img src="https://s2.loli.net/2025/10/20/ea9sMRmXqfAL3iT.png" alt="image-20251020115936464"></p><h2 id="关于-Java-EE-x2F-Jakarta-EE（简明）"><a href="#关于-Java-EE-x2F-Jakarta-EE（简明）" class="headerlink" title="关于 Java EE / Jakarta EE（简明）"></a>关于 Java EE / Jakarta EE（简明）</h2><ol><li><strong>背景</strong>：Oracle 在 2017 年把 Java EE 移交给 Eclipse Foundation，随后更名为 Jakarta EE。:contentReference[oaicite:4]{index=4}</li><li><strong>包名变化</strong>：从 Jakarta EE 9 开始，标准 API 的包名由 <code>javax.*</code> 迁移为 <code>jakarta.*</code>。这会导致依赖旧 <code>javax.*</code> 的应用在 Tomcat 10（及更高、基于 Jakarta API 的容器）上无法直接运行，除非进行迁移或使用兼容工具。:contentReference[oaicite:5]{index=5}</li><li><strong>实务建议</strong>：<ul><li>如果你的项目还使用 <code>javax.*</code>（很多老项目/第三方库如此），可以继续使用 Tomcat 9.x（兼容 javax）直到完成迁移；</li><li>或者使用 <strong>Apache Tomcat 的迁移工具</strong>（migration tool for Jakarta EE）将已有的 WAR/binaries 从 <code>javax</code> 转为 <code>jakarta</code>；也可以在源码层面升级依赖并重新编译。:contentReference[oaicite:6]{index=6}</li></ul></li></ol><h2 id="部署（常用方法）"><a href="#部署（常用方法）" class="headerlink" title="部署（常用方法）"></a>部署（常用方法）</h2><ul><li><strong>直接部署 WAR</strong>：把 <code>yourapp.war</code> 拷贝到 Tomcat 的 <code>webapps/</code> 目录，Tomcat 会自动展开并部署（默认）。这是最简单的本地部署方式。:contentReference[oaicite:7]{index=7}</li><li><strong>使用 Manager</strong>：通过 Tomcat Manager 可以网页方式或 HTTP 接口部署、卸载应用；需要在 <code>conf/tomcat-users.xml</code> 为管理用户配置 <code>manager-gui</code> / <code>manager-script</code> 等角色。开发/测试环境常用此方式。:contentReference[oaicite:8]{index=8}</li><li><strong>其它方式</strong>：还可以使用 CI/CD 工具、远程部署脚本或 Tomcat Deployer 客户端等流程化部署方式（适合生产）。:contentReference[oaicite:9]{index=9}</li></ul><h2 id="常见配置与注意事项"><a href="#常见配置与注意事项" class="headerlink" title="常见配置与注意事项"></a>常见配置与注意事项</h2><ul><li><strong>默认端口</strong>：<code>8080</code>（在 <code>conf/server.xml</code> 中可修改）。</li><li><strong>安全建议</strong>：不要直接把 Tomcat 端口暴露在公网；在生产环境常见做法是把 Nginx 放在前面做反向代理、TLS 终端和静态资源处理，Tomcat 只监听内网访问。</li><li><strong>JDK 版本</strong>：务必根据你选的 Tomcat 版本检查所需的 Java 版本（64-bit），并使用受支持的 JDK。官方“Which version”页面有对应表格。</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  Licensed to the Apache Software Foundation (ASF)...</span><br><span class="hljs-comment">  （原始许可证头略）</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 顶层 Server 元素：代表 Tomcat 实例级别的配置（不是容器本身）</span><br><span class="hljs-comment">     主要属性：</span><br><span class="hljs-comment">       port: 用于监听关闭命令的端口。默认通常是 8005。设置为 -1 则禁用通过端口关闭（更安全）。</span><br><span class="hljs-comment">       shutdown: 发送到 port 的字符串命令，若匹配则触发正常关闭。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"-1"</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">"SHUTDOWN"</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 下面是若干 Listener（监听器），在 Tomcat 启动/关闭过程中执行初始化或清理工作 --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 记录版本信息（启动时打印 Tomcat/组件版本）--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 可选的安全监听器（已注释），用于增强安全相关初始化 --&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  &lt;Listener className="org.apache.catalina.security.SecurityListener" /&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- APR（Tomcat Native / OpenSSL）生命周期监听器，</span><br><span class="hljs-comment">       当安装了 Tomcat Native / APR 时可以使用以提升性能/SSL 支持。</span><br><span class="hljs-comment">       注意：需要额外本地库，非必须。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.AprLifecycleListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- OpenSSL 的替代（基于 Java 22 的 FFM API）示例（被注释）。</span><br><span class="hljs-comment">       如果启用，和 AprLifecycleListener 的作用类似：提供 OpenSSL 支持。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;Listener className="org.apache.catalina.core.OpenSSLLifecycleListener" /&gt; --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 防止常见的 JRE/JEE API 导致的内存泄漏（如 JDBC 驱动、线程本地变量等） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 管理全局 JNDI 资源的生命周期（例如全局 DataSource、UserDatabase） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 预防 ThreadLocal 导致的泄漏（在某些类库使用 ThreadLocal 时有帮助） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 全局 JNDI 资源（GlobalNamingResources）</span><br><span class="hljs-comment">       在这里定义的资源可以被 webapp 或 Realm 等通过 JNDI 引用。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- UserDatabase：内存可编辑的用户数据库资源示例</span><br><span class="hljs-comment">         属性说明：</span><br><span class="hljs-comment">           name: JNDI 名称（引用该资源时使用的名字）</span><br><span class="hljs-comment">           auth: Container / Application（谁来管理认证）</span><br><span class="hljs-comment">           type: Java 类型（接口/类）</span><br><span class="hljs-comment">           description: 描述</span><br><span class="hljs-comment">           factory: 生产该资源实例的工厂类</span><br><span class="hljs-comment">           pathname: 资源的数据文件路径，这里指向 conf/tomcat-users.xml（保存用户和角色）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"UserDatabase"</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">type</span>=<span class="hljs-string">"org.apache.catalina.UserDatabase"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">description</span>=<span class="hljs-string">"User database that can be updated and saved"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">factory</span>=<span class="hljs-string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">pathname</span>=<span class="hljs-string">"conf/tomcat-users.xml"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">GlobalNamingResources</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Service：一个 Service 下可以包含多个 Connector（端点），共享同一个 Engine（容器）</span><br><span class="hljs-comment">       name: 服务名（任意，例如 "Catalina"）</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Executor：可选的线程池定义（被注释）。</span><br><span class="hljs-comment">         定义后多个 Connector 可以复用同一个线程池（通过 executor 属性）。</span><br><span class="hljs-comment">         属性示例：</span><br><span class="hljs-comment">           name: 线程池名字</span><br><span class="hljs-comment">           namePrefix: 线程名前缀</span><br><span class="hljs-comment">           maxThreads: 最大线程数</span><br><span class="hljs-comment">           minSpareThreads: 最少空闲线程</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"</span><br><span class="hljs-comment">        maxThreads="150" minSpareThreads="4"/&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Connector：表示接受请求的网络端点（HTTP、AJP 等）</span><br><span class="hljs-comment">         常见属性：</span><br><span class="hljs-comment">           port: 监听端口（例如 8080）</span><br><span class="hljs-comment">           protocol: 协议实现（HTTP/1.1、AJP/1.3 或特定的 Http11NioProtocol 等）</span><br><span class="hljs-comment">           connectionTimeout: 毫秒为单位，连接空闲或等待时间</span><br><span class="hljs-comment">           redirectPort: 当需要 SSL 时重定向到的端口（通常 8443）</span><br><span class="hljs-comment">           executor: 指向上面定义的线程池名字（如果使用共享线程池）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 如果使用共享线程池 (Executor)，Connector 可以写成下面这种形式（示例被注释） --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Connector executor="tomcatThreadPool"</span><br><span class="hljs-comment">               port="8080" protocol="HTTP/1.1"</span><br><span class="hljs-comment">               connectionTimeout="20000"</span><br><span class="hljs-comment">               redirectPort="8443" /&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- SSL/TLS Connector 示例（注释掉），展示如何配置 HTTPS（8443）和 HTTP/2</span><br><span class="hljs-comment">         重要点：</span><br><span class="hljs-comment">           SSLEnabled="true" 开启 SSL</span><br><span class="hljs-comment">           使用 &lt;SSLHostConfig&gt; 和 &lt;Certificate&gt; 指定 keystore 或证书信息</span><br><span class="hljs-comment">           可以选用不同的协议实现（NIO、APR 等）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"</span><br><span class="hljs-comment">               maxThreads="150" SSLEnabled="true"&gt;</span><br><span class="hljs-comment">        &lt;!-- 启用 HTTP/2 协议支持 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">UpgradeProtocol</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.coyote.http2.Http2Protocol"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">SSLHostConfig</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Certificate</span> <span class="hljs-attr">certificateKeystoreFile</span>=<span class="hljs-string">"conf/localhost-rsa.jks"</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">certificateKeystorePassword</span>=<span class="hljs-string">"changeit"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"RSA"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">SSLHostConfig</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span><br>    --&gt;<br><br>    <span class="hljs-comment">&lt;!-- AJP Connector 示例（注释）</span><br><span class="hljs-comment">         AJP（Apache JServ Protocol）常用于与前端服务器（如 Apache httpd 或早期的代理）通信。</span><br><span class="hljs-comment">         安全提醒：AJP 在过去存在配置不当导致远程代码执行的高危问题（如 Ghostcat），</span><br><span class="hljs-comment">         因此如果不使用最好禁用，或限制绑定地址为本地回环并做访问控制。</span><br><span class="hljs-comment">         常用属性：</span><br><span class="hljs-comment">           protocol="AJP/1.3"</span><br><span class="hljs-comment">           address: 绑定地址（可限制为 127.0.0.1 或 ::1）</span><br><span class="hljs-comment">           port: AJP 端口（默认 8009）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;Connector protocol="AJP/1.3"</span><br><span class="hljs-comment">               address="::1"</span><br><span class="hljs-comment">               port="8009"</span><br><span class="hljs-comment">               redirectPort="8443" /&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Engine：Catalina 引擎，处理所有请求并根据 Host 分发</span><br><span class="hljs-comment">         常用属性：</span><br><span class="hljs-comment">           name: 引擎名字</span><br><span class="hljs-comment">           defaultHost: 默认虚拟主机（Host）的名字（当请求不匹配任何 Host 时使用）</span><br><span class="hljs-comment">           jvmRoute: 用于负载均衡和 session 粘滞（在使用 AJP / 负载均衡器时有用）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 说明：建议在使用集群或负载均衡时配置 jvmRoute（eg. jvm1、jvm2） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Engine</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span> <span class="hljs-attr">defaultHost</span>=<span class="hljs-string">"localhost"</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- Cluster（集群）配置示例（被注释）。如需启用会话复制等功能，可参考文档 --&gt;</span><br>      <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">      &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;</span><br><span class="hljs-comment">      --&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- Realm（身份认证与授权）配置：</span><br><span class="hljs-comment">           外层 LockOutRealm 用来保护内部 Realm，防暴力破解（如超过失败次数会锁定账户）。</span><br><span class="hljs-comment">           内层 UserDatabaseRealm 从全局 JNDI 的 UserDatabase（conf/tomcat-users.xml）读取用户/角色信息。</span><br><span class="hljs-comment">           常用 Realm 类型还有 JDBCRealm、DataSourceRealm、JNDIRealm 等（用于生产环境接 LDAP/DB）。</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Realm</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里的 UserDatabaseRealm 使用 GlobalNamingResources 中的 UserDatabase 资源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Realm</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">resourceName</span>=<span class="hljs-string">"UserDatabase"</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">Realm</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- Host：表示一个虚拟主机（virtual host）</span><br><span class="hljs-comment">           常用属性：</span><br><span class="hljs-comment">             name: 主机名（必须对应请求的 Host header 或者是 defaultHost）</span><br><span class="hljs-comment">             appBase: webapp 存放目录（相对于 CATALINA_BASE 或绝对路径）</span><br><span class="hljs-comment">             unpackWARs: 是否自动解压 war 包（true/false）</span><br><span class="hljs-comment">             autoDeploy: 是否在运行时自动扫描并部署 webapps（开发方便，生产通常禁用）</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"localhost"</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span></span><br><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- SingleSignOn Valve（注释）</span><br><span class="hljs-comment">             用途：在同一 Engine 内的多个 webapp 之间共享认证信息（登录一次，多个应用免登陆）。</span><br><span class="hljs-comment">             注意：使用 SSO 时需评估安全性与会话管理。</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- AccessLogValve：访问日志记录器</span><br><span class="hljs-comment">             常用属性：</span><br><span class="hljs-comment">               className: 实现类</span><br><span class="hljs-comment">               directory: 日志输出目录（相对于 CATALINA_BASE）</span><br><span class="hljs-comment">               prefix/suffix: 日志文件前后缀</span><br><span class="hljs-comment">               pattern: 日志格式（类似 Apache httpd 的格式，Tomcat 支持很多占位符）</span><br><span class="hljs-comment">             pattern 示例中：</span><br><span class="hljs-comment">               %h 客户端 IP</span><br><span class="hljs-comment">               %l 远程逻辑用户（通常为 -）</span><br><span class="hljs-comment">               %u 认证用户名</span><br><span class="hljs-comment">               %t 时间</span><br><span class="hljs-comment">               "%r" 请求第一行（方法与 URL 与 协议）</span><br><span class="hljs-comment">               %s 状态码</span><br><span class="hljs-comment">               %b 返回字节数</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">prefix</span>=<span class="hljs-string">"localhost_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b"</span> /&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="快速参考（链接）"><a href="#快速参考（链接）" class="headerlink" title="快速参考（链接）"></a>快速参考（链接）</h2><ul><li>Tomcat 官网（下载与文档）：<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></li><li>Which version（Tomcat 与 Java 对应表）：<a href="https://tomcat.apache.org/whichversion.html%E3%80%82">https://tomcat.apache.org/whichversion.html。</a> :contentReference[oaicite:11]{index=11}</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/posts/Maven/"/>
    <url>/posts/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>上文提到的Servlet包属于是外部依赖，我们在开发中往往需要引入很多这样的依赖，但是手动下载和引入是一件麻烦的事情，所以我们需要一个统一的包管理工具Maven，来帮助我们管理jar包和构建项目。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p>安装后解压，配置环境变量</p><p>与jdk配置环境变量的方式类似。</p><ol><li>高级系统设置</li><li>环境变量</li><li>示例：配置MAVEN_HOME  =  D:\Programs\apache-maven-3.9.9</li><li>配置path：新增：%MAVEN_HOME%\bin</li><li>点击确定</li></ol><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>打开<code>cmd</code>命令行，输入<code>mvn -version</code>如果出现版本号，那就是安装成功了。</p><p>配置镜像站在<a href="https://blog.csdn.net/m0_73804764/article/details/139898041">这里</a></p><h2 id="IDEA中配置MAVEN"><a href="#IDEA中配置MAVEN" class="headerlink" title="IDEA中配置MAVEN"></a>IDEA中配置MAVEN</h2><ol><li>打开设置（File - Settings）</li><li>找到maven（Build,Execution… - Build Tools - Maven）</li><li>配置maven路径、配置文件、本地仓库</li><li>安装Maven-Helper插件</li></ol><p>建议按照以下文件结构继续：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">src: 源代码<br>  -main：核心代码<br>    --java：java代码的位置<br>    --resources：资源，例如配置文件、图片等<br>  -test: 测试代码<br>    --java：测试相关java代码的位置<br>    --resources：测试相关资源，例如配置文件、图片等<br>pom.xml： 项目对象模型的配置文件。<br><br>External Libraries：用到的外部依赖<br></code></pre></td></tr></tbody></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>POM.xml是Maven的核心配置文件，修改POM.xml文件，Maven就会解析该文件并引入对应的包。</p><p>如，在<code>dependencies</code>标签中添加Servlet和hutool依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.35<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>随后点击<code>Dependency Analyer</code>—-<code>Reimport</code>引入我们需要的包。</p><p><a href="https://imgchr.com/i/pVLo9aj"><img src="https://s21.ax1x.com/2025/10/20/pVLo9aj.png" alt="pVLo9aj.png"></a></p><h1 id="使用Maven一键运行Tomcat项目"><a href="#使用Maven一键运行Tomcat项目" class="headerlink" title="使用Maven一键运行Tomcat项目"></a>使用Maven一键运行Tomcat项目</h1><h3 id="引入Tomcat依赖"><a href="#引入Tomcat依赖" class="headerlink" title="引入Tomcat依赖"></a>引入Tomcat依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">uriEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">uriEncoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>随后右键pom.xml,Run Maven ——- tomcat7:run</p><p>打开<a href="http://localhost:8080/(Html%E6%96%87%E4%BB%B6%E5%90%8D)%E6%9D%A5%E6%89%93%E5%BC%80%E9%A2%84%E8%A7%88%E7%95%8C%E9%9D%A2%E3%80%82">http://localhost:8080/(Html文件名)来打开预览界面。</a></p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/posts/Servlet/"/>
    <url>/posts/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet（Server Applet）是 <strong>Java Servlet</strong> 的简称，也叫“小型服务程序”或“服务连接器”。它是使用 <strong>Java</strong> 编写的服务器端组件，具有跨平台和与协议无关的特性。Servlet 主要用于在 Web 环境中进行交互式的数据处理与动态内容生成。</p><hr><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><ul><li><strong>狭义定义</strong>：Servlet 是 Java 中的一个接口。</li><li><strong>广义定义</strong>：Servlet 是任何实现了该接口的类。</li></ul><hr><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>Servlet 运行在 <strong>Java 应用服务器</strong> 中，例如 <strong>Tomcat</strong>。<br>它能够响应客户端请求，处理数据并动态生成网页内容，从而满足 Web 应用对动态页面的需求。</p><hr><h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><ol><li><strong>接收请求</strong><br>用户在浏览器中执行操作（如点击链接或提交表单），浏览器会向服务器发送请求。</li><li><strong>处理请求</strong><br>服务器接收到请求后，会根据请求路径将其分发给相应的 Servlet。<br>Servlet 容器（如 Tomcat）负责管理 Servlet 的整个生命周期，包括加载、初始化、请求处理和销毁。<br>Servlet 会从请求中读取数据，执行相应的业务逻辑，并生成响应内容。</li><li><strong>生成响应</strong><br>Servlet 通过 <code>HttpServletResponse</code> 对象将生成的内容（例如 HTML、JSON、XML 等）写入响应流。</li><li><strong>返回响应</strong><br>服务器将响应内容返回给客户端，浏览器最终展示结果页面。</li></ol><hr><h2 id="四、生命周期"><a href="#四、生命周期" class="headerlink" title="四、生命周期"></a>四、生命周期</h2><p>Servlet 的生命周期是从 <strong>创建到销毁</strong> 的完整过程，由 <strong>Servlet 容器</strong> 全权管理。其主要阶段如下：</p><ol><li><strong>加载与实例化</strong><br>当服务器启动或首次访问某个 Servlet 时，容器会加载其类并创建实例。<br>此过程只执行一次，一个 Servlet 实例可以同时处理多个请求。</li><li><strong>初始化（init）</strong><br>实例创建后，容器调用 <code>init()</code> 方法完成初始化工作。<br>通常用于读取配置、连接数据库或加载资源。<br><code>init()</code> 方法在整个生命周期中只执行一次。</li><li><strong>请求处理（service）</strong><br>每当有新的请求到达时，容器会调用 <code>service()</code> 方法。<br>该方法会根据请求类型（GET、POST 等）自动分发到 <code>doGet()</code>、<code>doPost()</code> 等具体处理方法。<br>这一步会被多次调用，用于实际的业务处理。</li><li><strong>销毁（destroy）</strong><br>当服务器关闭或容器需要释放资源时，会调用 <code>destroy()</code> 方法销毁 Servlet 实例。<br>通常用于关闭连接、释放资源或执行清理操作。</li></ol><hr><h2 id="五、相关说明"><a href="#五、相关说明" class="headerlink" title="五、相关说明"></a>五、相关说明</h2><p>在 Tomcat 的安装目录中，可以找到 <code>servlet-api.jar</code> 文件。<br>该文件包含了 Servlet 的接口定义，是 Web 开发中必不可少的外部依赖库。</p><hr><p><img src="https://s21.ax1x.com/2025/10/20/pVLI2P1.png" alt="Servlet"></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Servlet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/posts/Nginx/"/>
    <url>/posts/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>nginx是高性能HTTP服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。它具有并发处理能力强、内存占用少、运行稳定等特点，并支持跨平台运行，如Linux和Windows。</p><p>它能够运行静态网页，包括本博客就是用Nginx运行的。</p><p><img src="https://s2.loli.net/2025/10/20/LWxGM9l5XQwE73B.png" alt="image-20251020111026989"></p><h1 id="安装地址："><a href="#安装地址：" class="headerlink" title="安装地址："></a>安装地址：</h1><p><a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><p>解压后双击Nginx.exe启动</p><p><img src="https://s2.loli.net/2025/10/20/GvJUV7w8dehOYqE.png" alt="image-20251020111725464"></p><p>html文件夹下放html文件，就可以展示对应界面。</p><p>本地预览地址是<a href="http://localhost/(html%E6%96%87%E4%BB%B6%E5%90%8D)">http://localhost:80/(html文件名)</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置文件在/nginx/conf/nginx.conf</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 定义运行Nginx进程的用户和用户组，默认nobody（所有用户可运行）</span><br><span class="hljs-comment">#user  nobody;</span><br><br><span class="hljs-comment"># 设置工作进程数量（通常等于CPU核心数或auto自动检测）</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment"># 错误日志配置（可设置不同级别：debug|info|notice|warn|error|crit）</span><br><span class="hljs-comment">#error_log  logs/error.log;           # 默认错误日志</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;  # 通知级别日志</span><br><span class="hljs-comment">#error_log  logs/error.log  info;     # 信息级别日志（最详细）</span><br><br><span class="hljs-comment"># 进程ID存储文件路径</span><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><span class="hljs-comment"># 事件处理模块配置</span><br><span class="hljs-section">events</span> {<br>    <span class="hljs-comment"># 单个工作进程的最大并发连接数（总并发= worker_processes * worker_connections）</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>}<br><br><span class="hljs-comment"># HTTP服务器核心配置块</span><br><span class="hljs-section">http</span> {<br>    <span class="hljs-comment"># 引入MIME类型映射文件（定义文件扩展名与Content-Type的对应关系）</span><br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <br>    <span class="hljs-comment"># 默认MIME类型（当无法识别文件类型时使用application/octet-stream）</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment"># 定义日志格式模板（main为格式名称）</span><br>    <span class="hljs-comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br>    <span class="hljs-comment">#                  '$status $body_bytes_sent "$http_referer" '</span><br>    <span class="hljs-comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><br>    <span class="hljs-comment"># 访问日志设置（使用main格式，路径为logs/access.log）</span><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-comment"># 开启高效文件传输模式（零拷贝技术，提升静态文件传输性能）</span><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <br>    <span class="hljs-comment"># 在sendfile模式下，将数据包累积到一定大小再发送（提升网络效率）</span><br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment"># 连接超时时间设置（0表示禁用长连接）</span><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;  <span class="hljs-comment"># 长连接超时时间（秒）</span><br><br>    <span class="hljs-comment"># Gzip压缩开关（开启可减少传输数据量，但增加CPU开销）</span><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-comment"># 虚拟主机配置（一个server块代表一个虚拟主机）</span><br>    <span class="hljs-section">server</span> {<br>        <span class="hljs-comment"># 监听端口（可指定IP:端口，如listen 127.0.0.1:80）</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <br>        <span class="hljs-comment"># 服务器名称（支持域名、通配符、正则匹配，多个用空格分隔）</span><br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-comment"># 字符集设置（默认使用系统字符集，可设置为koi8-r、utf-8等）</span><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment"># 本虚拟主机的访问日志（可覆盖http块中的全局设置）</span><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br><br>        <span class="hljs-comment"># 位置块配置：匹配所有以/开头的请求</span><br>        <span class="hljs-section">location</span> / {<br>            <span class="hljs-comment"># 设置请求的根目录（相对路径基于nginx安装目录）</span><br>            <span class="hljs-attribute">root</span>   html;<br>            <br>            <span class="hljs-comment"># 设置默认索引文件（按从左到右优先级查找）</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        }<br><br>        <span class="hljs-comment"># 自定义错误页面（当出现404错误时返回/404.html）</span><br>        <span class="hljs-comment">#error_page  404              /404.html;</span><br><br>        <span class="hljs-comment"># 重定向服务器错误页到静态页面/50x.html</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <br>        <span class="hljs-comment"># 精确匹配路径/50x.html（=表示精确匹配，优先级最高）</span><br>        <span class="hljs-section">location</span> = /50x.html {<br>            <span class="hljs-attribute">root</span>   html;  <span class="hljs-comment"># 错误页面所在目录</span><br>        }<br><br>        <span class="hljs-comment"># PHP脚本代理到Apache（示例配置，需要取消注释并修改）</span><br>        <span class="hljs-comment">#location ~ \.php$ {</span><br>        <span class="hljs-comment">#    proxy_pass   http://127.0.0.1;  # 转发到本机Apache</span><br>        <span class="hljs-comment">#}</span><br><br>        <span class="hljs-comment"># PHP脚本通过FastCGI处理（需要PHP-FPM服务运行在9000端口）</span><br>        <span class="hljs-comment">#location ~ \.php$ {</span><br>        <span class="hljs-comment">#    root           html;</span><br>        <span class="hljs-comment">#    fastcgi_pass   127.0.0.1:9000;  # PHP-FPM地址</span><br>        <span class="hljs-comment">#    fastcgi_index  index.php;</span><br>        <span class="hljs-comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>        <span class="hljs-comment">#    include        fastcgi_params;   # 引入FastCGI参数文件</span><br>        <span class="hljs-comment">#}</span><br><br>        <span class="hljs-comment"># 禁止访问.htaccess文件（Apache配置文件，增强安全性）</span><br>        <span class="hljs-comment">#location ~ /\.ht {</span><br>        <span class="hljs-comment">#    deny  all;  # 拒绝所有访问</span><br>        <span class="hljs-comment">#}</span><br>    }<br><br>    <span class="hljs-comment"># 另一个虚拟主机示例（基于IP、域名和端口的混合配置）</span><br>    <span class="hljs-comment">#server {</span><br>    <span class="hljs-comment">#    listen       8000;                   # 监听8000端口</span><br>    <span class="hljs-comment">#    listen       somename:8080;          # 监听8080端口并指定主机名</span><br>    <span class="hljs-comment">#    server_name  somename  alias  another.alias;  # 多域名配置</span><br>    <br>    <span class="hljs-comment">#    location / {</span><br>    <span class="hljs-comment">#        root   html;</span><br>    <span class="hljs-comment">#        index  index.html index.htm;</span><br>    <span class="hljs-comment">#    }</span><br>    <span class="hljs-comment">#}</span><br><br>    <span class="hljs-comment"># HTTPS服务器配置示例（需要SSL证书）</span><br>    <span class="hljs-comment">#server {</span><br>    <span class="hljs-comment">#    listen       443 ssl;                # 监听443端口并启用SSL</span><br>    <span class="hljs-comment">#    server_name  localhost;</span><br>    <br>    <span class="hljs-comment">#    # SSL证书文件路径（需替换为实际证书）</span><br>    <span class="hljs-comment">#    ssl_certificate      cert.pem;</span><br>    <span class="hljs-comment">#    ssl_certificate_key  cert.key;</span><br>    <br>    <span class="hljs-comment">#    # SSL会话缓存设置（shared表示多个工作进程共享缓存）</span><br>    <span class="hljs-comment">#    ssl_session_cache    shared:SSL:1m;</span><br>    <span class="hljs-comment">#    ssl_session_timeout  5m;              # 会话超时时间</span><br>    <br>    <span class="hljs-comment">#    # 加密套件配置（禁用弱算法增强安全性）</span><br>    <span class="hljs-comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br>    <span class="hljs-comment">#    ssl_prefer_server_ciphers  on;        # 优先使用服务器端加密套件</span><br>    <br>    <span class="hljs-comment">#    location / {</span><br>    <span class="hljs-comment">#        root   html;</span><br>    <span class="hljs-comment">#        index  index.html index.htm;</span><br>    <span class="hljs-comment">#    }</span><br>    <span class="hljs-comment">#}</span><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/posts/JSON/"/>
    <url>/posts/JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h1><p><strong>JSON（JavaScript Object Notation）</strong> 是一种轻量级、文本性的数据交换格式，便于人阅读与编写，也易于机器解析和生成。尽管起源于 JavaScript 的语法子集，JSON 已成为与语言无关的通用数据格式，广泛被各种编程语言支持。</p><hr><h2 id="1-简介-——-什么是-JSON？"><a href="#1-简介-——-什么是-JSON？" class="headerlink" title="1. 简介 —— 什么是 JSON？"></a>1. 简介 —— 什么是 JSON？</h2><p>JSON 用键值对（key–value）来表示结构化数据，支持嵌套对象与数组，从而能够描述复杂的数据结构。它常用于前后端交互、配置文件和轻量级数据存储。</p><hr><h2 id="2-JSON-的主要特点"><a href="#2-JSON-的主要特点" class="headerlink" title="2. JSON 的主要特点"></a>2. JSON 的主要特点</h2><ul><li><strong>可读性高</strong>：采用清晰的文本表示，结构直观。</li><li><strong>易于编写</strong>：语法简单，不需要复杂标记。</li><li><strong>易于解析</strong>：多数语言提供标准库或第三方库用于解析/生成。</li><li><strong>轻量级</strong>：相较于 XML 等格式更为紧凑，传输效率高。</li></ul><hr><h2 id="3-基本结构"><a href="#3-基本结构" class="headerlink" title="3. 基本结构"></a>3. 基本结构</h2><p>JSON 有两种顶级结构：<strong>对象（Object）</strong> 和 <strong>数组（Array）</strong>。</p><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>对象由若干键值对组成，使用大括号 <code>{}</code> 包围，键必须是字符串（双引号），值可以是字符串、数字、布尔值、<code>null</code>、对象或数组。</p><p>示例：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"张三"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"isStudent"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"address"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"city"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"北京"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"street"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"长安街"</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><p>数组由一系列值组成，使用中括号 <code>[]</code> 包围，元素之间用逗号分隔。数组元素类型可以混合（字符串、数字、对象等）。</p><p>示例：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-string">"苹果"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">"香蕉"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"橙子"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"color"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"橙色"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">3.14</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="4-语法规则要点"><a href="#4-语法规则要点" class="headerlink" title="4. 语法规则要点"></a>4. 语法规则要点</h2><ol><li><strong>键名（Key）</strong>：必须是字符串，<strong>必须</strong>用双引号 <code>"</code> 包围。</li><li><strong>值（Value）</strong>：可以是：<ul><li>字符串（双引号）</li><li>数字（整数或浮点数）</li><li>布尔值：<code>true</code> / <code>false</code></li><li><code>null</code></li><li>对象（嵌套 <code>{}</code>）</li><li>数组（<code>[]</code>）</li></ul></li><li><strong>分隔符</strong>：对象的键值对与数组元素之间用逗号 <code>,</code> 分隔；最后一项后不能有多余的逗号（严格 JSON 不允许尾随逗号）。</li><li><strong>字符串转义</strong>：特殊字符需用反斜杠 <code>\</code> 转义，例如：<code>\n</code>（换行）、<code>\t</code>（制表）、<code>\"</code>（双引号）、<code>\\</code>（反斜杠）等。</li></ol><hr><h2 id="5-常见用途"><a href="#5-常见用途" class="headerlink" title="5. 常见用途"></a>5. 常见用途</h2><ul><li><strong>前后端数据交换</strong>：浏览器通过 AJAX / fetch 获取后端返回的 JSON 数据，然后转换为对象进行处理。</li><li><strong>配置文件</strong>：许多工具和库使用 JSON 作为配置文件格式（可读、可编辑）。</li><li><strong>数据存储</strong>：NoSQL 数据库（如 MongoDB）使用 JSON 风格的文档存储数据。</li><li><strong>日志与接口标准</strong>：在微服务与接口设计中，JSON 常用作请求/响应的标准格式。</li></ul><hr><h2 id="6-解析与生成（示例）"><a href="#6-解析与生成（示例）" class="headerlink" title="6. 解析与生成（示例）"></a>6. 解析与生成（示例）</h2><p>不同语言通常都有内置或常用库进行 JSON 操作。</p><ul><li><p><strong>JavaScript</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonString);      <span class="hljs-comment">// 将 JSON 字符串解析为对象/数组</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);         <span class="hljs-comment">// 将对象/数组转换为 JSON 字符串</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>Python</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>obj = json.loads(json_string)            <span class="hljs-comment"># 解析</span><br>s = json.dumps(obj, ensure_ascii=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 生成（ensure_ascii=False 保持中文）</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>Java（示例库）</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Gson</span><br><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> gson.fromJson(jsonString, MyClass.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> gson.toJson(obj);<br></code></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="7-注意事项与最佳实践"><a href="#7-注意事项与最佳实践" class="headerlink" title="7. 注意事项与最佳实践"></a>7. 注意事项与最佳实践</h2><ul><li><strong>键名唯一</strong>：同一对象中不要重复使用相同键名（行为未定义或后者覆盖前者）。</li><li><strong>类型明确</strong>：注意区分字符串和数字，避免将数字写成带引号的字符串（除非确有需要）。</li><li><strong>不要有尾随逗号</strong>：严格 JSON 禁止最后一项后多余逗号，例如 <code>{ "a": 1, }</code> 是非法的。</li><li><strong>字符编码</strong>：一般使用 UTF-8 编码，处理中文时注意编码一致性。</li><li><strong>安全性</strong>：处理来自不可信来源的 JSON 时，注意避免注入或反序列化漏洞；不要将 <code>eval</code> 用于解析 JSON。</li><li><strong>合理的结构设计</strong>：为接口或配置设计清晰、扁平或层次分明的结构，便于维护与演进。</li></ul><hr><h2 id="8-常见错误示例（便于排查）"><a href="#8-常见错误示例（便于排查）" class="headerlink" title="8. 常见错误示例（便于排查）"></a>8. 常见错误示例（便于排查）</h2><ul><li><p>使用单引号代替双引号（非法）：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span> 'name'<span class="hljs-punctuation">:</span> '张三' <span class="hljs-punctuation">}</span>   <span class="hljs-comment">// 错误：键与字符串必须用双引号</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>尾随逗号（非法）：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">}</span>         <span class="hljs-comment">// 错误：最后不能有逗号</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>未转义特殊字符（可能导致解析失败）：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"text"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"第一行</span><br><span class="hljs-string">第二行"</span> <span class="hljs-punctuation">}</span>           <span class="hljs-comment">// 错误：换行应使用 \n 转义</span><br></code></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p>JSON 是一种简洁、通用的数据交换格式，适合绝大多数前后端通信与轻量级数据存储场景。掌握其基本语法（字符串需双引号、无尾逗号、类型与转义）和常用解析/生成方法，可以在绝大多数开发任务中提高效率与互操作性。</p><hr>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML</title>
    <link href="/posts/XML/"/>
    <url>/posts/XML/</url>
    
    <content type="html"><![CDATA[<h1 id="XML（可扩展标记语言）"><a href="#XML（可扩展标记语言）" class="headerlink" title="XML（可扩展标记语言）"></a>XML（可扩展标记语言）</h1><p>XML（Extensible Markup Language，可扩展标记语言）是一种用于<strong>存储和传输数据</strong>的标记语言。<br>与 HTML 不同，XML 的标签不是预定义的，而是由用户自定义的，这使得 XML 非常适合于各种应用，如数据存储、配置文件、网络传输等。</p><hr><h2 id="一、XML-简介"><a href="#一、XML-简介" class="headerlink" title="一、XML 简介"></a>一、XML 简介</h2><h3 id="什么是-XML？"><a href="#什么是-XML？" class="headerlink" title="什么是 XML？"></a>什么是 XML？</h3><p>XML 是一种标记语言，用于描述数据。它允许用户定义自己的标签来存储信息。</p><h3 id="XML-的特点："><a href="#XML-的特点：" class="headerlink" title="XML 的特点："></a>XML 的特点：</h3><ul><li><strong>自描述性</strong>：标签描述了数据的含义。</li><li><strong>平台无关性</strong>：XML 文件可以在任何操作系统和平台上使用。</li><li><strong>数据驱动</strong>：XML 关注数据本身，而不是显示格式。</li><li><strong>易于扩展</strong>：用户可以定义自己的标签。</li></ul><hr><h2 id="二、XML-文档结构"><a href="#二、XML-文档结构" class="headerlink" title="二、XML 文档结构"></a>二、XML 文档结构</h2><p>一个基本的 XML 文档示例如下：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>````<br><br>**结构说明：**<br><br>* **XML 声明**：`<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>` 指定了 XML 的版本和字符编码。<br>* **根元素**：`<span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>` 是根元素，所有其他元素都嵌套在其中。<br>* **子元素**：`<span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>` 是根元素 `<span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>` 的子元素。<br><br>---<br><br>## 三、XML 语法规则<br><br>1. **所有标签都必须有闭合：**<br><br>   ```xml<br>   <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>   自闭合标签（空元素）：</p>   <figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tag</span> /&gt;</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><p><strong>标签名称区分大小写：</strong><br><code>&lt;Note&gt;</code> 和 <code>&lt;note&gt;</code> 是不同的标签。</p></li><li><p><strong>属性值必须用引号括起来：</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"John Doe"</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"30"</span>/&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>元素必须正确嵌套：</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">outer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">inner</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">inner</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">outer</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>特殊字符需要使用实体引用：</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;  表示小于号 <span class="hljs-comment">(&lt;)</span><br>&gt;  表示大于号 <span class="hljs-comment">(&gt;)</span><br>&amp; 表示和号 <span class="hljs-comment">(&amp;)</span><br><span class="hljs-string">' 表示单引号 ('</span>)<br><span class="hljs-string">" 表示双引号 ("</span>)<br></code></pre></td></tr></tbody></table></figure></li></ol><hr><h2 id="四、XML-元素和属性"><a href="#四、XML-元素和属性" class="headerlink" title="四、XML 元素和属性"></a>四、XML 元素和属性</h2><h3 id="元素（Element）"><a href="#元素（Element）" class="headerlink" title="元素（Element）"></a>元素（Element）</h3><p>元素是 XML 文档的基本构建块，由<strong>开始标签、内容、结束标签</strong>组成。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XML教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h3><p>属性提供元素的额外信息，放在开始标签内。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">"编程"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XML教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="五、注释与-CDATA-区"><a href="#五、注释与-CDATA-区" class="headerlink" title="五、注释与 CDATA 区"></a>五、注释与 CDATA 区</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>XML 中的注释以 <code>&lt;!--</code> 开始，以 <code>--&gt;</code> 结束。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="CDATA-区"><a href="#CDATA-区" class="headerlink" title="CDATA 区"></a>CDATA 区</h3><p>CDATA 区用于在 XML 文件中包含<strong>不被解析器解析的文本数据</strong>。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>&lt;![CDATA[这是一个包含&lt;特殊字符&gt;的文本]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="六、XML-Schema（XSD）"><a href="#六、XML-Schema（XSD）" class="headerlink" title="六、XML Schema（XSD）"></a>六、XML Schema（XSD）</h2><p>XML Schema 用于定义 XML 文档的结构和数据类型。</p><h3 id="示例-XSD-文件："><a href="#示例-XSD-文件：" class="headerlink" title="示例 XSD 文件："></a>示例 XSD 文件：</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xs:schema</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"book"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">xs:complexType</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">xs:sequence</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">xs:sequence</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">xs:complexType</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xs:element</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xs:schema</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="关联-XML-与-XSD："><a href="#关联-XML-与-XSD：" class="headerlink" title="关联 XML 与 XSD："></a>关联 XML 与 XSD：</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">"book.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XML教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="七、XML-解析方式"><a href="#七、XML-解析方式" class="headerlink" title="七、XML 解析方式"></a>七、XML 解析方式</h2><p>XML 解析器用于读取和分析 XML 文档。常见的解析方式包括：</p><ul><li><strong>DOM（Document Object Model）</strong>：将整个文档加载到内存中，形成一个树形结构，方便操作但占内存大。</li><li><strong>SAX（Simple API for XML）</strong>：逐行读取文档，事件驱动，适合处理大型文档。</li><li><strong>StAX（Streaming API for XML）</strong>：基于 Java 的流式 API，适合高效地处理大型 XML 文档。</li></ul><hr><p><strong>总结：</strong><br>XML 是一种高度灵活的数据表示语言，适用于跨平台的数据交换和存储。<br>它不关注展示，而是注重结构与意义，常用于配置文件、网络通信、Web 服务（如 SOAP）和数据存储。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程</title>
    <link href="/posts/Java_Thread/"/>
    <url>/posts/Java_Thread/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA线程"><a href="#JAVA线程" class="headerlink" title="JAVA线程"></a>JAVA线程</h1><h2 id="一、多线程基础"><a href="#一、多线程基础" class="headerlink" title="一、多线程基础"></a>一、多线程基础</h2><p><strong>进程</strong>是操作系统分配资源的最小单元，<strong>线程</strong>是操作系统调度的最小单元。一个进程中可以包含多个线程，这些线程共享进程的资源。</p><p><strong>并发</strong>是指处理器通过<strong>时间片轮转</strong>等方式，在宏观上同时处理多个任务，但微观上这些任务实际上是交替执行的。<strong>并行</strong>则是指多个处理器核心真正地同时执行多个任务。在多核CPU架构下，多线程不仅能提高程序响应速度（将耗时操作放入后台线程），还能充分利用多核计算能力。</p><p>WIN系统（以及所有现代操作系统）实现多线程确实采用了<strong>时间片轮转</strong>的调度机制。即使在单核CPU上，也可以通过快速切换执行不同的线程，给人“同时”进行的错觉。在多核CPU上，多个线程可以真正并行执行。</p><h2 id="二、创建线程的方式"><a href="#二、创建线程的方式" class="headerlink" title="二、创建线程的方式"></a>二、创建线程的方式</h2><p>多线程的具体表现形式如下，你执行后就能够发现主线程和输出abc的线程是齐头并进的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mythread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>{  <span class="hljs-comment">//继承线程Thread公共类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>    {<br>        System.out.println(<span class="hljs-string">"abc"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Th</span>{<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Mythread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mythread</span>();<br>        t.start ();<br>        System.out.println(<span class="hljs-string">"1"</span>);<br>        System.out.println(<span class="hljs-string">"2"</span>);<br>        System.out.println(<span class="hljs-string">"3"</span>);<br>        System.out.println(<span class="hljs-string">"4"</span>);<br>    }<br><br>    <br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h3><p>通过继承<code>Thread</code>类并重写<code>run</code>方法（该方法为线程的入口点）来创建线程。调用<code>start()</code>方法（而非直接调用<code>run</code>方法）来启动线程，<code>start()</code>方法会启动一个新的执行线程并调用<code>run</code>方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> { <span class="hljs-comment">// 继承Thread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 重写run方法</span><br>        System.out.println(<span class="hljs-string">"MyThread is running"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start(); <span class="hljs-comment">// 启动线程，最终由JVM调用run方法</span><br>        System.out.println(<span class="hljs-string">"Main thread"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：直接调用<code>run()</code>方法只会像普通方法一样在当前线程执行，而不会启动新线程。</p><h3 id="2-实现Runnable接口（推荐）"><a href="#2-实现Runnable接口（推荐）" class="headerlink" title="2. 实现Runnable接口（推荐）"></a>2. 实现Runnable接口（推荐）</h3><p>实现<code>Runnable</code>接口的类并非线程类，而是<strong>任务类</strong>。需要将<code>Runnable</code>实例作为参数传递给<code>Thread</code>构造函数来创建线程。这种方式更灵活，避免了单继承的限制，也更符合面向对象的思想。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> { <span class="hljs-comment">// 实现Runnable接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"MyRunnable is running"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task); <span class="hljs-comment">// 将Runnable任务传递给Thread构造函数</span><br>        t.start();<br>        System.out.println(<span class="hljs-string">"Main thread"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="三、线程的状态与生命周期"><a href="#三、线程的状态与生命周期" class="headerlink" title="三、线程的状态与生命周期"></a>三、线程的状态与生命周期</h2><p>Java线程在其生命周期中可能处于以下几种状态（定义在<code>Thread.State</code>枚举中）：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><strong>NEW</strong> (新建)</td><td>线程被创建但尚未调用<code>start()</code>方法</td></tr><tr><td><strong>RUNNABLE</strong> (可运行)</td><td>调用<code>start()</code>后，线程正在JVM中执行或等待系统资源（如CPU）</td></tr><tr><td><strong>BLOCKED</strong> (阻塞)</td><td>线程被阻塞，等待获取<strong>监视器锁</strong>（如进入<code>synchronized</code>块）</td></tr><tr><td><strong>WAITING</strong> (等待)</td><td>线程进入等待状态，需要其他线程显式唤醒（如<code>Object.wait()</code>）</td></tr><tr><td><strong>TIMED_WAITING</strong> (超时等待)</td><td>线程在指定的时间内等待（如<code>Thread.sleep(time)</code>）</td></tr><tr><td><strong>TERMINATED</strong> (终止)</td><td>线程已执行完毕（<code>run()</code>方法完成）</td></tr></tbody></table><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">stateDiagram-v2<br>    direction LR<br>    [*] --&gt; NEW<br>    NEW --&gt; RUNNABLE : start()<br>    RUNNABLE --&gt; TERMINATED : run()方法执行完毕<br>    <br>    RUNNABLE --&gt; BLOCKED : 等待进入<span class="hljs-keyword">synchronized</span>块/方法<br>    BLOCKED --&gt; RUNNABLE : 获取到锁<br>    <br>    RUNNABLE --&gt; WAITING : Object.wait()&lt;br/&gt;Thread.join()（无参）<br>    WAITING --&gt; RUNNABLE : Object.notify()/notifyAll()<br>    <br>    RUNNABLE --&gt; TIMED_WAITING : Thread.sleep(time)&lt;br/&gt;Object.wait(timeout)&lt;br/&gt;Thread.join(timeout)<br>    TIMED_WAITING --&gt; RUNNABLE : 超时/被中断/被唤醒<br></code></pre></td></tr></tbody></table></figure><h2 id="四、线程同步"><a href="#四、线程同步" class="headerlink" title="四、线程同步"></a>四、线程同步</h2><p>当多个线程访问<strong>共享资源</strong>时，可能会发生<strong>数据竞争</strong>（Data Race），导致数据不一致或其他不可预料的错误。Java提供了多种机制来保证线程安全。</p><h3 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h3><p><code>synchronized</code>是Java中最基本的同步机制，它可以同步<strong>代码块</strong>或<strong>方法</strong>。</p><ul><li><strong>同步代码块</strong>：需要显式指定一个对象作为<strong>锁</strong>。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">synchronized</span> (lockObject) { <span class="hljs-comment">// lockObject可以是任意对象，但所有线程必须共享同一个锁对象才有效</span><br>        <span class="hljs-comment">// 需要同步的代码</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>同步实例方法</strong>：锁是<strong>当前实例对象</strong>（<code>this</code>）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 方法体</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>同步静态方法</strong>：锁是<strong>当前类的Class对象</strong>（如<code>MyClass.class</code>）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>     <span class="hljs-comment">// 方法体</span><br> }<br></code></pre></td></tr></tbody></table></figure><h3 id="2-Lock-接口"><a href="#2-Lock-接口" class="headerlink" title="2. Lock 接口"></a>2. Lock 接口</h3><p>从Java 5开始，提供了<code>java.util.concurrent.locks.Lock</code>接口（如<code>ReentrantLock</code>），它提供了比<code>synchronized</code>更灵活的锁操作，如尝试非阻塞获取锁、可中断的获取锁以及超时获取锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> {<br>            count++;<br>        } <span class="hljs-keyword">finally</span> {<br>            lock.unlock(); <span class="hljs-comment">// 必须在finally块中释放锁，防止异常导致死锁</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>synchronized 与 Lock 的对比</strong></p><table><thead><tr><th>特性</th><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td><strong>实现级别</strong></td><td>JVM层面，原生语法</td><td>Java API层面</td></tr><tr><td><strong>锁的释放</strong></td><td>自动释放</td><td>必须手动调用<code>unlock()</code></td></tr><tr><td><strong>灵活性</strong></td><td>相对简单，不灵活</td><td>非常灵活，支持多种获取锁的方式</td></tr><tr><td><strong>性能</strong></td><td>早期性能较差，后续版本有优化</td><td>在高竞争环境下性能可能更好</td></tr><tr><td><strong>读写分离</strong></td><td>不支持</td><td>支持（<code>ReadWriteLock</code>）</td></tr></tbody></table><h2 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h2><p>线程间通信主要依靠<strong>等待/通知机制</strong>，核心方法是<code>Object</code>类的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>。<strong>这些方法必须在<code>synchronized</code>同步块或同步方法内调用</strong>，否则会抛出<code>IllegalMonitorStateException</code>异常。</p><ul><li><code>wait()</code>：使当前线程<strong>释放锁</strong>并进入等待（WAITING）状态，直到其他线程调用该对象的<code>notify()</code>或<code>notifyAll()</code>方法。</li><li><code>notify()</code>：随机唤醒一个在该对象上等待的线程。</li><li><code>notifyAll()</code>：唤醒所有在该对象上等待的线程。</li></ul><p>一个典型的生产者-消费者模型示例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumerExample</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Integer&gt; buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-keyword">synchronized</span> (lock) {<br>                <span class="hljs-keyword">while</span> (buffer.size() == CAPACITY) { <span class="hljs-comment">// 缓冲区满，生产者等待</span><br>                    lock.wait();<br>                }<br>                buffer.add(value++);<br>                System.out.println(<span class="hljs-string">"Produced: "</span> + value);<br>                lock.notifyAll(); <span class="hljs-comment">// 通知消费者可以消费了</span><br>            }<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟生产过程耗时</span><br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-keyword">synchronized</span> (lock) {<br>                <span class="hljs-keyword">while</span> (buffer.isEmpty()) { <span class="hljs-comment">// 缓冲区空，消费者等待</span><br>                    lock.wait();<br>                }<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> buffer.removeFirst();<br>                System.out.println(<span class="hljs-string">"Consumed: "</span> + value);<br>                lock.notifyAll(); <span class="hljs-comment">// 通知生产者可以生产了</span><br>            }<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟消费过程耗时</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="六、线程死锁"><a href="#六、线程死锁" class="headerlink" title="六、线程死锁"></a>六、线程死锁</h2><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因<strong>争夺资源</strong>而造成的一种<strong>互相等待</strong>的现象，若无外力干涉，这些线程都将无法继续执行下去</p><p>死锁产生的四个必要条件（缺一不可）：</p><p><strong>互斥条件</strong>：一个资源每次只能被一个线程使用。</p><p><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能被其他线程强行剥夺。</p><p><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</p><p><strong>避免死锁的常见方法</strong>：</p><p><strong>避免嵌套锁</strong>：尽量只获取一个锁。如果必须多个，确保所有线程以<strong>相同的顺序</strong>获取锁。</p><p><strong>使用定时锁</strong>：使用<code>Lock</code>接口的<code>tryLock(long time, TimeUnit unit)</code>方法，尝试获取锁超时则失败。</p><p><strong>减少同步范围</strong>：减小临界区范围，尽快释放锁。</p><h2 id="七、线程控制（补充）"><a href="#七、线程控制（补充）" class="headerlink" title="七、线程控制（补充）"></a>七、线程控制（补充）</h2><p><strong><code>join()</code>方法</strong>：等待目标线程执行完毕，当前线程才继续执行。可用于线程间同步。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {<br>    <span class="hljs-comment">// 一些操作</span><br>});<br>t.start();<br>t.join(); <span class="hljs-comment">// 主线程在此等待线程t执行完毕</span><br>System.out.println(<span class="hljs-string">"Thread t has finished."</span>);<br></code></pre></td></tr></tbody></table></figure><p><strong><code>sleep()</code>方法</strong>：让当前正在执行的线程<strong>休眠</strong>（暂停执行）指定的时间，但<strong>不会释放锁</strong>。</p><p><strong><code>yield()</code>方法</strong>：提示调度器当前线程愿意让出CPU，但调度器可以忽略这个提示。</p><p><strong><code>interrupt()</code>方法</strong>：中断目标线程。如果目标线程因<code>wait</code>, <code>sleep</code>, <code>join</code>而阻塞，会抛出<code>InterruptedException</code>并清除中断状态；否则，只是设置一个中断标志位，需要线程自己检查（<code>isInterrupted()</code>）并处理</p><p><strong>注意</strong>：<code>suspend()</code>, <code>resume()</code>, <code>stop()</code>等方法已被废弃，因为它们可能导致资源死锁和数据不一致，非常不安全。</p><h2 id="八、线程池"><a href="#八、线程池" class="headerlink" title="八、线程池"></a>八、线程池</h2><p>频繁创建和销毁线程开销很大。<strong>线程池</strong>可以预先创建一定数量的线程，放入池中备用。有任务时，从池中取线程执行；任务完成后，线程返回池中复用。这减少了创建销毁的开销，可以控制并发数，更有效地管理线程。</p><p>Java通过<code>java.util.concurrent.ExecutorService</code>接口及其实现类（如<code>ThreadPoolExecutor</code>）来提供线程池功能。通常使用<code>Executors</code>工具类来创建常见的线程池：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 创建一个固定大小的线程池（包含4个线程）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 提交任务给线程池执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; {<br>                System.out.println(<span class="hljs-string">"Executing task "</span> + taskId + <span class="hljs-string">" via "</span> + Thread.currentThread().getName());<br>            });<br>        }<br><br>        <span class="hljs-comment">// 关闭线程池（不再接受新任务，等待所有已提交任务完成）</span><br>        executor.shutdown();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java流</title>
    <link href="/posts/Java_Stream/"/>
    <url>/posts/Java_Stream/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA流"><a href="#JAVA流" class="headerlink" title="JAVA流"></a>JAVA流</h1><h2 id="流的基本概念"><a href="#流的基本概念" class="headerlink" title="流的基本概念"></a>流的基本概念</h2><p>流（Stream）在Java中是对<strong>数据序列的抽象</strong>，用于处理输入输出（I/O）操作。它代表了从一个源（如文件、网络套接字、内存缓冲区）到另一个目的地的数据流动。流不是特指网络套接字，而是涵盖了所有I/O操作，包括文件、控制台、网络等。</p><p>在计算机体系中，数据在磁盘、内存和CPU之间流动时，流充当了桥梁角色。但更准确地说，流操作通常涉及：</p><ul><li><strong>源</strong>（如磁盘文件）→ <strong>内存</strong>（缓冲区）→ <strong>程序（CPU处理）</strong></li><li><strong>程序</strong> → <strong>内存</strong>（缓冲区）→ <strong>目的</strong>（如磁盘文件）</li></ul><p>常见的流包括：</p><ul><li><strong>标准输入/输出流</strong>：<code>System.in</code>（标准输入），<code>System.out</code>（标准输出），<code>System.err</code>（标准错误输出）。例如 <code>System.out.println</code>使用了标准输出流。</li><li><strong>文件流</strong>：用于读写文件，如 <code>FileInputStream</code>, <code>FileOutputStream</code>, <code>FileReader</code>, <code>FileWriter</code>。</li><li><strong>缓冲流</strong>：在基础流之上增加缓冲功能，提高效率，如 <code>BufferedReader</code>, <code>BufferedWriter</code>。</li><li><strong>数据流</strong>：用于读写基本数据类型，如 <code>DataInputStream</code>, <code>DataOutputStream</code>。</li><li><strong>对象流</strong>：用于序列化对象，如 <code>ObjectInputStream</code>, <code>ObjectOutputStream</code>。</li><li><strong>网络流</strong>：用于网络通信，如 <code>Socket</code>相关的流。</li></ul><h2 id="文件流操作示例"><a href="#文件流操作示例" class="headerlink" title="文件流操作示例"></a>文件流操作示例</h2><p>文件流主要分为<strong>字节流</strong>（用于处理二进制数据）和<strong>字符流</strong>（用于处理文本数据，处理字符编码）。</p><h3 id="字节流文件复制"><a href="#字节流文件复制" class="headerlink" title="字节流文件复制"></a>字节流文件复制</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyByteStream</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1.txt"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2.txt"</span>;<br>        <span class="hljs-keyword">try</span> {<br>            copyByStream(sourceFile, targetFile);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用字节流复制文件（使用try-with-resources自动关闭资源）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sourceDir 源文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetDir 目标文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当IO操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyByStream</span><span class="hljs-params">(String sourceDir, String targetDir)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-comment">// 使用try-with-resources确保流自动关闭</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sourceDir);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(targetDir)) {<br>      <br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8192</span>]; <span class="hljs-comment">// 使用8KB缓冲区（通常比1KB更高效）</span><br>            <span class="hljs-type">int</span> length;<br>      <br>            <span class="hljs-keyword">while</span> ((length = fis.read(buffer)) != -<span class="hljs-number">1</span>) {<br>                fos.write(buffer, <span class="hljs-number">0</span>, length);<br>            }<br>      <br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        }<br>        <span class="hljs-comment">// 无需finally块 - try-with-resources自动处理关闭</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="字符流文件复制（改进版）"><a href="#字符流文件复制（改进版）" class="headerlink" title="字符流文件复制（改进版）"></a>字符流文件复制（改进版）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyCharStream</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1.txt"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2.txt"</span>;<br>        <span class="hljs-keyword">try</span> {<br>            copyByCharStream(sourceFile, targetFile);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用字符流复制文本文件（显式指定字符编码）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sourceDir 源文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetDir 目标文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当IO操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyByCharStream</span><span class="hljs-params">(String sourceDir, String targetDir)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-comment">// 使用StandardCharsets常量</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(sourceDir, StandardCharsets.UTF_8);<br>             <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(targetDir, StandardCharsets.UTF_8)) {<br>      <br>            <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-type">int</span> length;<br>      <br>            <span class="hljs-keyword">while</span> ((length = fis.read(buffer)) != -<span class="hljs-number">1</span>) {<br>                fos.write(buffer, <span class="hljs-number">0</span>, length);<br>            }<br>      <br>            <span class="hljs-comment">// flush操作会在close()中自动调用，通常无需显式调用</span><br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="缓冲流的使用（改进版）"><a href="#缓冲流的使用（改进版）" class="headerlink" title="缓冲流的使用（改进版）"></a>缓冲流的使用（改进版）</h2><p>缓冲流（Buffered Stream）通过减少底层系统的调用次数来提高I/O效率。它们确实在基础流之上添加了缓冲层，但更准确的说法是：<strong>缓冲流在内存中创建缓冲区，减少了对物理设备（如硬盘）的直接访问次数</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyBufferedStream</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"1.txt"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2.txt"</span>;<br>        <span class="hljs-keyword">try</span> {<br>            copyByBufferedStream(sourceFile, targetFile);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用缓冲流复制文件（更高效的IO操作）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sourceDir 源文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetDir 目标文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当IO操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyByBufferedStream</span><span class="hljs-params">(String sourceDir, String targetDir)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-comment">// 基础流在try-with-resources中创建，缓冲流包装它们</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sourceDir);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(targetDir);<br>             <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>             <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos)) {<br>      <br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-type">int</span> length;<br>      <br>            <span class="hljs-keyword">while</span> ((length = bis.read(buffer)) != -<span class="hljs-number">1</span>) {<br>                bos.write(buffer, <span class="hljs-number">0</span>, length);<br>            }<br>      <br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>某些缓冲流（如 <code>BufferedReader</code>）支持标记位置和重置功能。</p><h2 id="使用NIO-API进行文件复制（现代方法）"><a href="#使用NIO-API进行文件复制（现代方法）" class="headerlink" title="使用NIO API进行文件复制（现代方法）"></a>使用NIO API进行文件复制（现代方法）</h2><p>Java NIO (New I/O) 提供了更简洁高效的文件操作方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyNIO</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">sourcePath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"1.txt"</span>);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">targetPath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"2.txt"</span>);<br>  <br>        <span class="hljs-keyword">try</span> {<br>            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);<br>            System.out.println(<span class="hljs-string">"文件复制完成！"</span>);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"文件复制失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>NIO是新型的封装好的文件操作方法。</p><h2 id="重要注意事项与最佳实践"><a href="#重要注意事项与最佳实践" class="headerlink" title="重要注意事项与最佳实践"></a>重要注意事项与最佳实践</h2><p><strong>资源管理</strong>：<strong>总是使用try-with-resources</strong>来自动关闭流，避免资源泄漏。</p><p>不要依赖手动调用 <code>close()</code>，因为异常可能导致资源无法关闭。</p><p><strong>字符编码</strong>： 处理文本文件时<strong>总是明确指定字符编码</strong>（如UTF-8）。</p><p>避免使用 <code>FileReader</code>和 <code>FileWriter</code>的默认构造函数，因为它们使用平台默认编码，可能导致跨环境问题。</p><p><strong>缓冲区大小</strong>： 缓冲区大小（如8KB）通常比小缓冲区（如1KB）性能更好，但应通过测试确定最佳大小。</p><p>对于大文件，可以考虑使用更大的缓冲区（如64KB或128KB）。</p><p><strong>flush操作</strong>： 输出流在关闭前会自动flush，通常不需要显式调用 <code>flush()</code>。</p><p>如果需要确保数据立即写入（如实时日志），可以显式调用 <code>flush()</code>。</p><p><strong>性能考量</strong>： 对于大文件，NIO的 <code>Files.copy()</code>通常是最佳选择。</p><p>缓冲流对于多次小量读写操作最有效。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA异常</title>
    <link href="/posts/JAVA_Exception/"/>
    <url>/posts/JAVA_Exception/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA异常"><a href="#JAVA异常" class="headerlink" title="JAVA异常"></a>JAVA异常</h1><h2 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h2><p>异常（Exception）是指程序在<strong>运行时</strong>发生的不被期望的事件，它阻止了程序按照预期正常执行。需要注意的是，<strong>编译时期</strong>出现的错误（如语法错误）通常称为编译错误，不属于异常处理的范畴。异常处理机制旨在让程序在运行时遇到错误时，能够按照预先设定的逻辑进行应对，从而尽可能恢复或优雅终止。</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>Java中的异常和错误都继承自 <code>Throwable</code>类，其层次结构如下</p><p><img src="https://s21.ax1x.com/2025/10/09/pVH8qmt.png" alt="异常"></p><p><strong>Error (错误)<strong>： 是程序</strong>无法处理</strong>的严重问题，通常与JVM本身或系统资源相关，应用程序不应尝试捕获处理。例如 <code>OutOfMemoryError</code>（内存耗尽）、<code>StackOverflowError</code>（栈溢出，常由无限递归引发）等</p><p><strong>Exception (异常)<strong>： 是程序本身</strong>可以并且应该处理</strong>的问题。它分为两大类：</p><p><strong>受检异常 (Checked Exception)<strong>： 指在</strong>编译时期</strong>就必须被处理的异常。如果方法可能抛出这类异常，必须在方法签名中用 <code>throws</code>声明，或者用 <code>try-catch</code>块进行捕获，否则代码无法通过编译。例如 <code>IOException</code>(输入输出异常)、<code>SQLException</code>(SQL相关异常)</p><p><strong>非受检异常 (Unchecked Exception)<strong>： 主要指 <code>RuntimeException</code>及其子类。它们在</strong>编译时期不强制要求处理</strong>，通常是由程序逻辑错误引发的，应在开发阶段通过代码修正来避免。例如 <code>NullPointerException</code>（空对象异常）、<code>ArrayIndexOutOfBoundsException</code>（数组越界异常）、<code>ArithmeticException</code>（如除以零）</p><h2 id="如何处理异常"><a href="#如何处理异常" class="headerlink" title="如何处理异常"></a>如何处理异常</h2><p>Java提供了 <code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code>关键字来处理异常</p><h3 id="1-捕获异常-try-catch-finally"><a href="#1-捕获异常-try-catch-finally" class="headerlink" title="1. 捕获异常 (try-catch-finally)"></a>1. 捕获异常 (try-catch-finally)</h3><p>基本语法结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>    <span class="hljs-comment">// 可能会发生异常的代码</span><br>} <span class="hljs-keyword">catch</span> (ExceptionType1 e1) {<br>    <span class="hljs-comment">// 捕获并处理特定类型 ExceptionType1 的异常</span><br>} <span class="hljs-keyword">catch</span> (ExceptionType2 e2) {<br>    <span class="hljs-comment">// 捕获并处理特定类型 ExceptionType2 的异常</span><br>} <span class="hljs-keyword">finally</span> {<br>    <span class="hljs-comment">// 无论是否发生异常，最终都会执行的代码块</span><br>    <span class="hljs-comment">// 通常用于释放资源（如关闭文件、数据库连接等）</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>示例：处理数组越界异常</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) { <span class="hljs-comment">// 循环最后一次 i=6 时会越界</span><br>                a[i] = i;<br>            }<br>        } <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) {<br>            System.out.println(<span class="hljs-string">"捕获到数组越界异常: "</span> + e.getMessage());<br>        } <span class="hljs-keyword">finally</span> {<br>            System.out.println(<span class="hljs-string">"这段代码总是会执行。"</span>);<br>        } <span class="hljs-comment">// 在多异常检查中，finally为所有异常提供了统一出口，一般用于关闭资源</span><br>        System.out.println(<span class="hljs-string">"Hello World"</span>); <span class="hljs-comment">// 由于异常被捕获，程序可以继续执行</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="2-声明抛出异常-throws"><a href="#2-声明抛出异常-throws" class="headerlink" title="2. 声明抛出异常 (throws)"></a>2. 声明抛出异常 (throws)</h3><p>在方法签名中使用 <code>throws</code>关键字，声明该方法可能抛出的异常，将异常的处理责任交给方法的调用者。这常用于受检异常（Checked Exception）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-comment">// 可能抛出IOException的代码</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="3-主动抛出异常-throw"><a href="#3-主动抛出异常-throw" class="headerlink" title="3. 主动抛出异常 (throw)"></a>3. 主动抛出异常 (throw)</h3><p>使用 <code>throw</code>关键字在代码中主动抛出一个异常对象（可以是内置异常或自定义异常）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">"除数不能为零"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-try-with-resources（自动资源管理）"><a href="#4-try-with-resources（自动资源管理）" class="headerlink" title="4. try-with-resources（自动资源管理）"></a>4. try-with-resources（自动资源管理）</h3><p>对于实现了 <code>AutoCloseable</code>接口的资源（如 <code>InputStream</code>, <code>OutputStream</code>, <code>Connection</code>等），强烈推荐使用 <strong>try-with-resources</strong> 语句。它可以自动关闭资源，代码更简洁，且不易出错，无需显式编写 <code>finally</code>块来关闭资源</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryWithResourcesExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 资源在try后的括号内声明和初始化，多个资源用分号隔开</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"test.txt"</span>))) {<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) {<br>                System.out.println(<span class="hljs-string">"Line =&gt; "</span> + line);<br>            }<br>        } <span class="hljs-keyword">catch</span> (IOException e) { <span class="hljs-comment">// 这里仍然需要捕获可能发生的IOException</span><br>            System.out.println(<span class="hljs-string">"读取文件时发生异常: "</span> + e.getMessage());<br>        } <span class="hljs-comment">// 无需finally块，br会自动关闭</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>当Java标准异常类无法清晰表达特定的业务逻辑错误时，可以创建自定义异常</p><p><strong>创建自定义异常的最佳实践</strong>：</p><p>通常继承自 <code>Exception</code>（创建受检异常）或 <code>RuntimeException</code>（创建非受检异常）。选择取决于错误性质：是否强制调用者处理</p><p>提供多个构造方法，通常至少包括一个带详细消息（String message）的构造方法，并调用父类构造器</p><p>可以添加自定义字段（如错误码）来提供更丰富的错误信息</p><p><strong>示例：自定义一个非受检的业务异常</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义异常类，继承RuntimeException成为非受检异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsufficientBalanceException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> currentBalance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amountRequired;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InsufficientBalanceException</span><span class="hljs-params">(String message, <span class="hljs-type">double</span> currentBalance, <span class="hljs-type">double</span> amountRequired)</span> {<br>        <span class="hljs-built_in">super</span>(message); <span class="hljs-comment">// 调用父类构造方法</span><br>        <span class="hljs-built_in">this</span>.currentBalance = currentBalance;<br>        <span class="hljs-built_in">this</span>.amountRequired = amountRequired;<br>    }<br><br>    <span class="hljs-comment">// 获取额外信息的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCurrentBalance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> currentBalance;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmountRequired</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> amountRequired;<br>    }<br><br>    <span class="hljs-comment">// 可选：重写toString以提供更详细的错误信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + <br>               <span class="hljs-string">" Current Balance: "</span> + currentBalance + <br>               <span class="hljs-string">", Amount Required: "</span> + amountRequired;<br>    }<br>}<br><br><span class="hljs-comment">// 使用自定义异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> {<br>        <span class="hljs-keyword">if</span> (amount &gt; balance) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsufficientBalanceException</span>(<span class="hljs-string">"余额不足"</span>, balance, amount);<br>        }<br>        balance -= amount;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爱情</title>
    <link href="/posts/love/"/>
    <url>/posts/love/</url>
    
    <content type="html"><![CDATA[<h1 id="一个须臾"><a href="#一个须臾" class="headerlink" title="一个须臾"></a>一个须臾</h1><p>在回家的路上，飞机进入了平流层，灯关很暗，我捧着电子书，用笔戳着平板翻页，这一切都平平静静地发生着，直到我旁边的一个女孩子靠在我的肩膀上睡着了。她的青丝散发着淡淡的香气，呼吸均匀得像潮汐拍岸。我有些慌乱，将电子书切换到夜间模式，竭力让自己的瞳孔适应微弱的亮光，左肩的压力让我有些不自在，但我尽力保持平稳，那是一种很奇妙的感觉，我的肩膀上的重量好像一颗沉入杯中的方糖，在无声中消融。我不敢在平板上写字，生怕惊醒了她睫毛上停驻的整个星空。</p><p>我不想在这里提及什么老掉牙的一见钟情的桥段，这只是发生在地球46亿年的生命中的一个瞬间罢了。也许我在那个时刻突然爱上了这个面容模糊，脾性未明的人，在黑暗中构思着我们的未来，想象着我们一起去图书馆的理想情景。但是随即这种感觉便随飞机的尾气烟消云散。</p><h1 id="白玫瑰背后的刺"><a href="#白玫瑰背后的刺" class="headerlink" title="白玫瑰背后的刺"></a>白玫瑰背后的刺</h1><p>我见过很多仓促且浮躁的“快餐式恋爱”，有人为了某人夸张露骨的打扮怦然心动，却在她的放荡和背叛中懊悔不已：也有人为了迎合“完整的大学”选择抓住一个陌生的背影，最后为自己的冲动买单。<strong>白玫瑰的刺上沾满了血</strong>，但这些故事，像未校准的罗盘，指向了除了永恒之外的所有迷途。</p><p>摄影师总是喜欢将镜头聚焦到两人一见钟情的那一刻，却略去他们相守不离的情节。他们美化相识，淡化相守，造就了我们过于理想而不切实际的憧憬和期待。<strong>然而真正的爱情绝非某个须臾，而是一段需要漫长岁月才能写就的史诗。</strong></p><h2 id="醒来"><a href="#醒来" class="headerlink" title="醒来"></a>醒来</h2><p>飞机开始俯冲着陆，云朵被撕裂成碎片，剧烈的颠簸使她醒来，梦境里美好的星空是如此短暂，须臾间就化为了白昼。我盯着屏幕上的有向图，她收拾着她的东西，谁都没有说话，好像什么都没有发生，又好像这只是一场恍惚的梦。</p>]]></content>
    
    
    <categories>
      
      <category>旅途</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> 数据结构8：图</title>
    <link href="/posts/data_struction_8/"/>
    <url>/posts/data_struction_8/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>图是由顶点的<strong>有穷非空集合</strong>和<strong>顶点之间边的集合</strong>组成的。<br>通记为 G(V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是边的集合<br>V(G) 和 E(G) 通常分别表示图 G 的顶点集合和边集合。</p><p>对于图这种数据结构，不允许没有顶点，但边集可以为空。（点可以是孤立的）</p><p><img src="https://s2.loli.net/2025/05/27/uljhSLsk1bO6HG8.png" alt="image-20250526200457954"></p><h4 id="简单图与多重图"><a href="#简单图与多重图" class="headerlink" title="简单图与多重图"></a>简单图与多重图</h4><p>1.图中不能有指向自身的环</p><p>2.同一条边在图中不能出现两次或以上</p><p>不满足以上两条限制的图称为多重图</p><h4 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h4><p>完全图：具有最多边数的图<br>对于一个具有 n 个顶点的无向完全图，边数量的最大值为 n(n - 1) / 2<br>对于一个具有 n 个顶点的有向完全图，边数量的最大值为 n(n - 1)</p><p><strong>路径和路径长度</strong><br>路径：从一个顶点开始，经过一系列的边到达另外一个顶点形成的顶点序列。<br>路径长度：路径上边的条数<br>回路（环）：起点和终点相同，路径 {0, 3, 1, 0} 是一个回路（环）</p><p><img src="https://s2.loli.net/2025/05/27/1yGrDcMltWVS32i.png"></p><p><strong>简单路径</strong><br>简单路径：如果路径中不出现相同的顶点，则称为简单路径</p><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</p><p><strong>顶点的度</strong></p><p>度：对于无向图，顶点的度指的是与顶点相关联边的数目。<br>入度：在有向图中，对于顶点 v，箭头指向 v 的边的数目。<br>出度：在有向图中，对于顶点 v，从该顶点出发的边的数目。</p><p><strong>度和边的关系</strong></p><p>在无向图中，假设具有 n 个顶点，e 条边<br>图中所有顶点度之和等于边数的两倍<br>对于有向图，所有顶点的出度之和与入度之和相等，弧的数量也相等。</p><p><strong>子图</strong></p><p>就是类似于子集之类的一个定义</p><p><strong>连通图</strong><br>连通：在无向图中，如果从顶点 V 到顶点 w 有路径，则称顶点 v 到顶点 w 是连通的。<br>如果对于图中任意两个顶点都是连通的，则称此图为连通图</p><p><strong>连通分量</strong><br><strong>无向图中的极大连通子图</strong>称为连通分量<br>连通分量为子图<br>子图为连通图<br>连通子图含有极大顶点数<br>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</p><p><strong>强连通图</strong><br>强连通图：在有向图中，对于每一对顶点 v 和 w ，从 v 到 w 和从 w 到 v 都有路径，<br>则称该有向图是强连通图。<br>有向图中的极大强连通子图称为有向图的强连通分量。</p><p><strong>生成树</strong><br>生成树：指含有图中全部顶点的极小连通子树（连通图的<strong>极小连通子图</strong>）<br><strong>注意：包含所有顶点 n，但只有足以构成一棵树的 n-1 条边</strong></p><p><strong>边的权和网</strong><br>在一个图中，每条边可以标注上一个代表某种含义的数值，该数值称为这个边的权值<br>网：边上带的权值的图，也称为带权图</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵（Adjacency Matrix）是图（Graph）的一种存储结构，通过二维数组表示顶点之间的连接关系。其核心原理是将图的顶点和边信息分别用一维数组和二维矩阵存储，适用于描述图的拓扑结构，尤其适合<strong>稠密图</strong>（边数接近顶点数平方）。</p><p><img src="https://s2.loli.net/2025/05/27/UTRLh6mtIZHG97b.png" alt="image-20250527103145031"></p><p>如果有连线在矩阵中就是1表示，如果没有就是0表示</p><p>无向图中一般是关于对角线对称的</p><p>有向图中的矩阵就不是这样</p><p>但是如果是带权值的图</p><p><img src="https://s2.loli.net/2025/05/27/ZsjWRblSOfEr3NP.png" alt="image-20250527110250144"></p><p>两个边之间没有关系在矩阵中表示为0。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表（Adjacency List）是图（Graph）的一种链式存储结构，结合了顺序存储和链式存储的特点，能够高效表示稀疏图并支持动态操作。</p><p>图中构成了四条链表，而链表的头节点就是各个顶点，这四个链表都存放在一维数组中，而第二个元素开始的数据域就是一维数组的元素的索引，所以我们可以使用这种路径来实现图的遍历。</p><p>有时候基于顶点的边不是固定顺序的，比如，下图中V0有指向V1，V2和V3的三条边，那么第一条链表中的第二第三第四元素可以自由交换位置。</p><p><img src="https://s2.loli.net/2025/05/27/yS5oRlcnk2uvtGH.png" alt="image-20250527111402078"></p><p>在有向图中，根据方向我们可以有<strong>逆邻接表</strong></p><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>它和邻接表相反，头节点是终点，后面的元素是起点。</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>十字链表（Orthogonal List）是一种专为<strong>有向图</strong>设计的链式存储结构。</p><p>十字链表有两个结构：<strong>顶点结构</strong>和<strong>边结构</strong></p><p>入边就是“进入该顶点的边\弧\箭头”，出边反之。</p><p>Vex指的是顶点，Tailvex表示弧尾，Headvex表示弧头，后面Headlink表示弧头的指针，taillink表示弧尾的指针</p><p><img src="https://s2.loli.net/2025/05/27/2VUicQpxgNmMZH9.png" alt="image-20250527133314864"></p><p>下面我们讲解一个橙色箭头的意思，根据上文，顶点结构的第二个格子应该是入边的指针，所以我们需要找到”进入”该顶点的弧，并且让该顶点的第二个格子的指针指向它。</p><p><img src="https://s2.loli.net/2025/05/27/TYwvKurpf26DNJ4.png" alt="image-20250527190943882"></p><p>用横向来表达出边的路径，用纵向来表达入边的路径，纵横交错形成了Crossing，也就是<strong>十字链表</strong>。</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><strong>邻接多重表</strong>是专为无向图设计的一种链式存储结构，通过优化邻接表的冗余存储问题，显著提升了空间效率与边操作能力。以下从结构特性、应用场景及对比分析等角度进行详细介绍：</p><p><img src="https://s2.loli.net/2025/05/27/Og7ZeMpfRBibNvQ.png" alt="image-20250527193509055"></p><p>将顶点连接到与他相关的边上，随即将link连接到未涉及的边上。</p><p><img src="https://s2.loli.net/2025/05/27/CDvrHysFlZfQMmA.png" alt="image-20250527195518243"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果你看到这里，<strong>那么这段时间对数据结构的学习算是告一段落了</strong>。按之前的安排，这之后应该还要三个章节，分别是<strong>DFS和BFS</strong>，<strong>Dijkstra最短路径算法</strong>和<strong>拓扑排序</strong>，但是我打算将他放到算法的学习章节中去。</p><p>写下这段文字的时间是六月二号，按道理，我将提前两周开始复习大学的期末考试，祝看到这里的人好运，我们再会。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构7：树与二叉树</title>
    <link href="/posts/data_struction_7/"/>
    <url>/posts/data_struction_7/</url>
    
    <content type="html"><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><p>树是一种非线性数据结构，由 <strong>n（n≥0）</strong> 个有限节点构成具有层次关系的集合。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>结点</strong>：树中的一个独立单元。</p><p><strong>结点的度</strong>：结点拥有的子树数称为结点的度。<br><strong>树的度</strong>：树内各结点度的最大值。<br><strong>叶子</strong>：度为 0 的结点或终端结点。<br><strong>非终端结点</strong>：度不为 0 的结点。<br><strong>双亲和孩子</strong>：结点的子树的根称为该结点的<strong>孩子</strong>，相应地，该结点称为孩子的双亲。<br><strong>层次</strong>：结点的层次从根开始定义，<br>根为第一层，根的孩子为第二层，<br>以此类推。</p><p><img src="https://s2.loli.net/2025/05/25/DWh5wJXvTG6gMsV.png" alt="image-20250523204021005"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（Binary Tree）是 n（ ）个结点<br>所构成的集合，它或为空树（n=0），或为非<br>空树。对于非空树 T：<br>n ⩾ 0<br>（1）有且仅有一个 称为根的结点<br>（2）除根结点以外的其余结点分为两个互<br>不相交的子集 T1 和 T2 ，分别称为 T 的左<br>子树和右子树，且 T1 和 T2 本身又都是二叉<br>树。<br>（3）二叉树每个结点至多只有两棵子树。<br>（4）二叉树的子树有左右之分，其次序不能任意颠倒。</p><p><img src="https://s2.loli.net/2025/05/23/Rac6gBTKHydwQoP.png" alt="image-20250523215612638"></p><h2 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h2><p>二叉树主要有以下几个基本形态：</p><p><img src="https://s2.loli.net/2025/05/23/xFJWIVOsoi6hgYf.png" alt="image-20250523220257631"></p><p>树也是一种数据结构.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">{</span><br>  ElemType data;<br>  TreeNode *lchild;<br>  TreeNode *rchild;<br>  }TreeNode;<br><span class="hljs-keyword">typedef</span> TreeNode* BiTree;<span class="hljs-comment">//给TreeNode类型的指针起了别名为BiTree</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2025/05/25/9OPAeUwEaslZbFc.png" alt="image-20250524201202428"></p><p>类似于用指向表头的指针来代表链表，我们使用指向根结点的指针来代表整个树。</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>对于树的遍历，我们需要使用递归。这一块可能很难理解，可以辅助代码可视化。</p><p><img src="https://s2.loli.net/2025/05/24/fCEWdaqlt1LgYGn.png" alt="image-20250524205550958"></p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>先访问根结点，然后访问左分支上遇到的每一个结点，持续这一过程，直到遇到空结<br>点为止。这时，返回到最近的有右孩子的祖先结点，并从该结点的右孩子开始继续遍历。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(BiTree T)</span> <span class="hljs-comment">//前序遍历</span><br>{<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>{<br><span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, T-&gt;data);<br>preOrder(T-&gt;lchild);   <span class="hljs-comment">//先遍历左子节点再遍历右节点</span><br>preOrder(T-&gt;rchild);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历顺序：**A B D H K E C F I G J **</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先访问根结点，向树的左下方移动，直到遇到空结点为止，然后访问空结点的父结点。接着继续遍历该结点的右子树，如果右子树没的子树可以遍历，那么继续遍历上一层最后一个未被访问的结点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(BiTree T)</span><br>{<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>{<br><span class="hljs-keyword">return</span>;<br>}<br>inOrder(T-&gt;lchild);   <span class="hljs-comment">//顺序不一样了</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, T-&gt;data);<br>inOrder(T-&gt;rchild);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历顺序：**H K D B E A I F C G J **</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>从根结点开始先访问结点的左右儿子，再对该结点进行访问。这就意味着结点的儿子<br>将在该结点之前输出。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(BiTree T)</span><br>{<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>{<br><span class="hljs-keyword">return</span>;<br>}<br>postOrder(T-&gt;lchild);<br>postOrder(T-&gt;rchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, T-&gt;data);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历顺序：**K H D E B I F J G C A **</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构6：表达式求值</title>
    <link href="/posts/data_struction_6/"/>
    <url>/posts/data_struction_6/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><p><strong>C语言表达式求值是一个综合优先级、结合性、类型转换和副作用处理的复杂过程。</strong></p><p>表达式的书写形式有<strong>中缀表达式</strong>和<strong>后缀表达式</strong>两种。</p><p>中缀表达式是人类最常用的数学表达式形式，其特点是<strong>运算符位于两个操作数中间</strong>，后缀表达式将<strong>运算符置于操作数之后</strong>，后缀表达式<strong>使用栈结构</strong>对于计算机具有很高的计算效率。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><code>82/2+56*-</code>是一个后缀表达式。</p><ul><li>数字8入栈，位于栈的底层。</li><li>数字2入栈</li><li>运算符<code>/</code>入栈，以<strong>取栈顶的两个元素，靠近栈底元素为中缀表达式的第一项</strong>为原则执行8/2 == 4</li><li>和4被压入栈中</li><li>数字2入栈</li><li>继续计算直到-</li><li>将最后的元素弹出，返回给输入参数</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构5：栈和队列</title>
    <link href="/posts/Data_struction_5/"/>
    <url>/posts/Data_struction_5/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构4：栈和队列"><a href="#数据结构4：栈和队列" class="headerlink" title="数据结构4：栈和队列"></a>数据结构4：栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈（stack）是限定仅在表尾进行插入或删除操作的线性表。因此对栈来说，表尾端有其特殊含义，称为栈顶（top），相应地，表头端称为栈底（bottom）。不含元素的空表称为空栈。<br>假设 S=(a1, a2, …, an)，则称 a1 为栈底元素，an 为栈顶元素。栈中元素按 a1, a2, …,an 的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按照后进先出的原则进行的。因此，栈又称为后进先出（Last In First Out, LIFO）的线性表。</p><p><img src="https://s2.loli.net/2025/04/05/kLRzrf9y6PuW1pC.png" alt="image-20250405224822698"></p><blockquote><p>类似于手枪的弹匣，最先压进去的子弹是最后打出去的一发。</p></blockquote><p>所以，栈是限制插入和删除操作只能在一个位置进行的表，该位置是表的末端，叫作<br>栈顶（top）。对栈的基本操作有进栈（push）和出栈（Pop），前者相当于插入，<br>后者则是删除最后插入的元素。</p><h2 id="栈的设置和初始化"><a href="#栈的设置和初始化" class="headerlink" title="栈的设置和初始化"></a>栈的设置和初始化</h2><p>一个栈一般需要一个数据域和一个栈指针（用于调用栈里面的元素）。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span> {</span><br>    <span class="hljs-type">int</span> top;<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">10000</span>];<br>    } <span class="hljs-built_in">stack</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initstack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s)</span> {<br>    s-&gt;top = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//设置栈为空</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h2><p>往栈内增加元素类似于把子弹压入弹匣，故名。</p><p>代码实现:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;top == <span class="hljs-number">9999</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈满\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    s-&gt;top++;<br>    s-&gt;data[s-&gt;top] = x;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><p>删除栈内的元素类似于把子弹从弹匣内弹出，故名。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> *x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;top == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈空\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    *x = s-&gt;data[s-&gt;top];<br>    s-&gt;top--;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这会把删除的元素赋予传入参数的指针x中</p><h1 id="栈的链式结构"><a href="#栈的链式结构" class="headerlink" title="栈的链式结构"></a>栈的链式结构</h1><p>我们往往和链表一样，需要动态的内存分配的链式结构。</p><p>一般地，如果你详细阅读我之前的链表笔记，你就能理解链式结构的实现。</p><p>类似地：一个数据域，一个栈指针，一个指针域。</p><p>S是头节点，我们称它为<strong>栈顶指针</strong>，下一个节点就是<strong>栈顶</strong>。</p><p><img src="https://s2.loli.net/2025/04/06/nel7cK6RFiEqxpb.png" alt="image-20250406125858618"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>    <span class="hljs-type">int</span> *data;<br>    <span class="hljs-type">int</span> top;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span> *<span class="hljs-title">next</span>;</span><br>} <span class="hljs-built_in">stack</span>;<br><br><span class="hljs-built_in">stack</span>* <span class="hljs-title function_">init_stack</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">stack</span> *s = (<span class="hljs-built_in">stack</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>));<br>    s-&gt;data = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    s-&gt;top = <span class="hljs-number">-1</span>;<br>    s-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始栈的指针为空</span><br>    <span class="hljs-keyword">return</span> s;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链式结构的压栈"><a href="#链式结构的压栈" class="headerlink" title="链式结构的压栈"></a>链式结构的压栈</h2><p>这里使用了头插法，即新节点插入到链表的头部，也就是栈顶。</p><p>所以，头插法符合栈的结构特点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> x)</span> {<br>    <span class="hljs-built_in">stack</span> *new_s = (<span class="hljs-built_in">stack</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>));<br>    new_s-&gt;data = x;<br>    new_s-&gt;next = s -&gt; next;  <span class="hljs-comment">//如果s是栈顶指针的话，新节点的指针就是指向null</span><br>    s -&gt; next = new_s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链式结构的出栈"><a href="#链式结构的出栈" class="headerlink" title="链式结构的出栈"></a>链式结构的出栈</h2><p>出栈操作类似于链表的从头删除节点，我们通过改变栈顶的元素的指针，使得头节点和新的栈顶连接起来。</p><p><img src="https://s2.loli.net/2025/04/06/F3x78lKhimzB5CP.png" alt="image-20250406130033416"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> *x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;next == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"这个栈为空！\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    *x = s-&gt;next-&gt;data; <span class="hljs-comment">//一样地，会把删除的元素放进传入指针里</span><br>    <span class="hljs-built_in">stack</span> *temp = s-&gt;next;    <span class="hljs-comment">//临时指针</span><br>    s-&gt;next = s-&gt;next-&gt;next;   <span class="hljs-comment">//使得下一个节点成为新的栈顶</span><br>    <span class="hljs-built_in">free</span>(temp);   <span class="hljs-comment">//释放出栈节点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h2><p>没什么好说的，头节点的后继节点的数据域就是栈顶元素。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">get_top</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s, <span class="hljs-type">int</span> *x)</span> {<br>    <span class="hljs-keyword">if</span> (s-&gt;next == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"这个栈为空！\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    *x = s-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="栈和单链表的关系"><a href="#栈和单链表的关系" class="headerlink" title="栈和单链表的关系"></a>栈和单链表的关系</h2><p><strong>单链表的头插法和头删法可以用来实现栈的行为。栈是一种后进先出（LIFO，Last In First Out）的数据结构，而单链表的头插法和头删法正好符合栈的操作特性。</strong></p><ol><li><strong>栈的特性</strong>：<ul><li><strong>后进先出（LIFO）</strong>：最后插入的元素最先被移除。</li><li><strong>主要操作</strong>：<ul><li><code>push</code>：将元素插入栈顶。</li><li><code>pop</code>：从栈顶移除元素。</li><li><code>peek</code>：查看栈顶元素。</li><li><code>isEmpty</code>：检查栈是否为空。</li></ul></li></ul></li><li><strong>单链表的头插法和头删法</strong>：<ul><li><strong>头插法</strong>：将新节点插入到链表的头部。</li><li><strong>头删法</strong>：从链表的头部删除节点。</li></ul></li><li><strong>栈和单链表的映射</strong>：<ul><li>栈的 <code>push</code> 操作对应单链表的头插法。</li><li>栈的 <code>pop</code> 操作对应单链表的头删法。</li><li>栈顶对应单链表的头部。</li></ul></li></ol><p>从这方面来看，栈其实是单链表的一个衍生。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列（queue）是一种先进先出（First In First Out, FIFO）的线性表。它只<br>允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端称为<br>队尾（rear）,允许删除的一端则称为队头（front）。假设队列为 q = (a1, a2, …,<br>an)，那么，a1 就是队头元素，an 就是队尾元素。队列中的元素是按照 a1, a2, …,<br>an 的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在 a1,<br>a2, …, an-1 都离开队列之后，an 才能退出队列。</p><p><img src="https://s2.loli.net/2025/04/06/CSTfqmDHVsctU1W.png" alt="image-20250406131745115"></p><p>我会展示队列的动画，可能有点长。</p><p><img src="https://s2.loli.net/2025/04/06/McpHDsvUrh2OGNZ.gif" alt="QQ录屏20250406134123"></p><h2 id="生成队列和初始化"><a href="#生成队列和初始化" class="headerlink" title="生成队列和初始化"></a>生成队列和初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>{</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-type">int</span> rear;<br>}<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    q-&gt;front= <span class="hljs-number">0</span>;<br>    q-&gt;rear= <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><p>只要队列的队头和队尾相等，就代表队列为空，至于为什么请看上面的动画。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">is_queue_empty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    <span class="hljs-keyword">if</span>(q-&gt;front == q-&gt;rear){<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is empty\n"</span>);<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is not empty\n"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    <span class="hljs-keyword">if</span>(q-&gt;front == q-&gt;rear){<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is empty\n"</span>);<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        q-&gt;front++;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="队列调整"><a href="#队列调整" class="headerlink" title="队列调整"></a>队列调整</h2><p>rear==Max_value的时候不代表队列就是<strong>满的</strong>，如下面这种情况。</p><p><img src="https://s2.loli.net/2025/04/06/edOJUmao3VtQfS5.png" alt="image-20250406135930927"></p><p>所以，我们需要调整队列，我们需要把这一连串的数据往队头移动。</p><p>不可避免地，这会造成一个比较高的时间复杂度。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">queue_full</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q)</span>{<br>    <span class="hljs-keyword">if</span> (q-&gt;frint &gt; <span class="hljs-number">0</span> ){<br>        <span class="hljs-type">int</span> step = q-&gt;rear;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = q-&gt;front; i &lt;= q-&gt;rear; i++){<br>            {<br>                q -&gt; data[i-step] = q -&gt; data[i];    <span class="hljs-comment">//移动数据</span><br>            }<br>            q-&gt;front = <span class="hljs-number">0</span>;<br>            q-&gt;rear = q-&gt;rear - step;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is  full\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span>  <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *q, <span class="hljs-type">int</span> data)</span>{<br>    <span class="hljs-keyword">if</span>(q-&gt;rear == <span class="hljs-number">100</span>){<br>        <span class="hljs-keyword">if</span>(!queue_full(q)){<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    q-&gt;rear++;<br>    q-&gt;data[q-&gt;rear] = data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构4：双向链表</title>
    <link href="/posts/Data_struction_4/"/>
    <url>/posts/Data_struction_4/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构4：双向链表"><a href="#数据结构4：双向链表" class="headerlink" title="数据结构4：双向链表"></a>数据结构4：双向链表</h1><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上次我们讲到了局部有环的单链表。</p><p><a href="https://imgse.com/i/pE626V1"><img src="https://s2.loli.net/2025/04/05/VsFYvybK9Azi6tq.png" alt="pE626V1.png"></a></p><h2 id="循环链表：找出入口和长度"><a href="#循环链表：找出入口和长度" class="headerlink" title="循环链表：找出入口和长度"></a>循环链表：找出入口和长度</h2><p>现在需要你找出一个循环链表的环入口。</p><p>我们的步骤是：</p><ul><li>设定快指针的速度是慢指针的两倍。</li><li>当快慢指针相遇时，慢指针已经走了 k 步，快指针走了 2k 步。</li><li>当快慢指针相遇时，我们已经进到了环中</li><li>现在设立一个新指针指向快指针，使其遍历并记录步数直到与快慢指针相遇，步数就是环长度。</li><li>初始化快慢指针为头指针，然后让快指针前进【环长度】步</li><li>让快慢指针以相同速度前进，直到相遇，相遇点就是入口</li></ul><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">findroundBegin</span> <span class="hljs-params">(Node *head)</span>{<br>    Node *fast = head;<br>    Node *slow = head;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next!= <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//循环找到环的入口</span><br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow){  <span class="hljs-comment">//如果快指针和慢指针相遇，则说明有环</span><br>            Node *p = fast;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(p-&gt; next != slow){<br>                count++;  <span class="hljs-comment">//循环计数,表示环的长度</span><br>                p = p-&gt;next;<br>            }<br>            fast = head;<br>            slow = head;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++){  <span class="hljs-comment">//循环找到环的入口</span><br>                fast = fast-&gt;next;<br>            }<br>            <span class="hljs-keyword">while</span>(fast != slow){  <span class="hljs-comment">//循环找到环的入口</span><br>                fast = fast-&gt;next;  <span class="hljs-comment">//两者的速度同步</span><br>                slow = slow-&gt;next;<br>            }<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"环的入口为：%d\n"</span>, fast-&gt;data);<br>            <span class="hljs-keyword">return</span> slow;<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>链式存储结构的节点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他节点。若要寻查结点的直接前驱、则必须从表头指针出发。换句话说，在单链表中，查找直接后继的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。<br>为克服单链表这种单向性的缺点，可利用双向链表（Double Linked List)。在双向链表的节点中有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><p>节点示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span>{</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> 8<span class="hljs-title">prev</span>,*<span class="hljs-title">next</span>;</span><br>}Node;<br></code></pre></td></tr></tbody></table></figure><p>这就生成了一个节点，该节点有一个数据域和两个指针域。</p><h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2><p><img src="https://s2.loli.net/2025/04/05/SiBWQy2NeZFcO8u.png" alt="image-20250405145646106"></p><p>类似地，插入一个新节点，我们的步骤如下：</p><ul><li>使得新节点的prev指针指向头指针，next指针指向<strong>头指针的后一个节点</strong>。</li><li>使<strong>头节点的后一个节点的prev指针</strong>指向新节点</li><li>使头节点的next指针指向新节点</li></ul><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_head</span><span class="hljs-params">(Node *head,<span class="hljs-type">int</span> data)</span><br>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;prev = head;<br>    new_node-&gt;next = head-&gt;next;<br>    <span class="hljs-keyword">if</span> (head-&gt;next != <span class="hljs-literal">NULL</span>)<br>    {<br>        head-&gt;next-&gt;prev = new_node;<br>    }<br>    head-&gt;next = new_node;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>这个相对于头插法的步骤更简单，但是时间复杂度会比较高：</p><ul><li>找到尾节点，把尾节点的next指针指向新节点</li><li>把新节点的prev指针指向尾节点，next指针指向Null</li></ul><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 尾插法,传参直接传入尾节点。</span><br>Node* <span class="hljs-title function_">insertTail</span><span class="hljs-params">(Node *tail, ElemType e)</span> {<br>    Node *p = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    p-&gt;data = e;<br>    p-&gt;prev = tail;<br>    tail-&gt;next = p;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h2><p>类似于单链表的插入，移动到指定点，然后插入。</p><p>代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insertAtPosition</span><span class="hljs-params">(Node** head, <span class="hljs-type">int</span> position, <span class="hljs-type">int</span> value)</span> {<br>    <span class="hljs-comment">// 创建新节点</span><br>    Node* newNode = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    newNode-&gt;data = value;<br>    newNode-&gt;prev = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果链表为空，直接设置为头节点</span><br>    <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) {<br>        *head = newNode;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-comment">// 如果插入位置为0，直接插入到头部</span><br>    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) {<br>        newNode-&gt;next = *head;<br>        (*head)-&gt;prev = newNode;<br>        *head = newNode;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-comment">// 找到插入位置的前一个节点</span><br>    Node* current = *head;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; count &lt; position - <span class="hljs-number">1</span>) {<br>        current = current-&gt;next;<br>        count++;<br>    }<br><br>    <span class="hljs-comment">// 如果位置超出链表长度，返回错误</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置超出链表长度\n"</span>);<br>        <span class="hljs-built_in">free</span>(newNode);<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-comment">// 插入新节点</span><br>    newNode-&gt;next = current-&gt;next;<br>    <span class="hljs-keyword">if</span> (current-&gt;next != <span class="hljs-literal">NULL</span>) {<br>        current-&gt;next-&gt;prev = newNode;<br>    }<br>    current-&gt;next = newNode;<br>    newNode-&gt;prev = current;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="双向链表和顺序表的对比"><a href="#双向链表和顺序表的对比" class="headerlink" title="双向链表和顺序表的对比"></a>双向链表和顺序表的对比</h2><table><thead><tr><th>比较项目</th><th>存储结构</th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td></td><td>存储空间</td><td>预先分配，会出现闲置或溢出现象</td><td>动态分配，不会出现存储空间闲置或溢出现象</td></tr><tr><td>空间</td><td>存储密度</td><td>不用为表示节点间的逻辑关系而增加额外的存储，存储密度等于 1</td><td>需要借助指针来体现元素间的逻辑关系，存储密度小于 1</td></tr><tr><td></td><td>存取元素</td><td>随机存取，按位置访问元素的时间复杂度为 O(1)</td><td>顺序存取，按位置访问元素时间复杂度为 O(n)</td></tr><tr><td>时间</td><td>插入、删除</td><td>平均移动约表中一半元素，时间复杂度为 O(n)</td><td>不需要移动元素，确定插入、删除位置后，时间复杂度为 O(1)</td></tr><tr><td></td><td>适用情况</td><td>1) 表长变化不大，且能事先确定变化的范围2) 很少进行插入或删除操作，经常按元素位置序号访问数据元素</td><td>1) 长度变化较大2) 频繁进行插入或删除操作</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构3：链表的运用和循环链表</title>
    <link href="/posts/Data_structure_3/"/>
    <url>/posts/Data_structure_3/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构3：链表的运用"><a href="#数据结构3：链表的运用" class="headerlink" title="数据结构3：链表的运用"></a>数据结构3：链表的运用</h1><h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h3><p>链表是数据结构中很重要的一个，为此，我会单开一个章节来记录链表的使用，请不要好高骛远。</p><h2 id="例题一：倒数定位"><a href="#例题一：倒数定位" class="headerlink" title="例题一：倒数定位"></a>例题一：倒数定位</h2><blockquote><p>假设该链表只给出了头指针S。在不改变链表的前提下，请设计一个尽可能高效<br>的算法，查找链表中倒数第k个位置上的结点（k为正整数)。若查找成功，算法输出<br>该节点的data域的值，并返回1；否则，只返回0。</p></blockquote><p>值得注意的是，如果我们一直遍历到链表的末尾，再掉头，无疑会导致极高的时间复杂度。所以</p><p>，我们会使用<strong>快慢指针</strong>的速度差来表示k。比如，k == 3，那么，我们设定两个指针Fast和slow，让Fast先走三步，slow再开始走，那么，当Fast走到最后（Fast指针指向空指针）时，slow的位置就是Fast<strong>往前三步</strong>的节点。</p><p><img src="https://s2.loli.net/2025/04/04/IB8pkV7UKvNeMRd.png" alt="image-20250404165404424"></p><p>所以，具体的代码实现是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">findNodeFS</span><span class="hljs-params">(Node *L, <span class="hljs-type">int</span> k)</span><br>{<br>    Node *fast = L-&gt;next;<br>    Node *slow = L-&gt;next;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    {<br>        fast = fast-&gt;next;<br>    }<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)<br>    {<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"倒数第%d个节点值为：%d\n"</span>, k, slow-&gt;data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 查找成功返回1</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="例题二：共同后缀"><a href="#例题二：共同后缀" class="headerlink" title="例题二：共同后缀"></a>例题二：共同后缀</h2><blockquote><p>假定采用带头节点的单链表保存单词，当两个单问有相同的后缀时，则可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示。</p></blockquote><blockquote><p><img src="https://s2.loli.net/2025/04/04/wy8Aav4o7S2sFiI.png" alt="image-20250404200046663"></p></blockquote><blockquote><p>设str1和str2分别指向两个单词所在单链表的头节点，请没计一个时间上尽可能高效的算法，找出由Sr1和str2所指向两个链表共同后缀的起<br>始位置（如图字符i所在结点的位置p)。</p></blockquote><p><strong>这里用哈希表可能更好，但是我还没学到。</strong></p><p>所以，每个链表都有一个相同的后缀，后缀的长度是一定的，所以，我们获取两个链表的长度，他们之差就是后缀的长度，再用<strong>快慢指针</strong>就可以定位到共同后缀的第一个字母了。</p><p><img src="https://s2.loli.net/2025/04/04/en914zBtDJxEaFw.png" alt="image-20250404220225054"></p><h2 id="例题三：绝对值替换"><a href="#例题三：绝对值替换" class="headerlink" title="例题三：绝对值替换"></a>例题三：绝对值替换</h2><blockquote><p>用单链表保存 n 个整数，现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的结点。</p></blockquote><p>我们可以设置一个长度大于<code>n+1</code>（n个整数加上一个数据域为空的头节点就是n+1）的数组a，并将其初始化为0。然后，遍历整个链表，设置条件判断（这里说的date都是实际链表中的数据域的绝对值）：<strong>如果a[date]==0,将其设置为1，如果a[date] == 1，说明该date已经出现过了，就删除该节点</strong>，这就实现了ACM中类似的<strong>打表操作</strong>。遍历到末尾时，执行完毕。</p><p><img src="https://s2.loli.net/2025/04/04/M2tnBNsVv8ZODGx.png" alt="image-20250404220211050"></p><h2 id="例题四：反转链表"><a href="#例题四：反转链表" class="headerlink" title="例题四：反转链表"></a>例题四：反转链表</h2><blockquote><p>给你一个单链表，要求你反转链表方向。</p></blockquote><p>首先，我们需要三个指针，指针first指向NULL，指针Second指向头节点，指针Three指向<strong>头节点之后的一个节点</strong>，然后，只要Second的指针域不为空指针，将Second的指针域指向first，<strong>然后将first指向second，将second指向three</strong>，黑体操作就实现了操作器的移动。直到末尾，我们的反转工作就完成了。</p><p><img src="https://s2.loli.net/2025/04/04/iOBSArZU3DezfL6.png" alt="image-20250404220627277"></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表<br>中最后一个节点的指针域指向头节点，整个链表形成一个环。</p><p>循环链表的判别条件是：<code>P-&gt; != HEAD</code></p><p>但是实际使用中往往不是纯的环，可以是这样的结构：</p><p><img src="https://s21.ax1x.com/2025/04/04/pE626V1.png" alt="image-20250404224200811"></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构2：顺序表与链表</title>
    <link href="/posts/Data_Structure_linked_list/"/>
    <url>/posts/Data_Structure_linked_list/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构2"><a href="#数据结构2" class="headerlink" title="数据结构2"></a>数据结构2</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由<code>n(n&gt;=0)</code>个数据特性相同的元素构成的有限序列，称为线性表。</p><p><code>n == 0</code>时，称为空表。</p><p>对于头一个元素，我们称为“<strong>头节点</strong>”，对于最后一个数据元素“<strong>尾节点</strong>”。</p><p>除了头节点之外，每个元素的前一个元素，叫做“<strong>前驱</strong>”。</p><p>除了尾节点，每个元素的后一个元素叫做“<strong>后驱</strong>”。</p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用一组连续的内存单元依次存储线性表的各个元素，也就是说，逻辑上相邻的元素，实际的物理存储空间也是连续的。</p><p>接下来，我们会构建一个顺序表并且逐步实现“<strong>增删改查</strong>”。</p><p>我们构建一个顺序表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span></span><br><span class="hljs-class">{</span><br>    <span class="hljs-type">int</span> *date;<br>    <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><br>};<br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> date)</span><br>{<br>    l-&gt;date[l-&gt;length] = date;   <span class="hljs-comment">//使用下标来像使用数组一样使用指针是被允许的</span><br>    l-&gt;length++;<br>}<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> {<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">l</span>;</span><br>    add(&amp;l, <span class="hljs-number">20210101</span>);<br>    add(&amp;l, <span class="hljs-number">20210102</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>该代码实现了一个简易的<strong>顺序表</strong>，且配置了<strong>尾部增加</strong>的功能，但是我们往往只需要在中间插入某个元素，可以这么做：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insertElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> date)</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l-&gt;length - <span class="hljs-number">1</span>; i &gt;= index; i--) <br>    {<br>        l-&gt;date[i + <span class="hljs-number">1</span>] = l-&gt;date[i];  <span class="hljs-comment">//这会把待插入元素之后的元素全部往后挪动一个单位。</span><br>    }<br>    l-&gt;date[index] = date;     <span class="hljs-comment">//把输入元素插入到表中</span><br>    l-&gt;length++;               <span class="hljs-comment">//长度更新</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果是在末尾插入，无疑其时间复杂度是最低的，在头节点插入是最大的。</p><p>类似地，我们能够写一个函数实现<strong>删</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> index)</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; l-&gt;length - <span class="hljs-number">1</span>; i++)<br>    {<br>        l-&gt;date[i] = l-&gt;date[i + <span class="hljs-number">1</span>];<br>    }<br>    l-&gt;length--;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在删的基础上修改，就得到了<strong>改</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">changeElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> date)</span><br>{<br>    l-&gt;date[index] = date;<br>}<br></code></pre></td></tr></tbody></table></figure><p>从date[0]开始查找，到length结束，就是<strong>查</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">seekElement</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *l, <span class="hljs-type">int</span> date)</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l-&gt;length; i++)<br>    {<br>        <span class="hljs-keyword">if</span> (l-&gt;date[i] == date)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Element found at index %d\n"</span>, i);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Element not found\n"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>顺序表有很多不方便使用的地方，说白了<strong>，他就是一个套壳的数组。</strong>所以，我们使用了一种链式结构-链表。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>线性表链式存储结构的特点是：<strong>用一组任意的存储单元存储线性表的数据元素</strong>（这组存储单元可以是连续的，也可以是不连续的)。<br>为了表示每个数据元素a与其直接后继数据元素a[i+1]之间的逻辑关系，对数据元素a[i]来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置)。这两部分信息组成数据元素a的存储映像，称为<strong>节点(node)<strong>。<br>结点包括两个域：其中存储数据元素信息的称为</strong>数据域</strong>；存储直接后继存储位置有域称为<strong>指针域</strong>。指针域中存储的信息称作指针或链。</p><p><img src="https://s2.loli.net/2025/04/03/3C7TGKVYlEwgsMO.png" alt="061b5ffce79596f4445207f850c0db6e"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span>{</span>  <span class="hljs-comment">//定义节点</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>}Node;<br><br><br>Node *<span class="hljs-title function_">init</span><span class="hljs-params">()</span>{<br>    Node *head = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    head-&gt;data = <span class="hljs-number">0</span>;    <span class="hljs-comment">//数据域为0</span><br>    head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域为空指针</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    Node *<span class="hljs-built_in">list</span> = init();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链表的延长"><a href="#链表的延长" class="headerlink" title="链表的延长"></a>链表的延长</h2><p>原理：前一个节点的指针指向新插入的节点，使新节点的指针指向<strong>前一个节点原来指向的节点。</strong></p><p><img src="https://s2.loli.net/2025/04/03/X9MRmfDorgd6N1Q.png" alt="image-20250403214812079"></p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>头插法指的是每次都在头节点后面一个位置插入新的数据节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data; <span class="hljs-comment">//引入传入参数</span><br>    new_node-&gt;next = head-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原链表的头节点的指针域</span><br>    head-&gt;next = new_node;  <span class="hljs-comment">//原链表的头节点的指针域指向新节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这会使得每个插入的结构体都处于<strong>头节点的背后</strong>，从而免去了<strong>数组和顺序表</strong>的<strong>元素移动</strong>这一步骤，执行效率快很多。</p><h3 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">list_print</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;   <br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//只要不是空指针，就一直循环</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>        p = p-&gt;next;   <span class="hljs-comment">//指针指向下一个节点</span><br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>尾插法总是在链表的尾部插入新节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_tail</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Node *p = head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//该循环用于找到最后一个节点</span><br>        p = p-&gt;next;<br>    }<br>    p-&gt;next = new_node;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h3><p>我们在特殊情况需要在某两个节点中插入一个新节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//初始化为空指针，防止出错</span><br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到插入位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    new_node-&gt;next = p-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原节点的指针域</span><br>    p-&gt;next = new_node;  <span class="hljs-comment">//原节点的指针域指向新节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>原理是让被删除节点的前一个节点直接指向被删除节点的后一个节点，<strong>链</strong>就是自动排除被删除元素。</p><p><img src="https://s2.loli.net/2025/04/03/CPkFQUfRYxI7D5v.png" alt="image-20250403215033701"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos)</span>{<br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到删除位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    Node *del_node = p-&gt;next;  <span class="hljs-comment">//找到要删除的节点</span><br>    p-&gt;next = del_node-&gt;next;  <span class="hljs-comment">//原节点的指针域指向要删除节点的下一个节点</span><br>    <span class="hljs-built_in">free</span>(del_node);  <span class="hljs-comment">//释放要删除的节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="释放所有节点"><a href="#释放所有节点" class="headerlink" title="释放所有节点"></a>释放所有节点</h3><p>释放，指的是free，指的是将节点占用的堆内存解放出来。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">free_list</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//如果不是尾节点，就一直free下去。</span><br>        Node *temp = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>    }<br>    <span class="hljs-built_in">free</span>(head);  <span class="hljs-comment">//释放头节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span>{</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>}Node;<br><br><br>Node *<span class="hljs-title function_">init</span><span class="hljs-params">()</span>{<br>    Node *head = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    head-&gt;data = <span class="hljs-number">0</span>;    <span class="hljs-comment">//数据域为0</span><br>    head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域为空指针</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data; <span class="hljs-comment">//引入传入参数</span><br>    new_node-&gt;next = head-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原链表的头节点的指针域</span><br>    head-&gt;next = new_node;  <span class="hljs-comment">//原链表的头节点的指针域指向新节点</span><br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">list_print</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;   <br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//只要不是空指针，就一直循环</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>        p = p-&gt;next;   <span class="hljs-comment">//指针指向下一个节点</span><br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//新节点的指针域为空指针</span><br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到插入位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    new_node-&gt;next = p-&gt;next;  <span class="hljs-comment">//新节点的指针域指向原节点的指针域</span><br>    p-&gt;next = new_node;  <span class="hljs-comment">//原节点的指针域指向新节点</span><br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_list</span><span class="hljs-params">(Node *head)</span>{<br>    Node *p = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//循环释放所有节点</span><br>        Node *temp = p;<br>        p = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>    }<br>    <span class="hljs-built_in">free</span>(head);  <span class="hljs-comment">//释放头节点</span><br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> pos)</span>{<br>    Node *p = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos<span class="hljs-number">-1</span>; i++){  <span class="hljs-comment">//循环找到删除位置的前一个节点</span><br>        p = p-&gt;next;<br>    }<br>    Node *del_node = p-&gt;next;  <span class="hljs-comment">//找到要删除的节点</span><br>    p-&gt;next = del_node-&gt;next;  <span class="hljs-comment">//原节点的指针域指向要删除节点的下一个节点</span><br>    <span class="hljs-built_in">free</span>(del_node);  <span class="hljs-comment">//释放要删除的节点</span><br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert_tail</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> data)</span>{<br>    Node *new_node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_node-&gt;data = data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Node *p = head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!= <span class="hljs-literal">NULL</span>){  <span class="hljs-comment">//该循环用于找到最后一个节点</span><br>        p = p-&gt;next;<br>    }<br>    p-&gt;next = new_node;<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    Node *<span class="hljs-built_in">list</span> = init();<br>    insert(<span class="hljs-built_in">list</span>, <span class="hljs-number">2</span>);<br>    list_print(<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：算法时间复杂度</title>
    <link href="/posts/Data_Structure_Algorithm_Time_Complexity/"/>
    <url>/posts/Data_Structure_Algorithm_Time_Complexity/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://s2.loli.net/2025/03/30/c1tjGiXahSgAHD7.png" alt="image-20250330164232582"></p><p><img src="https://s2.loli.net/2025/03/30/VaYd7XsElw6R1om.png" alt="image-20250330164410787"></p><h2 id="虚拟内存地址"><a href="#虚拟内存地址" class="headerlink" title="虚拟内存地址"></a>虚拟内存地址</h2><p>内存条、显卡、各种适配卡都有其各自的存储地址空间。<br>操作系统将这些设备的存储地址空间抽象成一个巨大的一维数组空间。<br>对于内存的每一个字节会分配一个32位或64位的编号，这个编号称为内存地址。</p><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>C程序编译后，会以三种形式使用内存：</p><h4 id="静态全局内存"><a href="#静态全局内存" class="headerlink" title="静态全局内存"></a>静态全局内存</h4><p>静态声明的变量和全局变量使用这部分内存，这些变量在程序开始运行时<br>分配，直到程序终才消失。</p><h4 id="自动内存（栈内存"><a href="#自动内存（栈内存" class="headerlink" title="自动内存（栈内存)"></a>自动内存（栈内存)</h4><p>函数内部声明的变量使用这部分内存，在函数被调用时才创建。</p><h4 id="动态内存（堆内存"><a href="#动态内存（堆内存" class="headerlink" title="动态内存（堆内存)"></a>动态内存（堆内存)</h4><p>根据需求编写代码动态分配内存，可以编写代码释放，内存中的内容直到<br>释放才消失。</p><p>在C语言中，我们需要使用<code>malloc函数</code>实现动态分配内存，他会从堆内存中选取一片空间，并返回这片空间的指针。该函数传入的参数是需要的空间体积。</p><p>完了需要使用free来释放内存</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> {<br>    <span class="hljs-type">char</span> *s;<br>    s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)); <br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">"Hello"</span>); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);  <br>    <span class="hljs-built_in">free</span>(s);         <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为了避免计算错误，我们通常使用<code>sizeof</code>操作符来确保分配的内存大小正确。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>也称渐近时间复杂度，T(n)=O(f(n))<br>随着问题规模n的增大，算法执行时间和增长率和f(n)增长率成正比。</p><p>程序运行的总时间主要与两点有关，执行每条语句的耗时和每条语句的执行效率</p><p>由于语句的执行要由源程序翻译成目标代码，目标代码经装配再执行，因此语句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等)密切相关的。所以，所谓的算法分析并非实际执行所需时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息。</p><h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>时间频度并不是单纯指循环执行次数或条件判断次数，而是指算法中某个基本操作的总执行次数。具体来说：</p><ul><li>如果基本操作是循环体内的计算，时间频度就是循环体的执行次数。</li><li>如果基本操作是条件判断，时间频度就是条件判断的执行次数。</li><li>如果基本操作是某种组合操作（如循环和判断的组合），时间频度就是这些操作的总执行次数。</li></ul><p><img src="https://s2.loli.net/2025/04/01/hFr1XApiw6Gntou.png" alt="image-20250331141248103"></p><p>计算频度指的是代码执行的次数，最外层循环需要在执行<code>n</code>次之后在做一次 (i ==  n)的判断，所以执行频度为n+1，但是外层循环在最后一次判断不会通过，所以内层第一循环不会执行，所以内层循环为<code>n</code>次。</p><p><img src="https://s2.loli.net/2025/04/01/ZMrfsKa6ABmj2Py.png" alt="1.png"></p><p>所以，F(n) = 各层循环的计算频度的和。取得n的最高次幂为M</p><p><img src="https://s2.loli.net/2025/04/01/42JVcyXQWFZOn6q.png" alt="image-20250331143101268"></p><p>上述代码中如果<code>n == 0</code>，那么只会进行一次判断，所以 F(n) = 1，T(n) = O(1)</p><p>如果n很大很大，时间复杂度为1。</p><p><strong>最好时间复杂度</strong>：算法在最好情况下的时间复杂度。<br><strong>最坏时间复杂度</strong>：算法在最坏情况下的时间复杂度。<br><strong>平均时间复杂度</strong>：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计<br>量的加权平均值。<br>对算法时间复杂度的度量，通常只讨论算法在最坏情况下的时间复杂度，<br>即分析在最坏情况下，算法执行时间的上界。</p><h3 id="对数的时间复杂度"><a href="#对数的时间复杂度" class="headerlink" title="对数的时间复杂度"></a>对数的时间复杂度</h3><p><img src="https://s2.loli.net/2025/03/31/iNaXrYRkWyGB3bl.png" alt="image-20250331144619221"></p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度主要用来描述某个算法对应的程序想在计算机上执行，除了用来存储代码和输入数据的内存空间外，还需要额外的空间。</p><h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型 ADT"></a>抽象数据类型 ADT</h2><p>ADT是一种编程概念，用于定义数据的类型及其操作，而不涉及具体实现细节。它提供了一种将数据的逻辑表示与物理实现分离的方法，从而使程序更具可维护性和可扩展性。<br>在C语言中，ADT通常通过结构体和函数的结合来实现。结构体用于定义数据的类型，而函数用于操作这些数据。通过这种方式，程序员可以隐藏数据的内部结构，仅暴露出操作数据的接口。</p><p><strong>说白了，就是java当中的抽象类，是C++ 中的自定义类。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次去医院的思考</title>
    <link href="/posts/think_to_hospital/"/>
    <url>/posts/think_to_hospital/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次去医院的思考"><a href="#记一次去医院的思考" class="headerlink" title="记一次去医院的思考"></a>记一次去医院的思考</h1><p>周三，一个没课的下午，我前往医院看望W，在医院漫长的等待的过程中，我无时无刻忍受着令人作呕的药水味，还有前台电话不绝的响声和护士长的对话声。来来往往的人大多年纪很大，岁月的风在他们脸上吹过，留下阵阵涟漪，他们带着泛黄的电饭锅，刚买的方便面，老旧的热水瓶，推着自己的挚爱亲朋走向病房。<br>我和W的朋友一路奔走，从2号楼到5号楼，期间经过了4次电梯，在医院宽大的特制电梯时，我们往往和一些坐在轮椅上的病人，甚至是躺在转运床上的病人处于同一班电梯，有一个白发苍苍的老人，他无力地咳嗽，有气无力地呼吸。他们依靠挂在一旁的氧气瓶，延续着仅存的生命。</p><blockquote><p>我们每个人都会有这么一天的。</p><p>真正严肃的哲学问题只有一个,那就是自杀。</p></blockquote><p>死亡不是生命的BUG，他是生命的预置程序。磨损的物理结构，老化的胶原蛋白，就已经表明了生命的局限。任何生命都有黄昏之时，但是我们总是在害怕死亡。</p><p>我们或许无法选择死亡的时间与方式，但可以选择如何填充有限的生命。当一位HIV患者从绝望中学会接纳疾病、重新定义生活时，他领悟到生命的珍贵不在于长度，而在于为每个瞬间赋予意义。这让人想起余华在《活着》中的洞见：活着本身就是目的，无需附加宏大的意义。那些在医院走廊里虔诚祈祷的人们，那些在手术室外紧握的双手，都在用最朴素的方式诠释着存在的本质——即便躯体衰败，对爱与希望的渴望永不熄灭。</p><p><img src="https://s2.loli.net/2025/03/19/9AIQJ3Hi8k1T2Zd.jpg"></p><blockquote><p>医院的墙壁比教堂聆听过更多虔诚的祈祷，机场比婚礼殿堂见证了更多真挚的亲吻。</p></blockquote><p>这些祈祷从不关于永生，而是关于如何让存在的每一刻都迸发出尊严的火花，关于如何让至爱之人留在身边的每一面都在记忆中留下最深刻的烙印，关于如何在时间的洪流中留下自己所爱的一切。或许就是生命最深刻的悖论：承认死亡的必然，反而让我们更炽热地拥抱当下。</p><p>写到这里，也许我们走向人生的终点，能够多一份从容和无悔。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《战争之王》：必须存在的恶魔</title>
    <link href="/posts/Lord_of_War/"/>
    <url>/posts/Lord_of_War/</url>
    
    <content type="html"><![CDATA[<h2 id="矛盾与荒谬并行的世界"><a href="#矛盾与荒谬并行的世界" class="headerlink" title="矛盾与荒谬并行的世界"></a>矛盾与荒谬并行的世界</h2><blockquote><p> “可能对你来说我是一个恶魔，但不幸的是，我是一个必须存在的恶魔。”              ——尤里</p></blockquote><p>​       尤里的发迹史堪称全球化时代的资本寓言。从基辅餐馆的潦倒移民到掌控全球地下军火贸易的”战争之王”，他的成功轨迹完美契合新自由主义经济法则。几十本护照和假身份帮助他在边境畅通无阻；把武装直升机的武器和本体分开运输，就成了<strong>“人道主义”</strong>救援直升机；面对到来的国际刑警，自己的船名可以随时随地变换；赶上了冷战结束的黄金时代，他立马将那些没有敌人的优良武器收入囊中，从简易的AK47到厚重的装甲车，他是这些穷途末路的将军最好的生意伙伴，也是非洲军阀最好的供应商。</p><p>​       很显然，尤里背后的大权加冕的大人物不想放弃这位<strong>干净利索</strong>的棋子，这就是为什么最后的尤里在铁证如山的情况下仍不会在军事法庭待上一秒。而这些大人物，可能上一秒还在联合国会议上慷慨激昂地控诉着战争俘虏受到了非人道的虐待，发誓要为非洲的战乱和贫穷负责，下一秒就默许自己的手下继续这场黑暗且宏伟的地下军火交易。因为他们需要战争，而目的可以是五花八门的。</p><blockquote><p>我们需要战争，而不需要敌人。</p></blockquote><p>​     战争可以被用来解决国内供大于求的问题，可以将人民的矛头不再对准统治阶级，也可以使得小国愿意为军火拿出自己几十年来积累的财富，而这些财富大多流入了<strong>”政治家“</strong>及其背后资本的腰包。这就是这个世界的矛盾所在，每个掌权者都想让世界更好，但在那之前，更重要的是不计手段地来进行财产转移，让自己的国家更富有，强大，最后是霸权。所以像尤里这样的恶魔必不可少，一旦他良心发现，<strong>就会有下一个更彻底的恶魔替代他。</strong></p><h2 id="满腔热血无法抵抗时代的洪流"><a href="#满腔热血无法抵抗时代的洪流" class="headerlink" title="满腔热血无法抵抗时代的洪流"></a>满腔热血无法抵抗时代的洪流</h2><p>​     影片中，国际刑警杰克没有尤里说的<strong>”价码“</strong>，他秉持自己的正义，坚持合法地惩罚尤里。可就是这么一个尽职尽责的好警察，最后在强权之下也没有任何办法。他的顶头上司，美国总统一直是这种交易的常客，他需要尤里这样的人才武装非洲的军阀，从暗中操作的战争中赚得盆满钵满。</p><blockquote><p>要是没有我，他们根本无法打一场像样的战争。                                        ——尤里</p></blockquote><p>​    杰克最后可能会愤怒，会感叹于世间的不公，甚至威胁辞职，但这些都不重要了，因为<strong>个体善恶在系统惯性面前微不足道。</strong>尤里和他的博弈，赌注从来都不是下半生的自由，而是仅存的<strong>良心</strong>。在政客的眼中，杰克的职责就在于努力去解这个顶头上司留下的谜题，而揭开谜底的过程，能够让世界看到包括<strong>联合国五常</strong>在内的联合国对<strong>维护世界和平的决心</strong>，<strong>至少看起来是这样。</strong></p><blockquote><p><strong>在系统性暴力中，个体的“生存智慧”恰恰是对战争机器的被动妥协</strong>。</p></blockquote><p>​      影片真正的恐怖不在于展现多少战争残酷，而在于揭示我们早已深陷其中却不自知的生存真相——在资本全球化的精密系统里，相比于成为战争的牺牲品，我们每个人都倾向于成为某种意义上的**”战争之王”**。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
      <tag>世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024这一年</title>
    <link href="/posts/2024/"/>
    <url>/posts/2024/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我的2024，被高考泾渭分明地划分为了两半。</p><h2 id="1-6月"><a href="#1-6月" class="headerlink" title="1-6月"></a>1-6月</h2><p>我有个特点，一些令我感到痛苦的经历不会在我的记忆中存在太久。</p><p>1月到6月，我已经记得不大清的，我直接的那段时间太阳很大，血红的标语贴的到处都是，我们披坚执锐，在数不清的模拟中挣扎，在无数次西西弗斯一般的努力中等待时间流逝，在那段时间，有因为一句无聊的笑话引发的快乐，有模拟考试名次渐进的喜悦，有深夜备战的痛苦，我只记得那时，全家人的期望都在我身上，我只记得我必须全力以赴。</p><p>那个时期的自己有极度可怖的自律，献祭自己的心理和生理健康来夺取那几分，脑子里只知道<strong>卷</strong>，卷得天昏地暗，卷的不知疲倦，用尽了今天，又把希望寄托于明天。</p><blockquote><p>语文应该是一门很浪漫的学科，如果不是为了赶路，为了稳定的得分，也许我的文笔看起来就不会这么奇怪，可是，现在我记得的只有并列式和层进式的可悲的议论结构了。</p></blockquote><p>在自信与努力并存的等待中，我们迎来了最后的高考，不幸的是，这是我的死地。</p><p>我记不大清查分时的情景，我只记得我看到屏幕上的“675”（赋分制，对应大陆分数大概630左右），那时候脑子里只剩下震惊和麻木，随即就是懊悔。</p><p>后来，父母没对我多说什么，只是一个劲地安慰说没事，但我知道自己已经失败了，彻彻底底的失败。</p><blockquote><p>我们失败了。失败的意义就在于我们让所有人都感到失望，包括我们自己。    ——《超脱》</p></blockquote><p>后来，我在爸爸的手机里发现了他发给妈妈的语音，内容我记得不大清了，好像是说我三模考的一次比一次好，结果把最差的一次留给了高考。我麻木的思维在那是已经没有知觉了，只有我的心知道某个地方悄悄地碎掉了。</p><blockquote><p>我不大想写下去了，原谅我。</p></blockquote><p>抱着这般粉饰太平的冷静与坦然，这一切过的还算舒心。</p><h2 id="身后事"><a href="#身后事" class="headerlink" title="身后事"></a>身后事</h2><p>六月十八号，我们在家里给母亲庆祝生日，也许父母不是不喜欢吃蛋糕，他们喜欢的是过生日时的氛围和被给予的孩童时期的片刻的自由，至少那一个晚上，是属于我的母亲的。</p><p>那个蛋糕价格不低，可是父亲为了让她过上自打养小孩以来的第一次生日，倒也顾不上价格，那个晚上，天上的星旋转着，我们在家中欢庆，快乐且温暖。</p><p>七月二十九日，“接受”现实的我收到了杭电的通知书，那时我们全家都很高兴，可是只有我知道我的心有一处是空缺的，是破碎不堪的。</p><p>八月二日，我随母亲回广西。</p><p>？月？日，我记不清。</p><p>我把自己锁在这异国他乡的房间里，声嘶力竭地对着墙大吼，把所有的呼唤置之门外，把手机关机，让这个空间中只有一个手足无措的孩子的挣扎。当时占据头脑的不是愤怒，而是恐惧，是惶惶不可终日的痛苦，像是被宣判了死刑的囚徒，背着十字架在无人的荒漠中濒临绝望。</p><p>我记不清原因。</p><p>后来，这一切都结束了，时间按部就班地来到了开学的日子，任凭我如何懊悔。</p><p>我独自一人搭上了前往杭州的飞机，心里全是惊喜，不知道未来的生活是怎样的。</p><p>到了学校，我看见了高耸的楼宇，我看见了大城市的车水马龙，我看见了一个新的开始。</p><p><a href="https://imgse.com/i/pAxainS"><img src="https://s21.ax1x.com/2024/12/29/pAxainS.jpg" alt="pAxainS.jpg"></a></p><blockquote><p>拍摄于某个平静的下午</p></blockquote><p>………..</p><p>又过了几个月，我已记不清是什么时候。</p><p>我发现，大学的生活远远不如我所期待，“考上大学就轻松了”是一个彻头彻尾的谎言，所以，如果我看见有人旷课熬夜打游戏，我反倒认为这是正确的，他只不过是在实践自己在无数个地狱中赖以生存的信念罢了。高数和线代，两座大山，再加上教师难以接受的教学风格，作为大一新生的我实在很难跟上，我只记得学的懵懵懂懂，又带着这点一知半解参加了期中考，以68和77的成绩草草收场。</p><p>我在网上看了很多信息，知道了当前就业形势很不好，经济腾飞的副作用在这个时期显现出来。考研吗？现在学历贬值的厉害，统考人数不断下滑，机关对考研生不再感冒，考研之后到底是深造还是在啃老呢？卷竞赛吗？面对一群自从高中就有信息奥基础的人来说，我有任何优势吗？就这么扎扎实实地学习然后本科就业？学校教的过时的知识让我没了说话的底气。</p><blockquote><p>抱着这种迷茫，我一路写到了这里。</p></blockquote><ul><li>我试图让我的大学生活变得和高三一样，我试图复制应试背景下的成功。</li><li>我试图让我表面上的勤奋掩饰我迟于改变的懒惰。</li><li>我试图让曾经的机器取代现在的自己。</li></ul><p>翻找我的日记本，记忆如潮水般涌来。</p><p>我看见了曾经那个拥有无限可能的自己，他想参加OI而不带功利，不计后果，他想为心爱之人吹奏一支曲子而不在乎那人是否已经离去，他想……我看见在被高考招安之前的自己，像是一个燃烧的勇士，即使公主已经死去，他仍要把利剑刺入恶龙的咽喉。他是那么的意气风发，无所顾忌。</p><blockquote><p>我看见特工正处在明媚的阳光下和同事野餐，我看见他为了队里的新队员吹奏新曲，可我只发现我身处一片阴影之中，我与他样貌相似但没有色彩，我只是他的影子。</p></blockquote><p>高考已然成为历史，我也应该放过我自己，放过那个在缺氧环境下窒息的苦行僧。</p><p>我要重新学会畅快地呼吸，重新认识世界上的一切，重新和自己相识。</p><p>我要找回那个意气风发，从容不迫的自己。</p><blockquote><p>祝我好运</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫雷开发笔记</title>
    <link href="/posts/minesweeper/"/>
    <url>/posts/minesweeper/</url>
    
    <content type="html"><![CDATA[<h1 id="扫雷开发笔记"><a href="#扫雷开发笔记" class="headerlink" title="扫雷开发笔记"></a>扫雷开发笔记</h1><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://s2.loli.net/2024/12/12/I9y8N2B4luAZMUC.png" alt="扫雷游戏开发(1)"></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://s2.loli.net/2024/12/13/bCRM3mutWTE7QV1.png" alt=".png"></p><h2 id="难度设置"><a href="#难度设置" class="headerlink" title="难度设置"></a>难度设置</h2><p>简单：9*9 10雷</p><p>中级： 16*16 40雷</p><p>困难 ： 20*20  70雷</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>见<a href="https://github.com/Dr-WillMos/Minesweeper">Github仓库</a>，如果喜欢可以点个Star。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们使用了二位数组来实现扫雷，因Easyx库使用了C++的库且C++已适配绝大部分C语言的语法，所以我们提交的是.cpp文件，并封装了exe文件，可以直接双击运行。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>使用IDE：VS 2022</p><p>项目属性：使用多字节字符集</p><p>C语言标准：C89</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;easyx.h&gt;</span>  <span class="hljs-comment">// EasyX图形库，安装方式请见官网文档</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span>       <span class="hljs-comment">//计时库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span> <span class="hljs-comment">//windows的库，用于获取时间戳</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ROW 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_COL 20       <span class="hljs-comment">//以最大雷区作为常量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMG_SIZE 40     <span class="hljs-comment">// 这个数字用于实现从二维数组到游戏窗口的坐标转化</span></span><br><br>IMAGE img[<span class="hljs-number">13</span>];           <span class="hljs-comment">// 以数组的方式引入图片</span><br><span class="hljs-type">int</span> mine[MAX_ROW + <span class="hljs-number">2</span>][MAX_COL + <span class="hljs-number">2</span>];  <span class="hljs-comment">//+2是为了解决边缘问题</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mx;<br><span class="hljs-type">int</span> my;<br><span class="hljs-type">int</span> ROW = <span class="hljs-number">16</span>, COL = <span class="hljs-number">16</span>, MINE_NUM = <span class="hljs-number">40</span>;<br><br><span class="hljs-comment">//定义时间常量</span><br><span class="hljs-type">time_t</span> start_time;<br><span class="hljs-type">time_t</span> current_time;<br><span class="hljs-type">int</span> elapsed_time;<br></code></pre></td></tr></tbody></table></figure><p><strong>时间戳：</strong>时间戳是使用<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550?fromModule=lemma_inlink">数字签名</a>技术产生的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370?fromModule=lemma_inlink">数据</a>，因为程序的运行时间不同，时间戳也会不断变化，我们使用它作为生成随机数的种子。</p><h2 id="游戏初始化模块（gameInit"><a href="#游戏初始化模块（gameInit" class="headerlink" title="游戏初始化模块（gameInit)"></a>游戏初始化模块（gameInit)</h2><h3 id="开始界面停留"><a href="#开始界面停留" class="headerlink" title="开始界面停留"></a>开始界面停留</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C">initgraph(IMG_SIZE * ROW + <span class="hljs-number">240</span>, IMG_SIZE * COL);  <span class="hljs-comment">//创建游戏窗口</span><br><span class="hljs-type">int</span> mid1 = (IMG_SIZE * ROW + <span class="hljs-number">240</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> mid2 = (IMG_SIZE * COL) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y_length = IMG_SIZE * COL;<br><span class="hljs-type">int</span> x_length = IMG_SIZE * ROW + <span class="hljs-number">240</span>;<br><br>settextstyle(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">"宋体"</span>));         <span class="hljs-comment">//这里是以字符的左上角作为坐标基准</span><br>settextcolor(WHITE);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* text = <span class="hljs-string">"开始"</span>;<br><br><span class="hljs-comment">// 获取字符串的宽度和高度</span><br><span class="hljs-type">int</span> textWidth = textwidth(text);<br><span class="hljs-type">int</span> textHeight = textheight(text);<br><br><span class="hljs-comment">// 计算字符串的中央位置</span><br><span class="hljs-type">int</span> centerX = x_length / <span class="hljs-number">2</span> - textWidth / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> centerY = y_length / <span class="hljs-number">2</span> - textHeight / <span class="hljs-number">2</span>;<br><br><br>cleardevice();<br><br>outtextxy(centerX, centerY, text);<br><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>    ExMessage em;<br>    <span class="hljs-keyword">if</span> (peekmessage(&amp;em, EX_MOUSE)) {<br>        <span class="hljs-keyword">if</span> (em.message == WM_LBUTTONDOWN) {<br>            <span class="hljs-keyword">if</span> (em.x &gt;= centerX &amp;&amp; em.x &lt;= centerX + textWidth &amp;&amp;<br>                em.y &gt;= centerY &amp;&amp; em.y &lt;= centerY + textHeight) {     <span class="hljs-comment">// 点击开始（处于坐标范围内），否则用户永远卡在该循环内。</span><br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里使通过点击处是否处于字符坐标区间内来判定是否开始。</p><h3 id="初始化计时器"><a href="#初始化计时器" class="headerlink" title="初始化计时器"></a>初始化计时器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 初始化计时器</span><br>start_time = time(<span class="hljs-literal">NULL</span>);<br>current_time = start_time;<br>elapsed_time = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 设置字体和颜色</span><br>settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">"宋体"</span>));<br>settextcolor(RGB(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, _T(<span class="hljs-string">"Time: "</span>));<br></code></pre></td></tr></tbody></table></figure><p>这里没什么好说的。</p><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 加载图片</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">260</span>] = <span class="hljs-string">""</span>;      <span class="hljs-comment">//用于存储图片路径</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; ++i) {<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<span class="hljs-comment">//每次循环前，使用 memset 函数将 buf 数组清零</span><br>    sprintf_s(buf, <span class="hljs-string">"./img/%d.jpg"</span>, i);  <span class="hljs-comment">//将路径格式化</span><br>    loadimage(&amp;img[i], buf, IMG_SIZE, IMG_SIZE);<br>}<br></code></pre></td></tr></tbody></table></figure><p>memset函数能够快速填充空字符来清楚buff数组。</p><h3 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">LARGE_INTEGER frequency;<br>LARGE_INTEGER start;<br>QueryPerformanceFrequency(&amp;frequency);<br>QueryPerformanceCounter(&amp;start);<br>srand((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(start.QuadPart));<br></code></pre></td></tr></tbody></table></figure><p>以当前时间戳来作为生成随机数的种子，使得在短时间内多次启动程序生成的随机数都是不同的。</p><h3 id="生成雷区"><a href="#生成雷区" class="headerlink" title="生成雷区"></a>生成雷区</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> row, col;<br><span class="hljs-built_in">memset</span>(mine, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mine));  <span class="hljs-comment">// 清空雷区</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MINE_NUM;) {  <span class="hljs-comment">//随机生成雷</span><br>    row = rand() % ROW + <span class="hljs-number">1</span>;<br>    col = rand() % COL + <span class="hljs-number">1</span>;        <span class="hljs-comment">//rand函数，1-9之间随机生成值</span><br>    <span class="hljs-keyword">if</span> (mine[row][col] == <span class="hljs-number">0</span>) {<br>        mine[row][col] = <span class="hljs-number">9</span>;      <span class="hljs-comment">//9表示地雷</span><br>        ++i;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="更新格子数据"><a href="#更新格子数据" class="headerlink" title="更新格子数据"></a>更新格子数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 更新周围数字（九宫格内雷的数量）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span>) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = i - <span class="hljs-number">1</span>; a &lt;= i + <span class="hljs-number">1</span>; ++a) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = j - <span class="hljs-number">1</span>; b &lt;= j + <span class="hljs-number">1</span>; ++b) {<br>                    <span class="hljs-keyword">if</span> (mine[a][b] != <span class="hljs-number">9</span>) {<br>                        mine[a][b]++;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="数据偏移加密"><a href="#数据偏移加密" class="headerlink" title="数据偏移加密"></a>数据偏移加密</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 给所有格子加上偏移量，防止与被翻开格子冲突，也是加密数据的一种表现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        mine[i][j] += <span class="hljs-number">20</span>;  <span class="hljs-comment">//只有显示为29的才是雷，在20-28之间的都是非雷格子，点击翻开格子和递归翻开格子的操作就是-20</span><br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>类似于凯撒密码，但这里的偏移值为20</p><h2 id="游戏胜利判断模块-isOver"><a href="#游戏胜利判断模块-isOver" class="headerlink" title="游戏胜利判断模块(isOver)"></a>游戏胜利判断模块(isOver)</h2><h3 id="检查是否踩到雷"><a href="#检查是否踩到雷" class="headerlink" title="检查是否踩到雷"></a>检查是否踩到雷</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> isHitMine = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//布尔型变量，只有0和1两种形式（即true和flase）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span> &amp;&amp; (mine[i][j] &lt; <span class="hljs-number">20</span> || mine[i][j] &gt; <span class="hljs-number">29</span>)) {  <span class="hljs-comment">// 雷被翻开</span><br>            isHitMine = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (isHitMine) <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>布尔型变量：其只有0和1两种形式，即flase和true，常作为条件判断。</p><h3 id="重置计数器并弹出消息盒子"><a href="#重置计数器并弹出消息盒子" class="headerlink" title="重置计数器并弹出消息盒子"></a>重置计数器并弹出消息盒子</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 如果踩雷</span><br><span class="hljs-keyword">if</span> (isHitMine) {<br>    <span class="hljs-type">int</span> ok = MessageBox(GetHWnd(), <span class="hljs-string">"还要排雷吗"</span>, <span class="hljs-string">"你没了"</span>, MB_OKCANCEL);  <span class="hljs-comment">//easyx的函数，弹出消息盒子</span><br>    <span class="hljs-keyword">if</span> (ok == IDOK) {<br>        <span class="hljs-comment">// 重置雷区</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>                <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span>) {<br>                    mine[i][j] += <span class="hljs-number">20</span>;         <span class="hljs-comment">// 将雷标记为已翻开</span><br>                }<br>            }<br>        }<br>        num = <span class="hljs-number">0</span>;<br>        start_time = time(<span class="hljs-literal">NULL</span>);        <span class="hljs-comment">// 重置游戏开始时间</span><br>        elapsed_time = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 重置计时器</span><br>        gameInit();                        <span class="hljs-comment">// 重新初始化雷区和图像</span><br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 退出游戏</span><br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><code>exit(-1);</code>：终止当前进程。</p><h3 id="检查非雷格子被翻开"><a href="#检查非雷格子被翻开" class="headerlink" title="检查非雷格子被翻开"></a>检查非雷格子被翻开</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> uncoveredNonMine = <span class="hljs-number">0</span>;            <span class="hljs-comment">//翻开的非雷格子数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] &lt; <span class="hljs-number">20</span> &amp;&amp; mine[i][j] != <span class="hljs-number">9</span>) {          <span class="hljs-comment">// 非雷且已翻开</span><br>            uncoveredNonMine++;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="游戏绘制模块-gameDraw"><a href="#游戏绘制模块-gameDraw" class="headerlink" title="游戏绘制模块 (gameDraw)"></a>游戏绘制模块 (gameDraw)</h2><h3 id="对指定格子进行贴图"><a href="#对指定格子进行贴图" class="headerlink" title="对指定格子进行贴图"></a>对指定格子进行贴图</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-type">int</span> x = (j - <span class="hljs-number">1</span>) * IMG_SIZE;<br>        <span class="hljs-type">int</span> y = (i - <span class="hljs-number">1</span>) * IMG_SIZE;<br>        <span class="hljs-keyword">if</span> (mine[i][j] &gt;= <span class="hljs-number">0</span> &amp;&amp; mine[i][j] &lt;= <span class="hljs-number">9</span>) {<br>            putimage(x, y, &amp;img[mine[i][j]]);<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mine[i][j] &gt;= <span class="hljs-number">20</span> &amp;&amp; mine[i][j] &lt; <span class="hljs-number">30</span>) {<br>            putimage(x, y, &amp;img[<span class="hljs-number">10</span>]);<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mine[i][j] &gt; <span class="hljs-number">29</span>) {<br>            putimage(x, y, &amp;img[<span class="hljs-number">11</span>]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="显示计数器"><a href="#显示计数器" class="headerlink" title="显示计数器"></a>显示计数器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-comment">// 显示计时器</span><br>    <span class="hljs-type">char</span> time_str[<span class="hljs-number">20</span>];<br>    sprintf_s(time_str, <span class="hljs-string">"%d s"</span>, elapsed_time);<br>    settextcolor(RGB(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br>    outtextxy(IMG_SIZE * ROW + <span class="hljs-number">80</span>, <span class="hljs-number">20</span>, _T(<span class="hljs-string">"     "</span>));<br>    settextcolor(RGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    outtextxy(IMG_SIZE * ROW + <span class="hljs-number">110</span>, <span class="hljs-number">20</span>, time_str);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="递归展开格子模块（openNUll）"><a href="#递归展开格子模块（openNUll）" class="headerlink" title="递归展开格子模块（openNUll）"></a>递归展开格子模块（openNUll）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (mine[r][c] == <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r - <span class="hljs-number">1</span>; i &lt;= r + <span class="hljs-number">1</span>; ++i) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = c - <span class="hljs-number">1</span>; j &lt;= c + <span class="hljs-number">1</span>; ++j) {<br>            <span class="hljs-keyword">if</span> ((mine[i][j] == <span class="hljs-number">20</span> || mine[i][j] != <span class="hljs-number">29</span>) &amp;&amp; mine[i][j] &gt; <span class="hljs-number">9</span>) {<br>                mine[i][j] -= <span class="hljs-number">20</span>;<br>                num++;<br>                openNUll(i, j);<br>            }<br>        }<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="开始菜单模块-showMenu"><a href="#开始菜单模块-showMenu" class="headerlink" title="开始菜单模块(showMenu)"></a>开始菜单模块(showMenu)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C">initgraph(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);  <span class="hljs-comment">// 创建菜单窗口</span><br>setbkcolor(WHITE);<br>cleardevice();<br><br>settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">"宋体"</span>));<br>settextcolor(BLACK);<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">50</span>, _T(<span class="hljs-string">"选择游戏难度："</span>));<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">100</span>, _T(<span class="hljs-string">"1. 简单"</span>));<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">140</span>, _T(<span class="hljs-string">"2. 中等"</span>));<br>outtextxy(<span class="hljs-number">150</span>, <span class="hljs-number">180</span>, _T(<span class="hljs-string">"3. 困难"</span>));<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>    ExMessage em;<br>    <span class="hljs-keyword">if</span> (peekmessage(&amp;em, EX_MOUSE)) {<br>        <span class="hljs-keyword">if</span> (em.message == WM_LBUTTONDOWN) {<br>            <span class="hljs-keyword">if</span> (em.x &gt; <span class="hljs-number">150</span> &amp;&amp; em.x &lt; <span class="hljs-number">250</span> &amp;&amp; em.y &gt; <span class="hljs-number">100</span> &amp;&amp; em.y &lt; <span class="hljs-number">120</span>) {     <span class="hljs-comment">// 点击简单（处于坐标范围内）</span><br>                ROW = <span class="hljs-number">9</span>;<br>                COL = <span class="hljs-number">9</span>;<br>                MINE_NUM = <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (em.x &gt; <span class="hljs-number">150</span> &amp;&amp; em.x &lt; <span class="hljs-number">250</span> &amp;&amp; em.y &gt; <span class="hljs-number">140</span> &amp;&amp; em.y &lt; <span class="hljs-number">160</span>) {   <span class="hljs-comment">// 点击中等</span><br>                ROW = <span class="hljs-number">16</span>;<br>                COL = <span class="hljs-number">16</span>;<br>                MINE_NUM = <span class="hljs-number">40</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (em.x &gt; <span class="hljs-number">150</span> &amp;&amp; em.x &lt; <span class="hljs-number">250</span> &amp;&amp; em.y &gt; <span class="hljs-number">180</span> &amp;&amp; em.y &lt; <span class="hljs-number">200</span>) {    <span class="hljs-comment">// 点击困难</span><br>                ROW = <span class="hljs-number">20</span>;<br>                COL = <span class="hljs-number">20</span>;<br>                MINE_NUM = <span class="hljs-number">70</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br>}<br>closegraph();  <span class="hljs-comment">// 关闭菜单窗口</span><br></code></pre></td></tr></tbody></table></figure><h2 id="侧边栏提示模块-tips"><a href="#侧边栏提示模块-tips" class="headerlink" title="侧边栏提示模块(tips)"></a>侧边栏提示模块(tips)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">current_time = time(<span class="hljs-literal">NULL</span>);<br>elapsed_time = (<span class="hljs-type">int</span>)(current_time - start_time);<br><br><span class="hljs-type">char</span> time_str[<span class="hljs-number">20</span>];<br>sprintf_s(time_str, <span class="hljs-string">"%d s"</span>, elapsed_time);<br><br>settextcolor(RGB(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));         <span class="hljs-comment">//设置时间字体颜色。</span><br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">85</span>, <span class="hljs-number">20</span>, time_str);                 <span class="hljs-comment">//easyx的输出</span><br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">50</span>, _T(<span class="hljs-string">"鼠标左键：翻开格子"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">80</span>, _T(<span class="hljs-string">"鼠标右键：标记地雷"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">110</span>, _T(<span class="hljs-string">"所有的非雷格子都被打开"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">140</span>, _T(<span class="hljs-string">"才算游戏胜利"</span>));<br>outtextxy(IMG_SIZE * ROW + <span class="hljs-number">15</span>, <span class="hljs-number">170</span>, _T(<span class="hljs-string">"祝你游戏愉快"</span>));<br><br></code></pre></td></tr></tbody></table></figure><h2 id="鼠标消息处理模块-mouseClick"><a href="#鼠标消息处理模块-mouseClick" class="headerlink" title="鼠标消息处理模块(mouseClick)"></a>鼠标消息处理模块(mouseClick)</h2><h3 id="左键点击并保护雷区"><a href="#左键点击并保护雷区" class="headerlink" title="左键点击并保护雷区"></a>左键点击并保护雷区</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> firstClick = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 用一个变量标记是否为第一次点击</span><br>ExMessage em;                                 <span class="hljs-comment">//Easyx函数存储消息</span><br><span class="hljs-keyword">if</span> (peekmessage(&amp;em, EX_MOUSE)) {<br>    mx = em.y / IMG_SIZE + <span class="hljs-number">1</span>;<br>    my = em.x / IMG_SIZE + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (em.lbutton) {          <span class="hljs-comment">// 鼠标左键点击</span><br>        <span class="hljs-keyword">if</span> (firstClick) {<br>            firstClick = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记第一次点击已完成，准备随机布雷。</span><br><br>            <span class="hljs-comment">// 生成雷区并保护第一次点击及其周围，不能在周围生成雷</span><br>            <span class="hljs-type">int</span> protectedRow = mx;<br>            <span class="hljs-type">int</span> protectedCol = my;           <span class="hljs-comment">//获取鼠标点击位置。</span><br><br>            <span class="hljs-comment">// 随机生成雷区</span><br>            <span class="hljs-type">int</span> row, col;<br>            <span class="hljs-built_in">memset</span>(mine, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mine));  <span class="hljs-comment">// 清空雷区，清除gameinit函数的第一次结果</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MINE_NUM;) {<br>                row = rand() % ROW + <span class="hljs-number">1</span>;<br>                col = rand() % COL + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 跳过第一次点击区域及其周围九宫格</span><br>                <span class="hljs-keyword">if</span> (row &gt;= protectedRow - <span class="hljs-number">1</span> &amp;&amp; row &lt;= protectedRow + <span class="hljs-number">1</span> &amp;&amp;<br>                    col &gt;= protectedCol - <span class="hljs-number">1</span> &amp;&amp; col &lt;= protectedCol + <span class="hljs-number">1</span>) {<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br><br>                <span class="hljs-keyword">if</span> (mine[row][col] == <span class="hljs-number">0</span>) {<br>                    mine[row][col] = <span class="hljs-number">9</span>;  <span class="hljs-comment">// 9 表示地雷</span><br>                    ++i;<br>                }<br>            }<br></code></pre></td></tr></tbody></table></figure><h3 id="更新周围数据"><a href="#更新周围数据" class="headerlink" title="更新周围数据"></a>更新周围数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 更新周围数字</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        <span class="hljs-keyword">if</span> (mine[i][j] == <span class="hljs-number">9</span>) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = i - <span class="hljs-number">1</span>; a &lt;= i + <span class="hljs-number">1</span>; ++a) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = j - <span class="hljs-number">1</span>; b &lt;= j + <span class="hljs-number">1</span>; ++b) {<br>                    <span class="hljs-keyword">if</span> (mine[a][b] != <span class="hljs-number">9</span>) {<br>                        mine[a][b]++;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ROW + <span class="hljs-number">1</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; COL + <span class="hljs-number">1</span>; ++j) {<br>        mine[i][j] += <span class="hljs-number">20</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="翻开格子"><a href="#翻开格子" class="headerlink" title="翻开格子"></a>翻开格子</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-keyword">if</span> (mine[mx][my] &gt; <span class="hljs-number">9</span>) {<br>        mine[mx][my] -= <span class="hljs-number">20</span>;<br>        openNUll(mx, my);<br>        num++;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="右键标记功能"><a href="#右键标记功能" class="headerlink" title="右键标记功能"></a>右键标记功能</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (em.rbutton) {  <span class="hljs-comment">// 鼠标右键标记</span><br>            <span class="hljs-keyword">if</span> (mine[mx][my] &gt; <span class="hljs-number">9</span> &amp;&amp; mine[mx][my] &lt;= <span class="hljs-number">29</span>) {<br>                mine[mx][my] += <span class="hljs-number">20</span>;<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                mine[mx][my] -= <span class="hljs-number">20</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="主函数部分（main）"><a href="#主函数部分（main）" class="headerlink" title="主函数部分（main）"></a>主函数部分（main）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    showMenu();<br>    gameInit();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {          <span class="hljs-comment">//不断循环保证数据随时更新</span><br>        tips();<br>        mouseClick();<br>        gameDraw();<br>        isOver();<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="整体原理"><a href="#整体原理" class="headerlink" title="整体原理"></a>整体原理</h2><ul><li><strong>菜单的调用</strong>程序从 <code>main</code>函数开始执行，首先调用 <code>showMenu</code>函数创建一个菜单窗口，展示不同难度选项供玩家选择，玩家通过鼠标点击相应区域确定游戏难度（简单、中等、困难），对应不同的行数、列数和雷的数量设置。</li><li><strong>初始化操作</strong>选择完难度后，<code>gameInit</code>函数被调用，进行多方面的初始化操作。先是利用 <code>initgraph</code>初始化图形界面，设置好窗口大小并准备显示游戏内容。接着初始化计时器，记录游戏开始时间，用于后续统计游戏用时。同时，加载游戏中所需的各类图片资源，像代表数字、空白格、地雷等不同状态的图片。然后，生成雷区布局，通过获取合适的随机数种子，按照设定好的雷数，在排除首次点击及其周边九宫格范围的情况下，随机放置地雷，并根据地雷分布更新周围格子所对应的周边地雷数量，最后通过给每个格子数据添加偏移量的方式对雷区数据进行加密处理，便于后续判断格子状态和展开操作。</li><li><strong>界面更新与提示</strong>：在游戏运行的主循环（<code>main</code>函数中的 <code>while (true)</code>循环）里，每次循环都会调用 <code>tips</code>函数来更新游戏界面右侧的提示信息，包括显示游戏耗时以及告知玩家鼠标左右键的操作功能（左键翻开格子、右键标记地雷等），让玩家清楚游戏进展情况和操作方法。</li><li><strong>鼠标交互处理</strong>：<code>mouseClick</code>函数负责处理鼠标消息。对于鼠标左键点击，若为首次点击，会保护点击位置及其九宫格区域不布雷，随后生成雷区、更新周围雷数并加密雷区；若非首次点击，会根据点击格子的状态进行相应处理，比如翻开空白格及递归展开其周围空白格，同时统计翻开格子数量。对于鼠标右键点击，则是实现对格子进行标记地雷或取消标记的功能，通过改变对应格子存储的数据来体现标记状态的切换。</li><li><strong>界面绘制展示</strong>：<code>gameDraw</code>函数根据雷区二维数组中每个格子的数据值，确定要在对应位置绘制的图片（例如对应数字的图片、空白格图片、地雷图片等），将雷区当前的状态直观展示在游戏窗口上，同时更新显示游戏的计时器信息，实时呈现游戏的状态变化。</li><li><strong>游戏结束判断</strong>：<code>isOver</code>函数负责判断游戏是否结束，分为失败和胜利两种情况。通过遍历雷区数组，判断是否有雷被翻开以此来确定是否踩雷，若踩雷则弹出消息框询问玩家是否继续游戏，继续则重置相关状态重新开始，取消则退出游戏。同时，会统计已翻开的非雷格子数量，当该数量等于总格子数减去雷数时，判定游戏胜利，同样弹出消息框让玩家选择继续游戏或者退出，选择继续就重置状态重新初始化游戏，选择退出则直接结束程序。</li></ul><h2 id="开发过程出现的BUG和解决思路"><a href="#开发过程出现的BUG和解决思路" class="headerlink" title="开发过程出现的BUG和解决思路"></a>开发过程出现的BUG和解决思路</h2><p><strong>1.开头暴雷</strong></p><p>第一个解决思路是开头暴雷后重新排雷，结果出现了内存溢出的错误，第二个思路是先不排雷，在第一次点击的地方生成保护区，再开始排雷。笔者引入了一个bool值，解决了该问题。</p><p><strong>2.重新开始后失去开头保护</strong></p><p>一开始的解决思路是使用goto，但这会降低代码可读性，也不符合编译标准。所以，我编写了一个新的函数<code>restartgame</code>来重置游戏，这个思路被证实能够完美地解决该问题。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这可能是一个很拙劣的游戏源码，但编写他花了我和我的组员很多时间，如果喜欢，别忘了点个<a href="https://github.com/Dr-WillMos/Minesweeper">Star</a>,谢谢。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>开发</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序：基于插入算法的改进版本</title>
    <link href="/posts/shell_sort/"/>
    <url>/posts/shell_sort/</url>
    
    <content type="html"><![CDATA[<h1 id="希尔排序：基于插入算法的改进版本"><a href="#希尔排序：基于插入算法的改进版本" class="headerlink" title="希尔排序：基于插入算法的改进版本"></a>希尔排序：基于插入算法的改进版本</h1><p>平均时间复杂度：<strong>O(n log n)</strong></p><p>最好时间复杂度：<strong>O(n log^2 n)</strong></p><p>最坏时间复杂度：<strong>O(n log n)</strong></p><p>稳定性：<strong>不稳定</strong></p><p>特点：<strong>1.处理基本有序的效率较高</strong></p><p><strong>2.数据量比较小时效率较高</strong></p><p>希尔排序，又名<strong>缩小增量排序</strong>，是基于插入排序的一种<strong>改进算法</strong>，解决了插入排序一次只能移动一个元素造成的低效问题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1.设定一个<strong>增量</strong>整型gap = len / 2，向下取整，根据gap分组。</p><p>2.对每一组进行<strong>插入排序</strong>。</p><p>3.更新gap = gap / 2，继续以上操作。</p><p>4.知道gap == 1停止，对所有元素执行插入排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> {   <span class="hljs-comment">// &gt;&gt;是位运算符，相当于/2并向下取整</span><br>        <span class="hljs-type">int</span> gap, i, j;<br>        <span class="hljs-type">int</span> temp; <br>        <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)  <span class="hljs-comment">//第一层循环，保证gap的更新</span><br>                <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++) {     <span class="hljs-comment">//第二层循环，保证组别的切换</span><br>                        temp = arr[i];<br>                        <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)  <span class="hljs-comment">//第三层循环，完成组内比较。</span><br>                                arr[j + gap] = arr[j];<br>                        arr[j + gap] = temp;<br>                }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>假设有 {4, 2, 7, 0, 5, 8}这个数组，len = 6，首先，初始的 gap = len &gt;&gt; 1 也就是 6 &gt;&gt; 1 = 3（这里的 “&gt;&gt;” 是右移操作符，相当于除以 2 向下取整）。此时数组根据 gap 的值被分为了两组，分别是 {4, 0} 和 {2, 5} 以及 {7, 8}。</p><p>对于第一组 {4, 0}，进入内层的插入排序循环（也就是第三层循环），因为 4 &gt; 0，所以会将 4 往后移动（通过 arr [j + gap] = arr [j] 语句），然后把 0 放到合适的位置，即 arr [0] 的位置，这一组就排好了序。同样地，对 {2, 5} 和 {7, 8}  这两组也会进行类似的插入排序操作。</p><p>接着，<strong>更新 gap = gap &gt;&gt; 1</strong>，此时 gap 变为 1。这意味着现在要对整个数组当作一组来进行插入排序了。</p><p>从第二个元素开始遍历整个数组（第二层循环保证了这个遍历过程），比如对于元素 2，先把它存到临时变量 temp 中，然后通过第三层循环，与前面已经排好序的元素依次比较（这里是和 4 比较，因为 j = i -  gap，此时 i 是对应元素 2 的索引，gap 为 1），如果前面的元素大于它，就把前面的元素往后移（同样是通过 arr [j + gap] = arr [j] 语句），直到找到合适的位置，再把 temp（也就是  2）放到那个位置。就这样依次对数组中的每个元素进行这样的插入排序操作，直到整个数组都排好序为止。</p><h2 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h2><p>增量大时，分组多，组内元素比较少，效率较高。</p><p>随着增量逐渐减小，虽然组内元素越来越多，<strong>但整体越来越有序</strong>，所以效率越来越高。</p><h3 id="不稳定性"><a href="#不稳定性" class="headerlink" title="不稳定性"></a>不稳定性</h3><p><strong>希尔排序会改变排序前相同元素的相对位置。</strong></p><p>例如：数组 [5*, 4, 5, 2, 8, 1]，（对不同的5加星号标记）希尔排序之后会改变两个5的相对位置，排序后的星号5出现在5的后面。</p><p>所有希尔排序具有<strong>不稳定性</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>算法</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/posts/insertion_sort/"/>
    <url>/posts/insertion_sort/</url>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>平均时间复杂度：<strong>O($n^2$)</strong></p><p>最好时间复杂度：<strong>O(n)</strong></p><p>最坏时间复杂度：<strong>O($n^2$)</strong></p><p>稳定性：<strong>稳定</strong></p><p>将第一个元素设置为有序区，将后面的每个数<strong>插入</strong>到前面的有序区之内，形同打扑克牌时<strong>摸牌插入到手中牌堆内。</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>{  <span class="hljs-comment">//两个重要参数</span><br>        <span class="hljs-type">int</span> i,j,key;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;len;i++){   <br>                key = arr[i];  <span class="hljs-comment">//这里的key就是中间变量，意味着待处理元素</span><br>                j=i<span class="hljs-number">-1</span>;         <span class="hljs-comment">//前移一位</span><br>                <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (arr[j]&gt;key)) {  <br>                        arr[j+<span class="hljs-number">1</span>] = arr[j];   <span class="hljs-comment">//这三行代码完成了交换</span><br>                        j--;                 <span class="hljs-comment">//j--表示比较的移动，逐渐移动到arr[0]</span><br>                }<br>                arr[j+<span class="hljs-number">1</span>] = key;    <span class="hljs-comment">//如果while不执行，这句相当于什么都不做</span><br>        }<br><br></code></pre></td></tr></tbody></table></figure><h2 id="针对有序区处理的顺序"><a href="#针对有序区处理的顺序" class="headerlink" title="针对有序区处理的顺序"></a>针对有序区处理的顺序</h2><p>使用插入将数组元素从小到大排序，在将待处理元素与有序区比较时，<strong>强烈建议</strong>从后往前<strong>（即从有序区的大数到小数的顺序来比较）</strong>排序，因为这样<strong>只需要移动比待处理元素大的元素，一旦找到位置就可以直接插入。</strong></p><p>比如{1,3,5,7}待处理元素为4，在比较5，7之后移动了2个元素，再把4插入3后面即可。</p><p>但如果是反着来，可能会对已经比较过的元素进行多次移动操作，尤其是当待插入元素较小，需要移动的元素较多时，<strong>效率相对较低。</strong></p><p>然而这也不是绝对的，<strong>但从大到小是通常情况下的最优解。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四大常用字符处理函数的实现</title>
    <link href="/posts/String/"/>
    <url>/posts/String/</url>
    
    <content type="html"><![CDATA[<h1 id="四大常用字符处理函数的实现"><a href="#四大常用字符处理函数的实现" class="headerlink" title="四大常用字符处理函数的实现"></a>四大常用字符处理函数的实现</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对于指针变量s，*s代表其指向的变量（声明变量时不代表），可能是整型变量a，也可能是字符变量c。s代表他本身，他是一个地址，比如，32ffcs。理解这一点，不然剩下的很难看懂。</p><p>函数中，需要把实际参数的地址赋给形参的指针变量，并根据“函数中的指针能够修改实际变量”的特点来实现函数功能，例子详见strcat函数。</p><h3 id="strlen函数：获取字符串长度"><a href="#strlen函数：获取字符串长度" class="headerlink" title="strlen函数：获取字符串长度"></a>strlen函数：获取字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mystrlen</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span><br>{<br>    <span class="hljs-type">char</span> *b = s;   <span class="hljs-comment">//这里就是让形参b得到了*s的地址，即s。</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">for</span> (;*b != <span class="hljs-string">'\0'</span>;b++)<br>    {<br>        length++;<br>    }<br>    <span class="hljs-keyword">return</span> length;<br>}<br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> x[<span class="hljs-number">10</span>] = <span class="hljs-string">"abcdefgh"</span>;<br>    <span class="hljs-type">int</span> a;<br>    a = mystrlen(x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a);<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="srtrcpy函数：实现字符串的复制"><a href="#srtrcpy函数：实现字符串的复制" class="headerlink" title="srtrcpy函数：实现字符串的复制"></a>srtrcpy函数：实现字符串的复制</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mystrcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">char</span> *b)</span> {<br>    <span class="hljs-type">char</span> temp;<br>    temp = *b;  <span class="hljs-comment">// 先取出b指向的当前字符</span><br>    <span class="hljs-keyword">while</span> (temp!= <span class="hljs-string">'\0'</span>) {<br>        *a = temp;<br>        a++;<br>        b++;<br>        temp = *b;  <span class="hljs-comment">// 更新temp为下一个字符</span><br>    }<br>    *a = <span class="hljs-string">'\0'</span>;  <span class="hljs-comment">// 手动添加字符串结束符到目标字符串末尾</span><br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">char</span> *x = <span class="hljs-string">"nihaozhangzhou"</span>;  <span class="hljs-comment">// 记得定义足够大的字符数组来存储目标字符串，避免数组越界。</span><br>    <span class="hljs-type">char</span> *y = <span class="hljs-string">"zhongguo"</span>;<br>    mystrcpy(x, y);<br>    <span class="hljs-built_in">puts</span>(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="strcat函数：实现字符串连接"><a href="#strcat函数：实现字符串连接" class="headerlink" title="strcat函数：实现字符串连接"></a>strcat函数：实现字符串连接</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//字符串拼接函数 mystrcat()，在这里，假设X是32ffcs（说明*x的地址是32ffcs）;那么将x的值赋给p;通过函数内指针能够修改实际参数的特点修改指定值，所以最后的return可以是p也可以是x。</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">mystrcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">char</span> *y)</span><br>{<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-type">char</span> *q;<br>    <span class="hljs-keyword">for</span> (p = x;*p != <span class="hljs-string">'\0'</span>; p++);<br>    <span class="hljs-keyword">for</span> (q = y;*q != <span class="hljs-string">'\0'</span>; q++)<br>    {<br>        *p = *q;<br>        p++;<br>    }<br>    *p = <span class="hljs-string">'\0'</span>;<br>    <span class="hljs-keyword">return</span> p;<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>     <span class="hljs-type">char</span> a[<span class="hljs-number">80</span>]=<span class="hljs-string">"Spring "</span>;<br>     <span class="hljs-type">char</span> b[]= <span class="hljs-string">"Equinox"</span>;<br>     mystrcat(a,b);<br>     <span class="hljs-built_in">puts</span>(a);<br><br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="strcmp：实现字符串的比较，包括长度和字符两方面。"><a href="#strcmp：实现字符串的比较，包括长度和字符两方面。" class="headerlink" title="strcmp：实现字符串的比较，包括长度和字符两方面。"></a>strcmp：实现字符串的比较，包括长度和字符两方面。</h3><p>只有长度相同，每个字符都相同时才相同，此时输出0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mystrcmp</span><span class="hljs-params">(<span class="hljs-type">char</span> *x,<span class="hljs-type">char</span> *y)</span><br>{<br>  <br>    <span class="hljs-type">char</span> *p = x;<br>    <span class="hljs-type">char</span> *q = y;<br>    <span class="hljs-keyword">while</span> (*p!= <span class="hljs-string">'\0'</span> &amp;&amp; *q!= <span class="hljs-string">'\0'</span>)<br>{<br>    <span class="hljs-keyword">if</span> (*p &gt; *q)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*p &lt; *q)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    p++;<br>    q++;<br>}<br><span class="hljs-keyword">if</span> (*p == <span class="hljs-string">'\0'</span> &amp;&amp; *q!= <span class="hljs-string">'\0'</span>)<br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*p!= <span class="hljs-string">'\0'</span> &amp;&amp; *q == <span class="hljs-string">'\0'</span>)<br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>}<br><span class="hljs-keyword">else</span><br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br><br>}<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">char</span> a[] = <span class="hljs-string">"China"</span>;<br>    <span class="hljs-type">char</span> *b = <span class="hljs-string">"ChinaIlove"</span>;<br>    <span class="hljs-type">int</span> v = mystrcmp(a,b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,v);<br><br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PTA补题（一）</title>
    <link href="/posts/pta1/"/>
    <url>/posts/pta1/</url>
    
    <content type="html"><![CDATA[<h1 id="PTA补题（一）"><a href="#PTA补题（一）" class="headerlink" title="PTA补题（一）"></a>PTA补题（一）</h1><p><strong>1.以下定义了一个一维数组str，该数组可以存放81个字符型数据。</strong>       T，’\0’也算一个字符</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">char</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">81</span>];<br></code></pre></td></tr></tbody></table></figure><p><strong>2.数组定义后，数组名表示该数组所分配连续内存空间中第一个单元的地址，即首地址。</strong>      T</p><p><strong>3.数组定义后，只能引用单个的数组元素，而不能一次引用整个数组。</strong>  T</p><p>数组名只代表首个元素，更多时候是通过遍历来实现对数组的引用。</p><p><strong>4.在以下描述中，（ ABE ）是正确的。</strong></p><p><strong>A.</strong></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br></code></pre></td></tr></tbody></table></figure><p><strong>定义了数组a，并对数组元素赋初值。此时，a[0]为1，a[1]为2，a[2]为3，a[3]为4，a[4]为5。</strong></p><p><strong>B.</strong></p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">int</span> b[<span class="hljs-number">10</span>];<br></code></pre></td></tr></tbody></table></figure><p><strong>定义了静态数组b，且10个数组元素的初值都为0。</strong></p><p><strong>C.</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int fib[<span class="hljs-number">45</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>定义了数组fib，且45个数组元素的值都为0。****自动变量可能为任何数字</strong></p><p><strong>D.</strong></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">static</span> int week[<span class="hljs-number">7</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<br></code></pre></td></tr></tbody></table></figure><p><strong>定义了静态数组week，并对数组 week 的前3个元素week[0]～week[2]赋初值，week[3]～week[6]值都是不确定的。****静态变量未初始化时固定为0</strong></p><p><strong>E.</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int cnt[<span class="hljs-number">10</span>] <span class="hljs-operator">=</span> {<span class="hljs-number">1</span>}<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>定义了数组cnt，并对cnt[0]赋初值1，其余元素的初值为0。</strong></p><p><strong>5.<code>"a"</code> 和 <code>'a'</code>是等价的。</strong> F，前者代表字符串，后者代表字符</p><p><strong>6.调用strcmp函数比较字符串大小时，通常较长的字符串会较大。  F</strong></p><p><strong>调用</strong><code>strcmp</code>函数比较字符串大小时，是按照字典序而不是字符串长度来判断的。</p><p><strong>7.如果函数定义出现在函数调用之前，可以不必加函数原型声明。 F</strong></p><p><strong>需要的</strong></p><p><strong>9.C语言中函数不能嵌套定义  T</strong></p><p><strong>10.静态变量的作用域是整个文件。   F</strong></p><p><strong>如果在函数中出现，只在函数中有效</strong></p><p><strong>11.当变量的存储类型定义缺省时,系统默认为变量的存储类型为auto类型,分配在静态区。</strong></p><p><strong>分配在栈区</strong></p><p><strong>12.全局变量只能定义在程序的最前面，即第一个函数的前面。</strong>   F，任何位置a</p><p><strong>13.静态局部变量如果没有赋值，其存储单元中将是随机值。</strong>  F，为0</p><p><strong>14.<a href="https://pintia.cn/problem-sets/1861991914122440704/exam/problems/type/7?problemSetProblemId=1861991914193743872">约瑟夫环</a></strong></p><blockquote><p><strong>用数组的方法的缺点是必须知道测试点在什么范围，用动态分配内存就可以解决这个问题。</strong></p></blockquote><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br><span class="hljs-keyword">int</span> josephus(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m) {<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> monkeys[<span class="hljs-number">300</span>]; &nbsp;<span class="hljs-regexp">//</span> 定义足够大的数组来存放猴子状态，假设最多<span class="hljs-number">300</span>只猴子，可根据实际情况调整大小<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;monkeys[i] = i + <span class="hljs-number">1</span>; &nbsp;<span class="hljs-regexp">//</span> 初始化猴子编号，从<span class="hljs-number">1</span>开始<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> count = n; &nbsp;<span class="hljs-regexp">//</span> 剩余猴子数量<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; &nbsp;<span class="hljs-regexp">//</span> 当前报数位置索引<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>; &nbsp;<span class="hljs-regexp">//</span> 当前报数数字<br><br> &nbsp; &nbsp;<span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">1</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (monkeys[<span class="hljs-keyword">index</span>] &gt; <span class="hljs-number">0</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (num == m) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;monkeys[<span class="hljs-keyword">index</span>] = -<span class="hljs-number">1</span>; &nbsp;<span class="hljs-regexp">//</span> 将报到m的猴子标记为已淘汰（这里用 -<span class="hljs-number">1</span> 标记）<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num = <span class="hljs-number">0</span>;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count--;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">index</span>++; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-regexp">//</span>轮到下一个猴子报数。<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == n) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-regexp">//</span>索引越界时重置为<span class="hljs-number">0</span><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (monkeys[i] &gt; <span class="hljs-number">0</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> monkeys[i]; &nbsp;<span class="hljs-regexp">//</span> 返回剩下猴子的编号，也就是猴王编号<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; &nbsp;<span class="hljs-regexp">//</span> 正常情况不会执行到这里，只是为了语法完整性<br>}<br><br><span class="hljs-keyword">int</span> main() {<br> &nbsp; &nbsp;<span class="hljs-keyword">int</span> n, m;<br> &nbsp; &nbsp;<span class="hljs-keyword">while</span> (scanf(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m)!= EOF &amp;&amp; (n!= <span class="hljs-number">0</span> || m!= <span class="hljs-number">0</span>)) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">int</span> result = josephus(n, m);<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">printf</span>(<span class="hljs-string">"%d\n"</span>, result);<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>15.<a href="https://pintia.cn/problem-sets/1861991914122440704/exam/problems/type/7?problemSetProblemId=1861991914193743876&amp;page=0">矩阵相乘</a></strong></p><blockquote><p>相乘时的元素遍历需要注意。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><br><span class="hljs-comment">// 计算矩阵乘法的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matrixMultiply</span><span class="hljs-params">(<span class="hljs-type">int</span> matrixA[][MAX_SIZE], <span class="hljs-type">int</span> ra, <span class="hljs-type">int</span> ca, <span class="hljs-type">int</span> matrixB[][MAX_SIZE], <span class="hljs-type">int</span> rb, <span class="hljs-type">int</span> cb)</span> </span>{<br> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (ca!= rb) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: %d!= %d\n"</span>, ca, rb);<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span>;<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-type">int</span> result[MAX_SIZE][MAX_SIZE];<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ra; i++) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//左矩阵的行数遍历</span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cb; j++) { &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//右矩阵列数遍历</span><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i][j] = <span class="hljs-number">0</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; ca; k++) { &nbsp; &nbsp;<span class="hljs-comment">//双矩阵元素乘法的元素遍历</span><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i][j] += matrixA[i][k] * matrixB[k][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-comment">// 输出结果矩阵</span><br> &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ra, cb);<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ra; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cb; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, result[i][j]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (j &lt; cb - <span class="hljs-number">1</span>) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br> &nbsp;  }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br> &nbsp; &nbsp;<span class="hljs-type">int</span> ra, ca;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;ra, &amp;ca);<br> &nbsp; &nbsp;<span class="hljs-type">int</span> matrixA[MAX_SIZE][MAX_SIZE];<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ra; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ca; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;matrixA[i][j]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-type">int</span> rb, cb;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;rb, &amp;cb);<br> &nbsp; &nbsp;<span class="hljs-type">int</span> matrixB[MAX_SIZE][MAX_SIZE];<br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rb; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cb; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;matrixB[i][j]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-built_in">matrixMultiply</span>(matrixA, ra, ca, matrixB, rb, cb);<br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>16.<a href="https://pintia.cn/problem-sets/1861991914122440704/exam/problems/type/7?problemSetProblemId=1861991914193743878&amp;page=0">卷积</a></strong></p><blockquote><p><strong>就是成倍数输出数组，我当时想太多了。</strong></p></blockquote><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 10</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br> &nbsp; &nbsp;<span class="hljs-type">int</span> n, k;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;k);<br> &nbsp; &nbsp;<span class="hljs-type">int</span> image[MAX_SIZE][MAX_SIZE]; &nbsp;<span class="hljs-comment">// 存储原始图像像素信息的二维数组</span><br><br> &nbsp; &nbsp;<span class="hljs-comment">// 读取原始图像像素信息</span><br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;image[i][j]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-comment">// 按照倍数放大图像并输出</span><br> &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; n * k; row++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n * k; col++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-type">int</span> originRow = row / k;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-type">int</span> originCol = col / k;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, image[originRow][originCol]);<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br> &nbsp;  }<br><br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔一文速通</title>
    <link href="/posts/hanoi/"/>
    <url>/posts/hanoi/</url>
    
    <content type="html"><![CDATA[<h1 id="汉诺塔一文速通"><a href="#汉诺塔一文速通" class="headerlink" title="汉诺塔一文速通"></a>汉诺塔一文速通</h1><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><blockquote><ul><li><strong>有三根柱子，通常标记为 A（起始杆）、B（中转杆）、C（目标杆）。</strong></li><li><strong>开始时，所有的圆盘都按照从大到小的顺序堆叠在一根柱子（假设为 A 柱）上。</strong></li><li><strong>目标是将所有圆盘从起始柱子（A 柱）移动到目标柱子（比如 C 柱）。</strong></li><li><strong>移动过程中有两个重要的规则：每次只能移动一个圆盘；在移动过程中，大圆盘不能放在小圆盘上面。</strong></li></ul></blockquote><p><img src="https://s2.loli.net/2024/12/01/om67z1f3rwFtUqn.png" alt="image-20241201102242192"></p><h3 id="本质分析"><a href="#本质分析" class="headerlink" title="本质分析"></a>本质分析</h3><blockquote><p><strong>实际上，以三个汉诺塔为例，我们需要把最上面两个盘借助C转移到B上，（此时C是中转杆，B是目标杆），再直接将最大的底盘移动到C（目标杆），最后借助A，将B上的n-1个盘转移到C上（此时B是起始杆，A为中转杆，C为目标杆）。</strong></p><p><strong>当汉诺塔的盘数增加，其底层逻辑都不变，依旧是：</strong></p><ul><li><strong>将除底盘外的n-1个底盘移动借助目标杆到中转杆上</strong></li><li><strong>直接将最大底盘移动到目标杆上</strong></li><li><strong>将中转杆上的n-1个盘借助起始杆移动到目标杆上。</strong></li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">char</span> x,<span class="hljs-type">char</span> y)</span> &nbsp; &nbsp;<span class="hljs-comment">//移动函数，负责输出移动步骤</span></span><br><span class="hljs-function"></span>{<br> &nbsp; &nbsp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c -&gt; %c\n"</span>,x,y);<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> start,<span class="hljs-type">char</span> temp,<span class="hljs-type">char</span> end)</span><span class="hljs-comment">//第一位是起始，第二位中转，第三位目标</span></span><br><span class="hljs-function"></span>{<br> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//如果只有一个盘，可以直接移动</span><br> &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">print</span>(start,end); &nbsp;<br> &nbsp;  }<br> &nbsp; &nbsp;<span class="hljs-keyword">else</span> {<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>,start,end,temp); &nbsp;<span class="hljs-comment">//将非底盘（n-1）个从起始柱借助目标柱移动到中转柱</span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">print</span>(start,end); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">//将底盘从起始站柱子移动到目标柱</span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>,temp,start,end); &nbsp;<span class="hljs-comment">//将非底盘（n-1）从中转柱子借助起始柱移动到目标柱子</span><br> &nbsp;  }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br> &nbsp; &nbsp;<span class="hljs-type">int</span> n;<br> &nbsp; &nbsp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br> &nbsp; &nbsp;<span class="hljs-built_in">hanoi</span>(n,<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>); &nbsp; <span class="hljs-comment">//这里默认设定A为起始柱，B为中转柱，C为目标柱。</span><br> &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈优绩主义</title>
    <link href="/posts/meritocracy/"/>
    <url>/posts/meritocracy/</url>
    
    <content type="html"><![CDATA[<h1 id="优绩主义"><a href="#优绩主义" class="headerlink" title="优绩主义"></a>优绩主义</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>也不知道从什么时候开始，我们发现“全员保研”的文章铺天盖地。</strong></p><p><img src="https://s2.loli.net/2024/11/24/rEQ9bZe64qa5IA1.jpg" alt="nimg.ws.126"></p><p><strong>说实话，看到这种信息，我内心不是对优胜者的敬佩和崇拜，而是焦虑，漫无目的地想着我自己的未来，我会保研吗？他们的存在会对我的就业产生威胁吗？</strong></p><p>这就得引出我们今天的主题：<strong>优绩主义</strong>。</p><h1 id="优绩主义-1"><a href="#优绩主义-1" class="headerlink" title="优绩主义"></a>优绩主义</h1><p><strong>先来看看百度百科的定义：社会与经济的奖赏应当依据才能、努力和成就这些“优绩”来决定。人们在机会平等的条件下公平竞争，成绩优异者获胜。因此，最好的大学应当录取成绩最出色的学生，收入最高的职位应当留给最有能力的人才。</strong></p><p>这样的思想催生了一系列的制度，包括我们的高考，我们赏罚分明，唯分数论的方针。我们从小就被打上了思想钢印“<strong>每个人的一天都是24小时，我们努力的机会是均等的，努力的越多，回报就越多，这个世界是公平的。</strong>”</p><p>可是一个又一个天赋哥和富二代的现实提醒我们，这是错的。作为没有天赋的平庸的人，我们常常幻想自己只要通过不断地努力就能超越天赋哥，但现实是为了某一个唯分数论的体制，无数的天赋哥正在以苦行僧的方式和干劲，将自己的时间透支到学习当中，以高于常人数倍的产出效率狠狠地撕碎我们的白日梦。</p><p><em>讲一个作为一个中等生的无聊故事：</em></p><p><strong>很久之前，他曾经取得优异的成绩，在老师的眼中发光发热。可是到了一个新的阶段，他发现自己很普通，他无法在得心应手地处理自己曾经擅长的学科，他身边的好友的学习比他好得多，并且正在逐渐爬向巅峰，而他正在以肉眼可见速度越陷越深，他清楚地知道自己的情况，但他无能为力，他只能眼睁睁看着自己堕落，离曾经的自己越来越远。这时他才明白，抖音评论区的一句话：“</strong>中等生+曾经发过光+偏科+朋友学习好+清醒的堕落=绝杀**”是真的。</p><p>自卑和质疑如同潮水一般涌起，天才精英的傲慢嘲讽和老师一句“<strong>我记得你以前学习挺好的呀</strong>”一并袭来，将他打散，才知道这一切都是，化作了一抹泡影。</p><p>这个世界，不是公平的，天赋就是不公平的最大因素，还有家境背景也是。天赋哥可以自己应对学习，家里有背景的可以让教育资源向自己倾斜，<strong>而只有无能为力的中等生在孤立无援地进行着那辛酸血泪的争斗。</strong>只可惜，无论是天才还是常人，在“唯分数论”的教条下都不会怀疑自己的选择，精英可以凭借高层权力的倾斜张牙舞爪，而常人只能把不堪的现状归根于不够努力的自己，然后又一头扎进毫无进展的生活中去。</p><p>这就是优绩主义带来的副作用，它造就了天才的傲慢和失败者的自卑。这种看似公平的成功观造成精英的傲慢和底层民众的怨恨，使成功者深信其<strong>成功是自身努力的结果</strong>，忘记帮助他们的时机和运气，<strong>轻视着</strong>比自己不幸和缺乏资格的人，<strong>剥削着</strong>，<strong>操控着</strong>不被时运和上帝眷顾的无辜的人们，这便是<strong>优绩的暴政</strong>。</p><p>但也就是在这般束缚下，我们以收入将人分为三六九等，我们以地位将人异化得光怪陆离，<strong>我们也是优绩主义的帮凶。</strong></p><h1 id="对大学生活的思考"><a href="#对大学生活的思考" class="headerlink" title="对大学生活的思考"></a>对大学生活的思考</h1><p><strong>言归正传，再回到我们提到的保研问题上来。我们常常将保研视为大学生活中的一座高峰，似乎只有攀登上去才能证明自己的价值。然而，在优绩主义的影响下，保研竞争变得异常激烈，每个人都在拼命追逐那有限的名额。</strong></p><p>但是我们要注意的是，这是彻彻底底的<strong>零和博弈</strong>，保研名额注定是有限的，他保研就意味着你不能保研，一方的获利必定造成另一方的损失。</p><p>在这种零和博弈的困局中，许多人陷入了无尽的内卷漩涡。他们为了那几个保研指标，日夜苦读，放弃了社交、兴趣爱好甚至是健康。原本充满活力与探索精神的大学生活，被各种考试、竞赛和论文填满，变得单调而压抑。</p><p>大学本应是知识探索与人格塑造的殿堂，而非仅仅是保研竞争的战场。我们应该在大学找到真正的自我，<strong>而不是被世俗定义的成功绑架，不是被优绩主义异化为非人。</strong></p><p><strong>所以，如果你失败了，不是因为你不够努力，束缚你的是世俗强行加给你的价值观。如果你失败了，迎接你的不是死亡与堕落，而是很多的选择和不一样的人生，是无限的可能和不一样的风景。</strong></p><p><strong>所以，</strong></p><p><strong>别再为高考活着。</strong></p><p><strong>别再为绩点活着。</strong></p><p><strong>别再为虚荣活着。</strong></p><p><strong>请为你自己活着。</strong></p><p><img src="https://s2.loli.net/2024/11/26/lGtb6Qgm5LqyYU7.png" alt="930ead712b5e426d82c1ab2e701ebb4f.png"></p>]]></content>
    
    
    <categories>
      
      <category>拾遗阁</category>
      
      <category>随笔</category>
      
      <category>哲学思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>思考</tag>
      
      <tag>社会</tag>
      
      <tag>和解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《超脱》：自我与现实的斗争</title>
    <link href="/posts/Detachment/"/>
    <url>/posts/Detachment/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>剧情方面在此不再赘述，笔者建议看看原片，不建议看解说。</strong></p><blockquote><p>During the whole of a dull,dark soundless day 　　 在那年秋季枯燥，灰暗而瞑寂的某个长日里</p><p>　　In the autumn of that year, when the clouds hung oppressively low in heaven 　　沉重的云层低悬于天穹之上</p><p>　　I had been passing alone on the horse’s back 　　我独自一人策马前行</p><p>　　Through the Singularly,dreary tract in the country 　　穿过这片阴沉的，异域般的乡间土地</p></blockquote><blockquote><p>　　and at length found myself, as the shades of the evening drew on 　　最终，当夜幕缓缓降临的时候</p></blockquote><blockquote><p>　　Within the view of melancholy House of Usher 　　厄舍府清冷的景色展现在我眼前</p></blockquote><blockquote><p>　　I know not how it was 　　我未曾目睹它过往的模样</p></blockquote><blockquote><p>　　But with the first glimpse of the building, a sense of insufferable gloom pervaded my spirit 　　但仅凭方才的一瞥，某种难以忍受的阴郁便浸透了我的内心</p><p>　　I looked upon the scene before me the simple landscape features of the domain 　　我望着宅邸周围稀疏的景物</p><p>　　Upon the bleak walls,upon the white trunks of decayed trees 　　围墙荒芜，衰败的树遍体透着白色</p><p>　　With the utter depression souls 　　我的灵魂失语了</p><p>　There was an iciness 　　我的心在冷却</p><p>　　A sinking. 　　下沉</p><p>　　A sickening of the heart 　　显出疲软的病态<br><img src="https://s2.loli.net/2024/11/09/P4pY1JEKksUq8fn.jpg" alt="_1731166957270.jpg"></p></blockquote><h2 id="局外人的无力感"><a href="#局外人的无力感" class="headerlink" title="局外人的无力感"></a>局外人的无力感</h2><p>影片的开始，日记上赫然写着一句话：“我的灵魂与我之间的距离如此遥远，而我的存在却如此真实。”</p><blockquote><p><strong>Some of us believe that we can make a difference. And then sometimes when we wake up and we realize we failed.</strong></p><p><strong>有些人觉得我们能改变世界，但有时，我们醒来后发现，我们并没有做到。</strong></p></blockquote><p><strong>亨利</strong>和其他老师一样，都是教育工作者，处于职业操守，他们希望学生们变好。但对于一群流里流气的迷茫青年来说，这一点无非天方夜谭。面对这自甘堕落的学生们，我们的老师无能为力，他们无法融入学生的世界里，成为了局外人，也成为了可怜人。有的老师如查理·西博德特教授装疯卖傻地维持着这份毫无意义的工作，有的如刘玉玲老师歇斯底里地表达这自己的愤怒和无奈，有的如亨利无谓地放空内心等待任期结束。包括被资本绑架的女校长，所有的教育者只能眼睁睁地看着自己的学生坠入深不见底的底层。</p><p>如果把镜头集中亨利一人，这一点体现的更加淋漓尽致。亨利看见了破旧公交车上卖春反被打的少女，看她被欺凌，看她忍饥挨饿，最多只不过是将她带回了自己的家里提供食宿，甚至无法再提供其他任何的帮助。这一切，都因为亨利一人所承受的痛苦已经是泰山一座，关系不清的祖父在养老院苟延残喘，手下的学生目中无人，梅瑞狄斯正在遭受心魔，亨利的心已经被痛苦占据，没有多余的空间留给其他人了。亨利不是耶稣，他不能永久地承载别人的痛苦，最后也迫不得已将少女送入了管教机构，只能看着祖父挣扎着离开这个世界，只能对梅瑞狄斯的尸体做没有意义的人工呼吸。</p><p>等到影片的后半段，看着狂风吹乱书籍，亨利颓废地坐在讲台中央，一股不可避免的抽离感已从他内心升起，即使他的肉体切切实实存在着，但他似乎感到自己的灵魂已经不再属于这个世界，已经发生了”Detachment”。<br><img src="https://s2.loli.net/2024/11/09/pYoZLCqB3AvJPw1.png" alt="_1731166944959.png"></p><h2 id="畸零人的自我救赎"><a href="#畸零人的自我救赎" class="headerlink" title="畸零人的自我救赎"></a>畸零人的自我救赎</h2><p>我们常说，一部只有悲情而不能给人力量的电影是很难流传的，那么《超脱》的力量就来自于存在主义。</p><p>自我与荒诞的世界紧密相连，不可分割。每当我们渴望拯救自我、寻求救赎时，却常常深感无力。我们品尝着失败的苦涩，在有限的世界里奋力追逐无限的美好，却只能望而兴叹。也许，世间万物不过是一场自我慰藉的幻梦。若我们将自己全然交予自我，抑或彻底委身于现实，最终恐怕都难逃无尽的虚无、失败与荒谬。</p><p>我们曾对世界抱有无限的期望，但如果意外比明天先到，理想坠入万劫不复的深渊，最爱的人与我们阴阳两隔，我们还笑得出来吗？**</p><p>在这样一个世界中，你我都只是以一副躯壳游荡于世间，至于我们的灵魂在哪，没人说得清楚。</p><p>然而，在影片的后半段，亨利与少女在夕阳之下紧紧相拥，似乎给出了面对这荒诞世界的答案。<br><img src="https://s2.loli.net/2024/11/09/jz4ye71kXYQvZf9.png" alt="QQ20241109234409.png"></p><p>在那夕阳的余晖中，亨利与少女的紧紧相拥，仿佛是黑暗世界中的一抹曙光。这一拥抱，不仅仅是两个孤独灵魂的交汇，更是对生活的一种无声抗争，是在荒诞世界中寻找温暖与希望的勇敢尝试。</p><p>他们的拥抱，是对畸零人生的一种超脱。在这个荒诞的世界里，他们不再是孤独的个体，而是彼此的依靠。他们用这一拥抱告诉世人，即使生活充满了痛苦和无奈，我们仍然可以找到属于自己的温暖和希望，即使都是社会的可怜人也可以相互治愈。</p><p>刘玉玲老师在崩溃中大喊：“要无心太容易，但在乎才需要勇气。”如果人对一切都无所谓，无心看待这一切，那就成了真正意义上的躯壳，但我们要做的是拿出勇气和信心，勇于面对过去的离别和不堪，继续自己拥有无限可能的余生，去感知每一次心跳，<strong>才是对生命的尊重，才是对荒诞世界的反抗。</strong></p>]]></content>
    
    
    <categories>
      
      <category>拾遗阁</category>
      
      <category>随笔</category>
      
      <category>哲学思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言的18个经典实例</title>
    <link href="/posts/exampleofc/"/>
    <url>/posts/exampleofc/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>sizeof是一种关键字，是一个单目运算发，不是函数，但使用方法类似于函数，输出的数据类型为%ld，用法是<code>sizeof(变量名)</code>，返回的是内存大小(字节数)。</p><h3 id="1-判断奇偶数"><a href="#1-判断奇偶数" class="headerlink" title="1.判断奇偶数"></a>1.判断奇偶数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br><span class="hljs-type">int</span> number;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;number);<br><span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"偶数"</span>);<br>}<br><span class="hljs-keyword">else</span> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"奇数"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="2-表达式值的运用"><a href="#2-表达式值的运用" class="headerlink" title="2.表达式值的运用"></a>2.表达式值的运用</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> isLowercaseVowel, isUppercaseVowel;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个字母: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;c);<br>   <br>    <span class="hljs-comment">// 小写字母元音</span><br>    isLowercaseVowel = (c == <span class="hljs-string">'a'</span> || c == <span class="hljs-string">'e'</span> || c == <span class="hljs-string">'i'</span> || c == <span class="hljs-string">'o'</span> || c == <span class="hljs-string">'u'</span>);<br>   <br>    <span class="hljs-comment">// 大写字母元音</span><br>    isUppercaseVowel = (c == <span class="hljs-string">'A'</span> || c == <span class="hljs-string">'E'</span> || c == <span class="hljs-string">'I'</span> || c == <span class="hljs-string">'O'</span> || c == <span class="hljs-string">'U'</span>);<br>   <br>    <span class="hljs-comment">// if 语句判断</span><br>    <span class="hljs-keyword">if</span> (isLowercaseVowel || isUppercaseVowel)   <span class="hljs-comment">//这里使用了表达式值</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c  是元音"</span>, c);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c 是辅音"</span>, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="3-内外双层循环"><a href="#3-内外双层循环" class="headerlink" title="3.内外双层循环"></a>3.内外双层循环</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{  <br>    <span class="hljs-comment">//外层循环变量,控制行  </span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">//内层循环变量,控制列   </span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++){  <br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i;j++){  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%dx%d=%d\t"</span>,j,i,i*j);  <br>        }  <br>        <span class="hljs-comment">//每行输出完后换行   </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);   <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-GCD的另一种算法"><a href="#4-GCD的另一种算法" class="headerlink" title="4.GCD的另一种算法"></a>4.GCD的另一种算法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b);<br>    <span class="hljs-keyword">while</span> (b !=<span class="hljs-number">0</span> ){<br>        t = a%b;<br>        a = b;<br>        b = t;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d b=%d t=%d\n"</span>,a , b, t);<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大公约数是%d\n"</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-阶乘"><a href="#4-阶乘" class="headerlink" title="4.阶乘"></a>4.阶乘</h3><h4 id="正序循环："><a href="#正序循环：" class="headerlink" title="正序循环："></a>正序循环：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> factorial = <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br> <br>    <span class="hljs-comment">// 如果输入是负数，显示错误</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error! 负数没有阶乘jiechen"</span>);<br> <br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br>        {<br>            factorial *= i;              <span class="hljs-comment">// factorial = factorial*i;</span><br>        }<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d! = %llu"</span>, n, factorial);<br>    }<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}   <span class="hljs-comment">//顺序法，从1乘到n</span><br></code></pre></td></tr></tbody></table></figure><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiplyNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d! = %ld"</span>, n, multiplyNumbers(n));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiplyNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>    <span class="hljs-comment">//此处的函数在不满足if时会触发递归循环</span><br>{<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> n*multiplyNumbers(n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="5-数位判断"><a href="#5-数位判断" class="headerlink" title="5.数位判断"></a>5.数位判断</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>, &amp;n);<br> <br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)<br>    {<br>        n /= <span class="hljs-number">10</span>;   <span class="hljs-comment">//注意这里不是%10</span><br>        ++count;<br>    }<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"数字是 %d 位数。"</span>, count);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="6-斐波那契"><a href="#6-斐波那契" class="headerlink" title="6.斐波那契"></a>6.斐波那契</h3><h4 id="指定个数"><a href="#指定个数" class="headerlink" title="指定个数"></a>指定个数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> i, n, t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">1</span>, nextTerm;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输出几项: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"斐波那契数列: "</span>);<br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d, "</span>, t1);<br>        nextTerm = t1 + t2;<br>        t1 = t2;<br>        t2 = nextTerm;      <span class="hljs-comment">//这三步使得计算往后挪动1个单位</span><br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="7-整型数字翻转"><a href="#7-整型数字翻转" class="headerlink" title="7.整型数字翻转"></a>7.整型数字翻转</h3><h4 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n, reversedInteger = <span class="hljs-number">0</span>, remainder, originalInteger;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br> <br>    originalInteger = n;<br> <br>    <span class="hljs-comment">// 翻转</span><br>    <span class="hljs-keyword">while</span>( n!=<span class="hljs-number">0</span> )<br>    {<br>        remainder = n%<span class="hljs-number">10</span>;<br>        reversedInteger = reversedInteger*<span class="hljs-number">10</span> + remainder; <span class="hljs-comment">//这里无需设置数位变量</span><br>        n /= <span class="hljs-number">10</span>;<br>    }<br> <br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (originalInteger == reversedInteger)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d 是回文数。"</span>, originalInteger);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d 不是回文数。"</span>, originalInteger);<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="使用字符串："><a href="#使用字符串：" class="headerlink" title="使用字符串："></a>使用字符串：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span>  <span class="hljs-comment">//处理字符串和内存块的库</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">12021</span>;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">10</span>]={<span class="hljs-string">'\0'</span>},s1[<span class="hljs-number">10</span>]={<span class="hljs-string">'\0'</span>};<br>    <span class="hljs-built_in">sprintf</span>(s,<span class="hljs-string">"%d"</span>,a); <span class="hljs-comment">// 将整数转换为字符串</span><br>    <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(s);   <span class="hljs-comment">//字符串长度，这一步可以用循环实现，用"/0";</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    {<br>        s1[j++]=s[i];<br>    }<br>    <span class="hljs-comment">//s[j]='\0';</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %s\n"</span>,s,s1);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(s,s1))<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"整数%d是回文串"</span>,a);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"整数%d不是回文串"</span>,a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="8-表格形式输出数据"><a href="#8-表格形式输出数据" class="headerlink" title="8.表格形式输出数据"></a>8.表格形式输出数据</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>   <span class="hljs-type">int</span> i, j, count;<br> <br>   <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) {<br>      <span class="hljs-keyword">for</span>(j = i; j &lt;=<span class="hljs-number">100</span>; j += <span class="hljs-number">10</span> ) <span class="hljs-comment">//标准双层循环</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %3d"</span>, j);   <span class="hljs-comment">//限制列宽</span><br> <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>   }<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="9-数组拷贝"><a href="#9-数组拷贝" class="headerlink" title="9.数组拷贝"></a>9.数组拷贝</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>   <span class="hljs-type">int</span> original[<span class="hljs-number">10</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>};<br>   <span class="hljs-type">int</span> copied[<span class="hljs-number">10</span>];<br>   <span class="hljs-type">int</span> loop;<br>   <br>   <span class="hljs-keyword">for</span>(loop = <span class="hljs-number">0</span>; loop &lt; <span class="hljs-number">10</span>; loop++) {    <span class="hljs-comment">//单循环遍历整个数组</span><br>      copied[loop] = original[loop];<br>   }<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"元素数组 -&gt; 拷贝后的数组 \n"</span>);<br>   <br>   <span class="hljs-keyword">for</span>(loop = <span class="hljs-number">0</span>; loop &lt; <span class="hljs-number">10</span>; loop++) {<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"   %2d        %2d\n"</span>, original[loop], copied[loop]);<br>   }<br> <br>   <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>约瑟夫环</p><h3 id="10-分解某数作为两个素数的和"><a href="#10-分解某数作为两个素数的和" class="headerlink" title="10.分解某数作为两个素数的和"></a>10.分解某数作为两个素数的和</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">checkPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n, i, flag = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入正整数: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n/<span class="hljs-number">2</span>; ++i)<br>    {<br>        <span class="hljs-comment">// 检测判断</span><br>        <span class="hljs-keyword">if</span> (checkPrime(i) == <span class="hljs-number">1</span>)<br>        {<br>            <span class="hljs-keyword">if</span> (checkPrime(n-i) == <span class="hljs-number">1</span>)         <span class="hljs-comment">//n-i减少了变量设置</span><br>            {<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d = %d + %d\n"</span>, n, i, n - i);<br>                flag = <span class="hljs-number">1</span>;<br>            }<br> <br>        }<br>    }<br> <br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d 不能分解为两个素数。"</span>, n);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br> <br><span class="hljs-comment">// 判断素数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>{<br>    <span class="hljs-type">int</span> i, isPrime = <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n/<span class="hljs-number">2</span>; ++i)<br>    {<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>        {<br>            isPrime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }  <br>    }<br> <br>    <span class="hljs-keyword">return</span> isPrime;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="11-字符串翻转"><a href="#11-字符串翻转" class="headerlink" title="11.字符串翻转"></a>11.字符串翻转</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">reverseSentence</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个字符串: "</span>);<br>    reverseSentence();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">reverseSentence</span><span class="hljs-params">()</span>     <span class="hljs-comment">//递归写法，不读到回车不会停止</span><br>{<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;c);<br> <br>    <span class="hljs-keyword">if</span>( c != <span class="hljs-string">'\n'</span>)<br>    {<br>        reverseSentence();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,c);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="12-冒泡法排序"><a href="#12-冒泡法排序" class="headerlink" title="12. 冒泡法排序"></a>12. 冒泡法排序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 交换两个整数的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> {<br>    <span class="hljs-type">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>}<br><br><span class="hljs-comment">// 冒泡排序函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) {<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {<br>                swap(&amp;arr[j], &amp;arr[j + <span class="hljs-number">1</span>]);<br>            }<br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 打印数组元素的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, arr[i]);<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>};<br>    <span class="hljs-type">int</span> n = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"排序前的数组: "</span>);<br>    printArray(arr, n);<br><br>    bubbleSort(arr, n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"排序后的数组: "</span>);<br>    printArray(arr, n);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="13-矩阵相加"><a href="#13-矩阵相加" class="headerlink" title="13.矩阵相加"></a>13.矩阵相加</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">int</span> r, c, a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>], b[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>], sum[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>], i, j;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入行数 ( 1 ~ 100): "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;r);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入列数 ( 1 ~ 100): "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;c);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n输入第一维数组的元素:\n"</span>);<br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入元素 a%d%d: "</span>,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);<br>        }<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入第二维数组的元素:\n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入元素 a%d%d: "</span>,i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;b[i][j]);<br>        }<br> <br>    <span class="hljs-comment">// 相加</span><br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r;++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;c;++j)<br>        {<br>            sum[i][j]=a[i][j]+b[i][j];<br>        }<br> <br>    <span class="hljs-comment">// 显示结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n二维数组相加结果: \n\n"</span>);<br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r;++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;c;++j)<br>        {<br> <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d   "</span>,sum[i][j]);<br> <br>            <span class="hljs-keyword">if</span>(j==c<span class="hljs-number">-1</span>)<br>            {<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);<br>            }<br>        }<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="14-矩阵转置"><a href="#14-矩阵转置" class="headerlink" title="14.矩阵转置"></a>14.矩阵转置</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>], transpose[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>], r, c, i, j;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入矩阵的行与列: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;r, &amp;c);<br> <br>    <span class="hljs-comment">// 存储矩阵的元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n输入矩阵元素:\n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入元素 a%d%d: "</span>,i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i][j]);<br>        }<br> <br>    <span class="hljs-comment">// 显示矩阵 a[][] */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n输入矩阵: \n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d  "</span>, a[i][j]);<br>            <span class="hljs-keyword">if</span> (j == c<span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);<br>        }<br> <br>    <span class="hljs-comment">// 转换</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;r; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;c; ++j)<br>        {<br>            transpose[j][i] = a[i][j];<br>        }<br> <br>    <span class="hljs-comment">// 显示转换后的矩阵 a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n转换后矩阵:\n"</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;c; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;r; ++j)<br>        {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d  "</span>,transpose[i][j]);<br>            <span class="hljs-keyword">if</span>(j==r<span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);<br>        }<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="15-连接字符串"><a href="#15-连接字符串" class="headerlink" title="15.连接字符串"></a>15.连接字符串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> s1[<span class="hljs-number">100</span>], s2[<span class="hljs-number">100</span>], i, j;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入第一个字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s1);          <span class="hljs-comment">//如果是%c，读入一个就停止</span><br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入第二个字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s2);<br> <br>    <span class="hljs-comment">// 计算字符串 s1 长度</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; s1[i] != <span class="hljs-string">'\0'</span>; ++i);<br> <br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; s2[j] != <span class="hljs-string">'\0'</span>; ++j, ++i)<br>    {<br>        s1[i] = s2[j];<br>    }<br> <br>    s1[i] = <span class="hljs-string">'\0'</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"连接后: %s"</span>, s1);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="16-获取字符串长度"><a href="#16-获取字符串长度" class="headerlink" title="16.获取字符串长度"></a>16.获取字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br>    <span class="hljs-type">int</span> len;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);<br>    len = <span class="hljs-built_in">strlen</span>(s);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"字符串长度: %d"</span>, len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>], i;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);<br> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">'\0'</span>; ++i);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"字符串长度: %d"</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="17-字符类型的统计"><a href="#17-字符类型的统计" class="headerlink" title="17.字符类型的统计"></a>17.字符类型的统计</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">150</span>];<br>    <span class="hljs-type">int</span> i, vowels, consonants, digits, spaces;<br> <br>    vowels =  consonants = digits = spaces = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入一个字符串: "</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%[^\n]"</span>, line);      <span class="hljs-comment">//这会使scanf遇到回车才停止，但这不是一种标准用法。</span><br> <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; line[i]!=<span class="hljs-string">'\0'</span>; ++i)<br>    {<br>        <span class="hljs-keyword">if</span>(line[i]==<span class="hljs-string">'a'</span> || line[i]==<span class="hljs-string">'e'</span> || line[i]==<span class="hljs-string">'i'</span> ||<br>           line[i]==<span class="hljs-string">'o'</span> || line[i]==<span class="hljs-string">'u'</span> || line[i]==<span class="hljs-string">'A'</span> ||<br>           line[i]==<span class="hljs-string">'E'</span> || line[i]==<span class="hljs-string">'I'</span> || line[i]==<span class="hljs-string">'O'</span> ||<br>           line[i]==<span class="hljs-string">'U'</span>)<br>        {<br>            ++vowels;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((line[i]&gt;=<span class="hljs-string">'a'</span>&amp;&amp; line[i]&lt;=<span class="hljs-string">'z'</span>) || (line[i]&gt;=<span class="hljs-string">'A'</span>&amp;&amp; line[i]&lt;=<span class="hljs-string">'Z'</span>))<br>        {<br>            ++consonants;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(line[i]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; line[i]&lt;=<span class="hljs-string">'9'</span>)<br>        {<br>            ++digits;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line[i]==<span class="hljs-string">' '</span>)<br>        {<br>            ++spaces;<br>        }<br>    }<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"元音: %d"</span>,vowels);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n辅音: %d"</span>,consonants);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n数字: %d"</span>,digits);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n空白符: %d"</span>, spaces);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="18-约瑟夫环问题"><a href="#18-约瑟夫环问题" class="headerlink" title="18.约瑟夫环问题"></a>18.约瑟夫环问题</h3><blockquote><p>约瑟夫环（Josephus Problem）是一个经典的数学和计算机科学问题。问题是这样的：有 n个人围成一圈，从某个人开始顺序编号为1,2,3,4,····n 。从编号为 1的人开始报数，报到 m的人出列，然后下一个人重新从 1开始报数，报到 m的人又出列，如此循环，直到所有的人都出列为止。求出列的顺序。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">josephus</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> {<br>    <span class="hljs-type">int</span> people[n];<br>    <span class="hljs-comment">// 初始化数组，0表示未出列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        people[i] = <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录已经出列的人数</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 报数的索引</span><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 报数的数字</span><br>    <span class="hljs-keyword">while</span> (count &lt; n) {<br>        <span class="hljs-keyword">if</span> (people[index] == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">if</span> (num == m) {<br>                people[index] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, index + <span class="hljs-number">1</span>);<br>                count++;<br>                num = <span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                num++;<br>            }<br>        }<br>        index = (index + <span class="hljs-number">1</span>) % n;<br>    }<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">7</span>;  <span class="hljs-comment">// 总人数</span><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 报数到m的人出列</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出列顺序为: "</span>);<br>    josephus(n, m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灯塔</title>
    <link href="/posts/lighthouse/"/>
    <url>/posts/lighthouse/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这应该早就开始写了，现在就把存在脑海里几个月的思绪写下来。</p></blockquote><p>在HDU的一个月，我看见了形形色色的人和事，军训场上的歌者和舞者，舞台上的演员，他们仿佛在展示着青春不同的样子。这对一个来自小城镇的KID来说有点受宠若惊。但同时，见过花园之后就是迷茫，别人的青春如此，我呢？</p><h2 id="你要为你的未来做什么呢？"><a href="#你要为你的未来做什么呢？" class="headerlink" title="你要为你的未来做什么呢？"></a>你要为你的未来做什么呢？</h2><p>我们来讲一个故事，孙悟空跟着菩提老祖跟了7年，学到的本身，打穿天庭，一路降妖除魔，修得正果“斗战胜佛”。为什么这泼猴只学了7年，成就就已经超过了老祖的大半徒弟，我觉得是因为泼猴只盯着“长生”二字，不得长生二字不学，因此习得实用的技能，成了圣佛。这就对上了他说的那两句“<strong>求仙问卜不如自己做主，念佛诵经不如本事在身。”</strong><br>​      说句实话，现在的失业率暂停发布，就业形势并不大好。父母用一袋子钱为我们换来了一袋子书，但是我们有这个把握能用这一袋子书重新换来一袋子钱吗？这是个问题。<br>​      一个善于学习的人能提供的价值，比很多平庸的人在学校里虚度十六年光阴以后能拿出来的东西实用得多。学习和工作是未来人生的主线任务，是未来几十年你赖以生存的基础。一切其他事情，都是伴随工作左右的。毕业大家都拿到同一份工资，不代表毕业五年后大家依然拿同一份工资。<br>因此，变得优秀，不让以后的自己感到悔恨，是大学的主线任务。</p><h2 id="我想成为一个什么样的人"><a href="#我想成为一个什么样的人" class="headerlink" title="我想成为一个什么样的人"></a>我想成为一个什么样的人</h2><p><strong>1.加入ACM集训队</strong><br>这是一个很困难的目标，电专的竞赛强度有目共睹，我只能抱着试一试的心态去尝试。杭电有十七个分队，即使我不能加入其中，也能用所学参加Codeforce等个人赛，技多不压身。<br><strong>2.放弃社恐，收放自如</strong><br>内向不代表扭扭捏捏，我们需要的是能够将自己的想法简明地告知别人的交际能力。这种能力可以不用，但不能没有。<br>不要怕做的不好，很多过去的事情不需要原谅，<strong>因为没人记得。</strong><br><strong>3.控制自己的欲望。</strong><br><strong>欲望的背后绝非自由，而是更深重的桎梏。</strong><br>从欲望的绑架中脱离，我们才知道我们真正想做的是什么。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>人生的路本可以很轻松，只是笔者和读者选择变得更加优秀，既然如此，就将选择的路一直走下去，也许这样<br><strong>直到晚年</strong></p><p><strong>我们才能称自己为爱人</strong></p><p><strong>和感到</strong></p><p><strong>被这个世界爱过。</strong></p><p><img src="https://s2.loli.net/2024/10/16/z2XOuBPsi9vVK3y.jpg" alt="https://s2.loli.net/2024/10/16/z2XOuBPsi9vVK3y.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>随感</tag>
      
      <tag>未来</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的月光</title>
    <link href="/posts/newmoonlight/"/>
    <url>/posts/newmoonlight/</url>
    
    <content type="html"><![CDATA[<h2 id="新的月光"><a href="#新的月光" class="headerlink" title="新的月光"></a>新的月光</h2><p>WillMo博士颓废地坐在鱼冢里，在O5的注视中沉默地迎接晨曦的到来。</p><p>O5回到了他们的圆桌上，MTF收起了枪，随着打卡机的响起，所有的Site又开始了新的呼吸。</p><p>WillMo博士大概确实是与过去诀别了，他将所有关于研究员Lucy的物件都锁在了他办公室无人知晓的角落里。</p><blockquote><p><strong>您有一封新的邮件，请查收。</strong></p><p><strong>-打开</strong></p><p><strong>信息分析部门主管WillMo博士：</strong></p><p>我们的特工突袭了Are We Cool Yet?的一处地点，并缴获了一系列异常项目，相关资料已在附件中给出。其中的一项是一个布满花纹的USB存储设备，我们需要你和你的部门分析其存储原理并尽可能分析其异常性质的来源。如果可以，请在10.4日前将检测报告发送给<br>Ruby博士。</p><p>——艺术异常部副主管Lucy</p></blockquote><p>博士看着这熟悉的署名，感到一股陌生和茫然，但鱼冢里的墓碑很快就把他拉回了现实。</p><p>“同名的“他抱着这样的念头，打开了那台布满灰尘的终端。<br>…….</p><blockquote><p><strong>您的邮件已发送。</strong></p></blockquote><p>最终执念还是战胜了理性，他迫不及待打开基金会的职员数据库，查询了”Lucy”这个字段，然后焦急地等待回应。</p><blockquote><p><strong>员工编号：[权限不足]</strong></p><p><strong>姓名：Lucy ▆▆▆▆</strong></p><p><strong>性别：女</strong></p><p><strong>出生日期：[权限不足]</strong></p><p><strong>国籍：[权限不足]</strong></p><p><strong>所属站点：Site-69</strong></p><p><strong>职位：4级部门副主管</strong></p><p><strong>入职日期：[权限不足]</strong></p><p><strong>安全许可等级：4级</strong></p><p><strong>专长：对研究艺术类异常项目有敏锐感知力，已被指派追踪GOI”Are We Cool yet”。</strong></p></blockquote><p>WillMo博士盯着这几行有限的信息，记起了同级权限人员的信息只能有限查阅。<br>“这是O5的阴谋，还是说只是一个同名者呢？”WillMo博士这样想着，直到夜色吞没了他的思绪。<br> ………<br>大梦一场过后，年轻的博士觉得这位同事的身份已经无关紧要，真正有价值的是那个熟悉的名字。曾经他很弱小，躲在沉默后面对Lucy投以注视，一幕又一幕的背影，在他的自卑下似乎套上了一层神的光辉，就此，成为里无数个月夜中辗转反侧的白月光。但是等他足够强大，带着鲜花和底气来见她时，迎接他的只是一座孤零零的坟墓。而现在，这个名字的出现好像是上帝给的另一次机会，让他能够在余生中将自己从遗憾中拯救回来，去保护那个曾经未能保护的人。</p><p><strong>灯光从窗户透过，WillMo博士正在进行他自己的救赎。</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码，反码，补码一文速通</title>
    <link href="/posts/d6c660ac/"/>
    <url>/posts/d6c660ac/</url>
    
    <content type="html"><![CDATA[<h2 id="机器数：万物之基"><a href="#机器数：万物之基" class="headerlink" title="机器数：万物之基"></a>机器数：万物之基</h2><p><strong>就是二进制数，这些而二进制数能够被机器理解并执行。</strong></p><p><strong>机器数带有符号，计算机字长为8位，所以最高位代表符号，</strong>正数是0<strong>，</strong>负数是1<strong>，例如0000 0011就表示+3，1000 0011就代表-3。</strong> <strong>以上的0000 0011就是机器数。</strong></p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><p>带符号位的机器数对应的十进制数就是<strong>机器数的真值</strong>。例如: 0000 0011=+000 0011=+3</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>即最基本的使用二进制代表十进制，<strong>是人脑最容易理解的表示方式</strong>。</p><p><strong>[+1]原=0000 0001</strong></p><p><strong>第一位不表示值，只表示正负。</strong></p><p><strong>[1111 1111]代表-127</strong></p><p><strong>注：原码的0有两种表示形式：0000 0000和1000 0000</strong></p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p><strong>正数的反码是其本身；</strong></p><p><strong>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</strong></p><p><strong>[+1] = [0000 0001]原= [0000 0001]反</strong></p><p><strong>[-1] = [1000 0001]原= [1111 1110]反</strong></p><p><strong>如果一个反码表示的是负数，人脑****无法直观的看出来</strong>它的数值。通常要将其转换成原码再计算。</p><p><strong>注：0的反码也有两种：0000 0000和1111 1111</strong></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><strong>正数的补码还是其本身；</strong></p><p><strong>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)</strong></p><p><strong>[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补</strong></p><p><strong>[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补</strong></p><p><em>原码，反码，补码是表示同一个数字的三种不同形式。</em></p><h2 id="为什么要有补码和反码？"><a href="#为什么要有补码和反码？" class="headerlink" title="为什么要有补码和反码？"></a>为什么要有补码和反码？</h2><p><strong>计算十进制的表达式： 1 - 1 = 0</strong></p><p><strong>1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [1000 0010]原= -2</strong></p><p><strong>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</strong></p><p><strong>为了解决原码做减法的问题， 出现了反码：</strong></p><p><strong>计算十进制的表达式：1 - 1 = 0</strong></p><p><strong>1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [0000 0001]反+ [1111 1110]反= [1111 1111]反= [1000 0000]原= -0</strong></p><p><strong>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上，虽然人们理解上</strong><strong>+0和-0</strong>是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。</p><p><strong>于是补码的出现，解决了0的符号问题以及0的两个编码问题：</strong></p><p><strong>1-1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [0000 0001]补+ [1111 1111]补= [1 0000 0000]补=[0000 0000]补=[0000 0000]原注意：进位1不在计算机字长里。</strong></p><p><strong>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128：-128的由来如下：</strong></p><p><strong>(-1) + (-127) = [1000 0001]原+ [1111 1111]原= [1111 1111]补+ [1000 0001]补= [1000 0000]补</strong></p><p><strong>-1-127的结果应该是-128，在用补码运算的结果中，[1000  0000]补就是-128，但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。(对-128的补码表示[1000 0000]补，算出来的原码是[0000 0000]原，这是不正确的)</strong></p><p><strong>使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。</strong></p><p><strong>因为机器使用补码，所以对于编程中常用到的有符号的32位int类型，可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WillMo的人事档案</title>
    <link href="/posts/e6ed99b1/"/>
    <url>/posts/e6ed99b1/</url>
    
    <content type="html"><![CDATA[<h2 id="SCP-人事档案"><a href="#SCP-人事档案" class="headerlink" title="SCP 人事档案"></a>SCP 人事档案</h2><p><strong>员工编号：21-1944</strong></p><p><strong>姓名：WillMo ▆▆▆▆</strong></p><p><strong>性别：女</strong></p><p><strong>出生日期：05/11/9</strong></p><p><strong>最高教育经历:杭州▆▆▆▆大学 研究生</strong></p><p><strong>国籍：中国</strong></p><p><strong>所属站点：Site-CN-21</strong></p><p><strong>职位：特遣特工，3级网络工程师</strong></p><p><strong>入职日期：26/09/25</strong></p><p><strong>安全许可等级：3级</strong></p><h2 id="个人简介："><a href="#个人简介：" class="headerlink" title="个人简介："></a>个人简介：</h2><p>WillMo在网络运维方面拥有卓越的专业知识和丰富的经验。2024/06/12，WillMo曾“意外”骇入基金会内部网络而被派遣的MTF逮捕。鉴于其良好合作态度和过硬的技术，WillMo被允许在基金会工作并享受相关福利。</p><p><strong>专业技能：</strong></p><ul><li>应急处理基金会内网入侵情况，维护基金会网络资产的安全。</li><li>在程序架构和智能控制方面具有出色的能力，能够协助相关部门进行开发工作。</li><li>熟练掌握多种语言，包括英语和汉语，便于与不同背景的人员进行沟通和合作。</li><li>精通级特殊载具驾驶(特种车辆、牵引运载车辆、歼击机、空天战斗机，电子对抗飞机等)，以便执行任务时尽快到达指定地点或执行基金会任务。</li><li>基本级使用标准枪械（手枪，突击步枪，狙击步枪等），以便保护站点和任务期间攻击敌对GOI成员甚至异常个体。</li><li>专家级使用重型异常武器（单兵恶魔学防御系统，奇术步枪等），即使该技能已被道德伦理委员会证明为非法获取，但仍能够允许其在高危战况下保护基金会资产甚至摧毁大型异常实体和其他GOI大型载具。</li></ul><p><strong>工作记录：</strong></p><ul><li><strong>协同工程部门共同开发了基金会太空武器-“灵弩”。</strong><br><img src="https://s2.loli.net/2024/09/07/ygkp6EIjtHLefQY.jpg" alt="freecompress-768024303850541199_3_.jpg"></li></ul><blockquote><p>WillMo博士对接“灵弩”时的记录</p></blockquote><ul><li><p>注意到与其年龄和入职时间不符合的技能掌握程度，道德伦理委员会对WillMo博士展开调查并证实其使用了多重非法手段（包括但不限于违规使用异常项目▆▆▆▆等手段）迅速获取了一系列技能，并对其提出弹劾，后被O5议会将提案降级为警告处罚。</p><ul><li>被O5议会配发特别行动令牌，以便收容失效时打开4级权限以下的防爆门。<br><img src="https://s2.loli.net/2024/09/08/SLFyBYnsAM7VKwI.jpg" alt="_W_VWV__TYXR_XWV__S_MVF.jpg"></li></ul></li></ul><blockquote><p>特别行动令牌</p></blockquote><p><strong>心理评估：</strong></p><p><strong>显示出中度的心理稳定性和适应能力，但在面对高压力和特殊异常情况时较难保持冷静和理智。</strong></p><p><strong><del>对欠薪的情况十分抗拒甚至抱有敌意</del>工作情绪稳定，但薪资需要按时发放。</strong></p><p><strong>禁止任何非心理部门的员工在WillMo博士面前提起王▆▆特工，违者将被行政处罚。</strong></p><p><strong>异常效应</strong></p><blockquote><p>现已确认WillMo博士收到AE-231的严重影响</p></blockquote><p><strong>AE-231表现为一种周期性异常现象，周期为7天。在此周期内，AE-231将引发一种与受影响个体高度相似的实体（以下简称AE-231-1）在指定空间内形成，并立即对受影响个体发起攻击。AE-231-1展现出与受影响个体相同的武器操作能力和战斗技巧，并能够自由操纵受影响个体在异常效应期间使用过的所有武器。</strong></p><p><strong>AE-231的影响还包括在受影响区域内生成大量黑色块状物质，这些物质对所有已知破坏手段免疫，且会阻塞该空间与外界的通道。此外，AE-231影响区域内的所有摄像设备均会受到严重干扰，无法提供有效图像。</strong></p><p><strong>在AE-231的影响下，若受影响个体死亡，黑色块状物质将自燃而不释放热量，AE-231-1将消失。若AE-231-1死亡，受影响个体的伤势将迅速自愈，黑色块状物质将逐渐消散。</strong></p><p><strong>备注</strong></p><p>“请求给他配备基金会的便携式能量武器，我们应该让特工出身的他有能力用特殊的武器保护自己，而不是看着他在肉搏中遭遇意外。”</p><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">------特工紫罗兰</span><br></code></pre></td></tr></tbody></table></figure><p>“我理解你说的，但别忘了AE-231-1的武器也会随之变化，更强大的武器只会让他的不确定因素增加。我们一方面会找到破局之法，一方面会为他提供更高强度的战斗训练，我们会尽最大努力保护为基金会做过贡献的职员。”                                                —–人事主任Dr.▆▆</p><p><strong>邮件记录</strong></p><blockquote><p>致O5-1：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">如你所见，我的情况不容乐观，但世界的情况比我要糟得多。人类是被宣判了死刑的囚徒，而我只是一个彻头彻尾的赌徒。我请求议会停止所有试图解除我异常效应的探索，把经费和人力资源移交到更重要的事业上去。我在和AE<span class="hljs-string">-231</span><span class="hljs-string">-1</span>中不止尝到了痛苦，我还知道他是过去的特工束影，他试图杀死我，取代我，变得比上一次更强，才是我活下去唯一的办法，才是人类走下去得唯一道路。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">-----Dr.WillMo</span><br></code></pre></td></tr></tbody></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scp</tag>
      
      <tag>档案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题自定义界面使用markdown</title>
    <link href="/posts/379e7120/"/>
    <url>/posts/379e7120/</url>
    
    <content type="html"><![CDATA[<p>创建自定义界面时，使用以下格式即可，可继承hexo对markdown的特定渲染。</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"markdown-body"</span>&gt;<br>正文<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未来计划</title>
    <link href="/posts/db95087c/"/>
    <url>/posts/db95087c/</url>
    
    <content type="html"><![CDATA[<h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><h2 id="1-顶级期刊"><a href="#1-顶级期刊" class="headerlink" title="1.顶级期刊"></a>1.顶级期刊</h2><p>**可以找老师要，上面论文要多看看，目前已知(待验证)**<strong>Computer Networks</strong></p><p><strong>Journal of Network and Computer Applications</strong></p><p><strong>International Journal of Communication Systems</strong></p><p><strong>Wireless Networks</strong></p><p><strong>Computer Communications</strong></p><h2 id="2-行业现实很重要"><a href="#2-行业现实很重要" class="headerlink" title="2.行业现实很重要"></a>2.行业现实很重要</h2><p><strong>（无论科研还是就业，①参考取景框看世界的专业和行业深度解读视频②各类机构针对该行业的最新行业报告注意是行业不是专业。)</strong></p><h2 id="3-AI大模型"><a href="#3-AI大模型" class="headerlink" title="3.AI大模型"></a>3.AI大模型</h2><p><strong>（Al工具：文心一言，讯飞星火，豆包，kimi等下集更详细）</strong></p><h2 id="4-多媒体技能"><a href="#4-多媒体技能" class="headerlink" title="4.多媒体技能"></a>4.多媒体技能</h2><p><strong>（首推：图片和视频处理。比较推荐做自媒体，只是推荐没说必须，自行选择哟。电脑上：Adobe全家桶中的PS和PR）</strong></p><h2 id="5-办公自动化技能"><a href="#5-办公自动化技能" class="headerlink" title="5.办公自动化技能"></a>5.办公自动化技能</h2><p><strong>（技能建议大家采用需求导向学习：先看入门的基础教程or教材，然后打住，具体运用中碰到实际问题再针对学习进阶的技巧和操作）</strong></p><h2 id="6-理工农科"><a href="#6-理工农科" class="headerlink" title="6.理工农科"></a>6.理工农科</h2><p><strong>（熟练掌握学科要求的软件还有编程]专业英语要打磨好哟，因为学校要求一般是SCI的英文期刊。）</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>可以关注其他专业和自己专业的结合点针对展开其他领域的技能学习)</strong></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><strong>当我写下这份文档，过去的一切已与我彻底诀别，不顾过去，循此苦旅，直抵群星。       ——Dr.WillMo</strong></p><p>2024年8月31日</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
      <tag>计划</tag>
      
      <tag>坚持</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>孤独之旅</title>
    <link href="/posts/4553e66c/"/>
    <url>/posts/4553e66c/</url>
    
    <content type="html"><![CDATA[<h1 id="孤独之旅"><a href="#孤独之旅" class="headerlink" title="孤独之旅"></a>孤独之旅</h1><p>PS:好友写的文，走向成熟与独立是我们每个人的必经之路，特此纪念。              ——WillMo</p><p>开学报告的那一天，公寓楼里楼外都挤满了许多的新生和他们的家长。家长们含辛茹苦地帮孩子打理了几乎所有的东西。</p><p>然而，这个来自遥远的南方的男孩却显得格格不入:蓬头垢面，孤零零一人拖着一堆的行李。在如山高的人海中，他是那么的矮小。</p><p>他独自笨拙地整理着床铺，独自为缺少的物资而发愁、奔波。他不善长打交道，面对一群“外地人”的追问，他只能木讷地笑笑。</p><p>他曾想要当一名好军训学员，可他今天却晕晕地发烧病倒了。</p><p>他曾以为“只要能吃就行”，可他吃下麻婆豆腐后嗓子被辣哑了。</p><p>他曾想为家里省下买书钱而一人劳碌了半天，可他的努力被“买书只能买一整套”的公告给撕碎了。</p><p>椰子树的身影不再，迎面而来的是挺拔的松、杉、柏木；南方的口音不再，四周充满着升调的北方口音；熟悉的朋友们不再，只能一个人慢慢地摸爬滚打……</p><p>“等待我的是什么呢？”他心想，“是将来有可能挂科的数学，内卷的焦虑，还是就业升学的彷徨?亦或者是各种生活上的烦恼……”</p><p>酸痛麻木的四肢和眩晕的大脑不允许他继续想下去了。梦里，他和曾经朝夕相伴的基友们一起，躺在小叶榄仁下，痴痴地望着天上的白云，看它们懒洋洋地<strong>聚拢、舒展，和飘散……</strong><br><a href="https://imgse.com/i/pAEFRbD"><img src="https://s21.ax1x.com/2024/08/30/pAEFRbD.jpg" alt="pAEFRbD.jpg"></a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二周目无伤游行大师</title>
    <link href="/posts/5fcdfef9/"/>
    <url>/posts/5fcdfef9/</url>
    
    <content type="html"><![CDATA[<p><strong>二周目无伤游行大师，也算是了结了类魂从未过无伤的遗憾。</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"> <iframe src="https://player.bilibili.com/player.html?isOutside=true&amp;aid=113001042546265&amp;bvid=BV1atWMeFENn&amp;cid=500001657555076&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lies of p</tag>
      
      <tag>游戏时刻</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于存在主义的一点思考</title>
    <link href="/posts/Infinity/"/>
    <url>/posts/Infinity/</url>
    
    <content type="html"><![CDATA[<h2 id="人生的意义是什么？"><a href="#人生的意义是什么？" class="headerlink" title="人生的意义是什么？"></a>人生的意义是什么？</h2><h3 id="·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母…-而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。"><a href="#·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母…-而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。" class="headerlink" title="·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母….而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。"></a>·人一无所有地来到这个世界上，成为万千生灵中的沧海一粟，除了存在别无其他。这是，人的本质仅仅是人。随着时间，人民会成长，也被附加了一系列的可能：子女，学生，职员，父母….而本质又是由人本身决定的。人可以自由地选择自己的人生和活法，从而重新拥有被重新定义的机会。人不同于工具，对工具而言，在物件被铸造成形之前就被人在图纸上决定了本质，一块铁锭的本质就是剪刀。但人不一样，先是生命的存在，再是本质的定义，即“存在先于本质”。存在的本身是重复，我们在社会的法则中按部就班，两点一线，朝九晚五，成为了流水线上的一枚螺丝钉，在无尽的重复中，存在的意义开始淡化，最后彻底消失，同理，由无数存在组成的世界也是无意义的。而实际上，对个体而言，存在是无意义的，却也不需要意义，因为它凌驾于意义之上。</h3><h3 id="·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”"><a href="#·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”" class="headerlink" title="·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”"></a>·人的存在分为肉体和意识两部分，意识无时不刻观察下着肉体，而肉体又在不断变化，二者的分离存在不可否认，但意识无法做到苏格拉底的“认识你自己”。正如加缪所说：“我与我的灵魂之间是如此遥远，而我的存在又是如此真实。”</h3><h3 id="·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。"><a href="#·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。" class="headerlink" title="·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。"></a>·人是理性的，而世界是非理性的。人可以利用规则去认知规则之外的事，而人与人在一起，就组成一个无序，混乱而非理性的“荒诞”世界：明明可以和平共处，而没有正邪之分的战争却带来的断肢和弹坑；明明合作就能共赢，非得卷的你死我活；有太多的善人遭到报应，有太多的恶人得到的善终，世界的荒诞造就了生活这团无意义，无逻辑，从充满偶然和不公的”虚无“。人们在重复中度过生命，想西西弗推向山顶的巨石。人们在一如既往的重复中开始怀疑人生的意义，而那位伟大的反抗者与创造者的故事就此开始。</h3><h3 id="·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。"><a href="#·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。" class="headerlink" title="·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。"></a>·人生的虚无，世界的荒诞需要由意识来拯救。我们的肉体跟随着我们的意识做的每一件能让我们感到快乐的事，都是有价值的，都是对“意义”的伟大创造，也是对虚无人生的反抗。意识的存在让我们卸下高雅的伪装，回归最本质的快乐，而不用在于他人的目光。我们是通过自己建立起来的自己，而不是通过他人建立起来的自己，我们完全可以拒绝他人对我们的影响，活的真实，自在。</h3><h3 id="·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。"><a href="#·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。" class="headerlink" title="·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。"></a>·“重要的不是治愈，而是带着病痛活下去。”荒谬是起点，而对抗荒谬的是反抗，在重复的人生中追随意识创造意义，就是对虚无最大的反击。别再懊恼过去的错误，别再沉迷于虚无缥缈的未来。活在当下，自认为有意义地消耗每一个小时，爱生活的本身，而不是爱生活的意义。</h3><h2 id="How-do-you-believe-How-do-you-live"><a href="#How-do-you-believe-How-do-you-live" class="headerlink" title="How do you believe How do you live."></a>How do you believe How do you live.</h2><h2 id="你怎样信仰-你就怎样生活"><a href="#你怎样信仰-你就怎样生活" class="headerlink" title="你怎样信仰 你就怎样生活"></a>你怎样信仰 你就怎样生活</h2>]]></content>
    
    
    <categories>
      
      <category>哲学思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实战演练】：绕过Cloudflare获取网站真实IP</title>
    <link href="/posts/e39bfa4e/"/>
    <url>/posts/e39bfa4e/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>笔者暑假内卷累了，网上冲浪的时候发现了需求：</p><p><a href="https://imgse.com/i/pC7Bix1"><img src="https://s1.ax1x.com/2023/07/19/pC7Bix1.png" alt="pC7Bix1.png"></a>看起来还有一定的悬赏，所以试一试。<br>我已获得站长授权，属于合法测试。</p><h3 id="理论思路"><a href="#理论思路" class="headerlink" title="理论思路"></a>理论思路</h3><p>一个网站注定留下蛛丝马迹，具体思路可以是挖洞，搜索引擎（google hacking等），或者RSS邮箱泄密，我们试着第二种。<br>而对于三件套，这是用来查找在线服务的工具，就好比说shodan，与谷歌不同的，Shodan不是在网上搜索网址，而是直接进入互联网的背后通道。Shodan可以说是一款“黑暗”谷歌，一刻不停的在寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。每个月Shodan都会在大约5亿个服务器上日夜不停地搜集信息。<br>信息收集————<a href="https://search.censys.io/">Censys</a>查DNS解析记录————网监三件套（<a href="https://www.shodan.io/">Shodan</a>，<a href="https://www.zoomeye.org/">钟馗之眼</a>，<a href="https://fofa.info/">Fofa</a>）————Nmap扫描端口————逐个排查————访问检验。</p><h3 id="实践开始"><a href="#实践开始" class="headerlink" title="实践开始"></a>实践开始</h3><p>测试目标：<a href="https://develxxxxx.com/%EF%BC%88%E4%BF%9D%E6%8A%A4%EF%BC%8C%E5%85%8D%E5%BE%97%E9%97%B2%E4%BA%BADDos%E6%90%9E%E4%BA%8B%EF%BC%89">https://develxxxxx.com/（保护，免得闲人DDos搞事）</a><br>笔者打开Censys，查了一波。<a href="https://imgse.com/i/pCTaDdH"><img src="https://s1.ax1x.com/2023/07/18/pCTaDdH.png" alt="pCTaDdH.png"></a>什么都没有<br>那就开三件套看看，我们首选Fofa，用起来方便些。先访问一下网站，出现了网站标题：<a href="https://imgse.com/i/pCTawLD"><img src="https://s1.ax1x.com/2023/07/18/pCTawLD.png" alt="pCTawLD.png"></a><br>看起来是一个Hexo的博客，那就以标题为切入点，在Fofa输入<code>title="Hexo" &amp;&amp; country="KR" &amp;&amp; region="Seoul"</code>弹出以下结果：<a href="https://imgse.com/i/pCTayFA"><img src="https://s1.ax1x.com/2023/07/18/pCTayFA.png" alt="pCTayFA.png"></a><br>很好，但一个个排查太浪费时间了，我们做一下<a href="https://port.hwcha.com/">端口扫描</a>，发现了一些开放端口，这会成为判断依据<a href="https://imgse.com/i/pCTaTFs"><img src="https://s1.ax1x.com/2023/07/18/pCTaTFs.png" alt="pCTaTFs.png"></a><br>将扫出来的端口键入搜索语句，有<code>title="Hexo" &amp;&amp; country="KR" &amp;&amp; region="Seoul" &amp;&amp; port="80"</code>这里调用80端口是因为其很常见，一般网站都会以此作为门户，得到了结果<a href="https://imgse.com/i/pCTarod"><img src="https://s1.ax1x.com/2023/07/18/pCTarod.png" alt="pCTarod.png"></a>发现158开头的很明显摆在了第二位，单机终端图标看看网站正文，发现了网站中相应的字样“主题，博主等”<a href="https://imgse.com/i/pCTdpk9"><img src="https://s1.ax1x.com/2023/07/18/pCTdpk9.png" alt="pCTdpk9.png"></a>，猜测得到验证，由此我们就得到了真实IP地址。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本站被暗黑引擎抓到了数据包，可能存在被绕过Cdn而Ddos攻击的风险。<br>感谢阅读！</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hacking</tag>
      
      <tag>网安</tag>
      
      <tag>Cloudflare</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Fluid中添加一言</title>
    <link href="/posts/7938d7d6/"/>
    <url>/posts/7938d7d6/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="一言-隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。"><a href="#一言-隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。" class="headerlink" title="一言,隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。"></a><a href="http://hitokoto.cn/">一言</a>,隶属于萌创团队，其初衷是为用户提供来自动漫，哲学，名著，游戏等来源的一句走心之言，分享对世界的理解和感受。</h3><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="一言可以增加博客的随机性和文学性，有利于丰富网站内容。"><a href="#一言可以增加博客的随机性和文学性，有利于丰富网站内容。" class="headerlink" title="一言可以增加博客的随机性和文学性，有利于丰富网站内容。"></a>一言可以增加博客的随机性和文学性，有利于丰富网站内容。</h3><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="在Fluid的主题配置”（指的是-theme-x2F-fluid-x2F-config-yml-或者-config-fluid-yml，这取决于你安装Fluid的方式）中找到（ctrl-F）Slogan打字机相关配置，将其改为如下配置"><a href="#在Fluid的主题配置”（指的是-theme-x2F-fluid-x2F-config-yml-或者-config-fluid-yml，这取决于你安装Fluid的方式）中找到（ctrl-F）Slogan打字机相关配置，将其改为如下配置" class="headerlink" title="在Fluid的主题配置”（指的是 theme/fluid/_config.yml 或者 _config.fluid.yml，这取决于你安装Fluid的方式）中找到（ctrl+F）Slogan打字机相关配置，将其改为如下配置;"></a>在Fluid的主题配置”（指的是 theme/fluid/_config.yml 或者 _config.fluid.yml，这取决于你安装Fluid的方式）中找到（<strong>ctrl+F</strong>）Slogan打字机相关配置，将其改为如下配置;</h3><figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs autoit">slogan:<br>  enable: <span class="hljs-literal">true</span>       <span class="hljs-meta"># 改为true</span><br><br>  <span class="hljs-meta"># 为空则按 hexo config.subtitle 显示</span><br>  <span class="hljs-meta"># If empty, text based on `subtitle` in hexo config</span><br>  text: <span class="hljs-string">"明眸如初，又见苍岚"</span>           <span class="hljs-meta">#写不写都可以</span><br><br>  <span class="hljs-meta"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span><br>  <span class="hljs-meta"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span><br>  api:<br>    enable: <span class="hljs-literal">true</span><br><br>    <span class="hljs-meta"># 请求地址</span><br>    <span class="hljs-meta"># Request url</span><br>    url: <span class="hljs-string">"https://v1.hitokoto.cn/"</span>            <span class="hljs-meta">#添加一言接口</span><br><br>    <span class="hljs-meta"># 请求方法</span><br>    <span class="hljs-meta"># Request method</span><br>    <span class="hljs-meta"># Available: GET | POST | PUT</span><br>    method: <span class="hljs-string">"GET"</span>                       <br><br>    <span class="hljs-meta"># 请求头</span><br>    <span class="hljs-meta"># Request headers</span><br>    headers: {}   <br><br>    <span class="hljs-meta"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 {<span class="hljs-string">"data"</span>: {<span class="hljs-string">"author"</span>: <span class="hljs-string">"fluid"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"An elegant theme"</span>}}, 则取值字段为 [<span class="hljs-string">'data'</span>, <span class="hljs-string">'content'</span>]；如果返回是列表则自动选择第一项</span><br>    <span class="hljs-meta"># The value field of the string obtained from the response. For example, the response content is {<span class="hljs-string">"data"</span>: {<span class="hljs-string">"author"</span>: <span class="hljs-string">"fluid"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"An elegant theme"</span>}}, the expected `keys: [<span class="hljs-string">'data'</span>,<span class="hljs-string">'content'</span>]`<span class="hljs-comment">; if the return is a list, the first item is automatically selected</span></span><br>    keys: [<span class="hljs-string">'hitokoto'</span>]                    <span class="hljs-meta">#填写Keys</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="保存，键入hexo-clean-hexo-g-hexo-s-即可预览效果。"><a href="#保存，键入hexo-clean-hexo-g-hexo-s-即可预览效果。" class="headerlink" title="保存，键入hexo clean  hexo g hexo s 即可预览效果。"></a>保存，键入<code>hexo clean</code>  <code>hexo g</code> <code>hexo s </code>即可预览效果。</h3>]]></content>
    
    
    <categories>
      
      <category>博客折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《百年孤独》：拉美的呻吟</title>
    <link href="/posts/986a860d/"/>
    <url>/posts/986a860d/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面：本文将从魔幻现实主义的巅峰，拉美的历史，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》"><a href="#写在前面：本文将从魔幻现实主义的巅峰，拉美的历史，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》" class="headerlink" title="写在前面：本文将从魔幻现实主义的巅峰，拉美的历史，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》"></a>写在前面：本文将从魔幻现实主义的巅峰，<strong>拉美的历史</strong>，马孔多的百年，孤独的意义四个板块介绍世界名著《百年孤独》。全文字数较多，建议分段阅读。参考书籍：马尔克斯《百年孤独》斯塔夫利阿诺斯《全球通史》，陆春祥《印加帝国陨落的隐喻》</h1><h2 id="金句摘抄"><a href="#金句摘抄" class="headerlink" title="金句摘抄"></a>金句摘抄</h2><p><font face="华文新魏" color="black" size="6">        1.生命中曾经有过的所有灿烂，原来终究，都需要用寂寞来偿还。</font></p><font face="华文新魏" color="black" size="6"><p>2.无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路。</p><p>3.生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>4.买下一张永久车票，登上一列永无终点的火车。</p><p>5.只是觉得人的内心苦楚无法言说，人的很多举措无可奈何，百年一参透，百年一孤寂。</p><p>6.平庸将你的心灵烘干到没有一丝水分，然后荣光才会拨动你心灵最深处的弦。</p><p>7.预感总是悠然来临，灵光一现，好像一种确凿无疑的信念在瞬间萌生却无从捕捉。</p><p>8.往日的推心置腹已经一去不返，同谋和交流变成敌意与缄默。</p><p>9.过去都是假的，回忆没有归路，春天总是一去不返，最疯狂执着的爱情也终究是过眼云烟。</p><p>10.很多人选择了向虚拟现实的魅力屈服，寄情于自我幻想，这纵然不切实际却更能与人安慰。</p><p>11.我们趋行在人生这个更古的旅途，在坎坷中奔跑，在挫折里涅盘忧愁缠满全身，痛苦飘洒一地我们累，却无从止歇；我们苦，却无法回避。</p><p>12.战争已经被扔进了存放悲惨记忆的高阁它仅仅在开启香槟酒的砰砰爆气里被偶尔提到。</p><p>13.此时微风初起；风中充盈着过往的群声喊喳，日日天竺葵的呢喃，无法排遣的怀念来临前的失望叹息。</p><p>14.一个幸福晚年的秘诀不是别的，而是与孤寂签订一个体面的协定。</p><p>15.一分钟的和好抵得过一辈子的友谊。</p><p>16.寂寞是造化对群居者的诅咒，孤独才是寂寞唯一出口。</p><p>17.多年以后，面对行刑队</p><p>奥雷里亚诺·布恩迪亚上校将会回想起父亲带他</p><p>去见识冰块的那个遥远的下午。</p><p>18.原来时间也会失误和出现意外，并因此迸裂，在某个房间留下永恒的片段。</p><p>19.死神一直追随他的脚步。嗅闻他的行踪，但尚未下定决心，给他最后一击。</p><p>20.“奥雷里亚诺”，他悲伤地敲下发报键，“马孔多在下雨。”</p><p>21.生命从来不曾离开过孤独而独立存在。无论是我们出生、我们成长、</p><p>22.我们相爱还是我们成功失败</p><p>直到最后的最后</p><p>孤独犹如影子一样存在于生命一隅。</p><p>羊皮卷上所载一切</p><p>自永远至永远不会在重复，</p><p>因为注定经受百年孤独的家族</p><p>不会有第二次机会在大地上出现。</p></font><p><font face="华文新魏" color="black" size="6">不到一百年，就不该有人知道其中的含义。<br></font></p><h2 id="魔幻现实主义的巅峰"><a href="#魔幻现实主义的巅峰" class="headerlink" title="魔幻现实主义的巅峰"></a>魔幻现实主义的巅峰</h2><p><font face="华文新魏" color="black" size="6"><img src="https://s1.ax1x.com/2022/08/13/vNtcFJ.jpg" alt="image"><br>《百年孤独》是哥伦比亚作家加西亚·马尔克斯创作的长篇小说，是其代表作，也是拉丁美洲魔幻现实主义文学的代表作，被誉为“再现拉丁美洲历史社会图景的鸿篇巨著””魔幻现实主义的巅峰之作“。<br>什么是魔幻现实主义？魔幻现实主义指的是20世纪的一种绘画，这种绘画用现实主义（REALISM）的精确来描绘物体，但是却悖论般地表现出一种由于对时空因素进行迥然不同的并置所致的奇异的效果，后继而成为一种文学艺术形式。魔幻现实主义来自于拉美，在黑暗的殖民统治下，这种表现手法被广泛用于揭露社会弊端，抨击社会现实，是顺应历史之流的产物。</font></p><hr><h2 id="拉美的历史"><a href="#拉美的历史" class="headerlink" title="拉美的历史"></a>拉美的历史</h2><p><font face="华文新魏" color="black" size="6">美洲坐落于世界西方，是世界上自然条件最为优越的大陆之一。它有着锯齿形的海岸线和大流量的运河。五大湖为森林提供了充足的水源，原始的自然环境为繁多的动植物提供了居所，全大陆地形较为平整，适宜居住。<br>据考察，3万年前，来自西伯利亚的人们穿过白令海来到阿拉斯加，成为了开垦美洲的先驱者。即使早期移民来自于经济不发达的地区，但经过数千年的耕耘，美洲印第安人发展了丰富多彩的种种文化，其中包括2000种截然不同的文字和不同形式的耕作制度。此外，印第安人培育了100多种植物，其中的南瓜,玉米，可可，花生在现代都是极为重要的作物。<br>美洲印第安人逐渐形成了三大文明：玛雅文明，阿兹特克文明和印加文明。<br>15世纪，哥伦布的船队发现了美洲，就此带来了枪炮，战争，掠夺，动荡和拉美的伤口。石质砍刀对上火枪和战马，倒下的只有印第安人的尸体。尸横遍野，印第安人试图用发达的宗教和文化掩盖技术上落后的事实，但西方人的炮火始终没有停止咆哮。<br>仅仅一小群冒险者就可以轻易推翻和根除三大文明，技术压制当然不是唯一因素。另外一个因素是，反抗的一方缺乏最起码的团结。被夹在两大洋之间的美洲不具备跨过大海与其他文明交流的能力，甚至各印第安文明之间也缺乏交流，因此没有相互影响.</font></p><font face="华文新魏" color="black" size="6"><blockquote><p>关于秘鲁和中美洲之间的相互关系，完全可以说，人们已经承认，在从形成期到西班牙人入侵这段漫长的时期内，所有证明这些地区之间存在着相互联系的实物或记录都是不可靠的。</p></blockquote></font><p><font face="华文新魏" color="black" size="6">硝烟过后，殖民者开始切割美洲的血管，用血腥的手去夺取血腥的财宝。欧洲列强对拉丁美洲实行了三次掠夺。<br>一是直接性掠夺：<br>1532年9月，殖民者皮萨罗对印加帝国发动战争，俘获了国王阿塔瓦尔帕，勒索了数万磅的真金白银。得到百分之二十分成的西班牙王室又加大战争拨款，给拉美的财富给予重创。手持枪炮的士兵把拉美的金银送到欧洲贵族的腰包里，用来装裱他们的城堡。<br>二是土地掠夺：在榨干拉美的金银之后，英国开始进行三角贸易，从非洲拉来的黑奴在拉美的土地上种植香蕉，烟草等让西方贵族满意的商品，再运到欧洲大肆出售。土地的过度利用和粮食作物的稀缺使拉美人民苦不堪言。<br>三是经济掠夺：长期被列强统治的拉美根本没有发展工业的机会，拉美就不可能制作自己的工艺品。而美洲人民只好依赖出口低级农产品勉强过活，但却不得不用十倍以上的价格买回欧洲的工艺品，列强的资本输出使得美洲更加贫困。<br>拉美的文明在外来侵略的浪潮中愈加贫困，丧失了出路和希望。</font></p><hr><h2 id="马孔多的百年"><a href="#马孔多的百年" class="headerlink" title="马孔多的百年"></a>马孔多的百年</h2><p><font face="华文新魏" color="black" size="6">《百年孤独》讲述了以何塞·阿尔卡蒂奥·布恩迪亚为首的乡亲在荒野之中开辟新家园“马孔多”的故事。随时代的改变，马孔多先后经历了兴盛与衰败，贫苦与富足，安定与动乱，繁华与死寂。而布恩迪亚家族的故事也在飓风的呼啸声和蚂蚁的啃咬声中走到了尽头，”一场突如其来的飓风把整个儿马孔多镇从地球上刮走，从此这个村镇就永远地消失了。</font></p><h2 id="孤独的意义"><a href="#孤独的意义" class="headerlink" title="孤独的意义"></a>孤独的意义</h2><p>  <font face="华文新魏" color="black" size="5">作者马尔克斯出生于哥伦比亚，他在见证了拉美令人哭泣和绝望的历史后写下了这部荒诞的家族史，因此，《百年孤独》很大程度上是拉美历史的缩影。从何塞·阿尔卡蒂奥·布恩迪亚的玻璃城市梦境和布恩迪亚家族的抗争史中可知，《百年孤独》的主题便是孤独与绝望，孤独在绝望中愈演愈烈，绝望在孤独中肆意生长。<br>   孤独这一主题是在书中的描写中揭示的。书中极少对家族成员之间的交流进行描写，展示在我们面前的好像是一个没有感情，没有信任，没有了解的可悲家庭。孤独是布恩迪亚家族的家徽，每位家庭成员不由自主地佩戴它，而他们在试图摆脱孤独时又被孤独束缚住了手脚，最后的结果不是在无尽的空虚中了结了自己就是再次被扔回到孤独的深海中去，家族的创始人何塞·阿尔卡蒂奥·布恩迪亚晚年因为思想守旧，在面对新事物时又被孤独击败，疯癫地成为树下的可怜虫；奥雷里亚诺上校一生经历了32场战争，遭遇14次暗杀，73次埋伏，后因战争的不明意义试图开枪自杀。<br>    绝望来自于失败，而失败源于抗争，布恩迪亚家族史可以说是一部抗争史。在故事的开始，夫妻二人就为了逃避骂声和偏见而开辟马孔多；后人又在为了某些东旭（尊严，自由，金钱）而抗争。上校起初以自由为口号发动战争，后才发觉自己是在用权力和战火掩饰自己的胆怯，仅仅是为了尊严而开枪；何塞·阿尔卡蒂奥第二引领工人运动，为工人利益而斗争······而这些英雄般的斗争，也最终迎来了结局：自由党上校的全线投降和3000名工人横七竖八的尸体···，人们在失败中绝望，在绝望中更加孤独。但有一人例外，与孤独斗争许久的乌尔苏拉被认为是家族精神的代表，她竭力反抗，想尽一切办法联合家族和马孔多，但依然没有成效和出路，最终在晚年被岁月追上，化作尘土。<br> 书中有两个值得注意的细节：一是上校的同僚马尔克斯上校与作者同名。像对马孔多一样，马尔克斯也见证了拉美的历史。却又对苟延残喘的拉美爱莫能助。二是家族中重复命名的每一代人都没有重复上一代人所做的事，但都无一例外地迎来了失败的结局。<br> 本书最大的手法就是以小见大，马孔多已不仅仅是荒野中的一个小镇，更是整个拉美文明的代表。同时拥有富饶的自然资源和广大贫苦人民的拉美是畸形的，也是可悲的。鲁迅说：“悲剧就是将有价值的东西毁灭给人看。”西方殖民者三次掠夺美洲，以枪炮掏空美洲的内脏，压迫着拉美的人民。面对外来文化，拉美人民不是没有抗争过，而是像书中的重复命名一样：尽管方式各不相同，但最终躲不开封建主义和资本主义的打击，逃不掉失败的命运。这也许就是为什么羊皮卷上写的：“家族的第一个人被绑在树上死去，最后一个人被蚂蚁吃掉。”有如此强的宿命感。黑格尔说：“人类从历史中学到的唯一教训，就是没有从历史中吸取到任何教训。”书中“失眠症”的后果就是失忆。拉美越来越多年轻人开始忘记拉美那段屈辱而血腥的历史，再加上在少数人的别有用心，拉美的历史逐渐不被人提起，成为历史的悲剧。</font><br> <font face="华文新魏" color="black" size="6">马尔克斯上校看着窗外的大雨说：“马孔多在下雨。”这场雨到现在都没有停，而真正造成在场雨的人不知道，也不在乎。</font></p>]]></content>
    
    
    <categories>
      
      <category>拾遗阁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Book</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
